
<!DOCTYPE html>
<html lang="en" data-color-scheme="auto">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Source: points.js | Points</title>
    <meta name="description" content="A Generative Art library made in WebGPU"><meta name="keywords" content="javascript, webgl, crative-coding, shaders, generative-art, webgpu, genart, wgsl">
    <link rel="icon" title="dummy" href="data:image/x-icon;base64,AA">
    <script src="scripts/docolatte.min.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/simplebar.min.css"><link type="text/css" rel="stylesheet" href="styles/hljs/nord.css"><link type="text/css" rel="stylesheet" href="styles/docolatte.min.css">
    <script>window.$docolatte.config = {"searchLimit":8,"syncHash":"scrollend"}</script>
    <noscript><style>[data-ready] { visibility: visible !important; }</style></noscript>
    <style>.header .masthead .title { font-size: 1.5em; font-family: Helvetica, sans-serif; }</style>
</head>
<body class="config">
<div class="site">

    <header class="header">
        <div class="masthead">
            <a class="link" href="https://github.com/Absulit/points"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home icon"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg></a>
            <a class="title" href="index.html">Points</a>
        </div>
        <div class="topbar">
            <h1 class="page-title">
                <a href="#">Source: points.js</a>
            </h1>
            <a class="light-switch" title="Switch light/dark mode" href="#"><i class="label auto">
<svg  class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	<path d="M 12 3 A 9 9 0 0 0 12 21 Z" stroke="none" fill="currentColor"/>
	<circle cx="12" cy="12" r="9"/>
</svg></i><i class="label light"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun icon"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></i><i class="label dark"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon icon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></i></a>
        </div>
    </header>

    <div class="primary">
        <main class="main">
            



    
<article class="src">
    <pre class="prettyprint source linenums lang-js"><span class="_char">_</span><code>'use strict';
import UniformKeys from './UniformKeys.js';
import VertexBufferInfo from './VertexBufferInfo.js';
import ShaderType from './ShaderType.js';
import RenderPass from './RenderPass.js';
import RenderPasses from './RenderPasses.js';
import Coordinate from './coordinate.js';
import RGBAColor from './color.js';
import Clock from './clock.js';
import defaultStructs from './core/defaultStructs.js';
import { defaultVertexBody } from './core/defaultFunctions.js';
import { dataSize, getArrayTypeData, isArray, typeSizes } from './data-size.js';
import { loadImage, strToImage } from './texture-string.js';
import LayersArray from './LayersArray.js';
import UniformsArray from './UniformsArray.js';

/**
 * Main class Points
 * @class Points
 * @example
 * import Points from 'points';
 * const points = new Points('canvas');
 *
 * let renderPasses = [
 *     new RenderPass(vert1, frag1, compute1),
 *     new RenderPass(vert2, frag2, compute2)
 * ];
 *
 * await points.init(renderPasses);
 * update();
 *
 * function update() {
 *     points.update();
 *     requestAnimationFrame(update);
 * }
 *
 * @category Main
 *
 */
class Points {
    #canvasId = null;
    #canvas = null;
    #device = null;
    #context = null;
    #presentationFormat = null;
    #renderPasses = null;
    #postRenderPasses = [];
    #vertexBufferInfo = null;
    #buffer = null;
    #internal = false;
    #presentationSize = null;
    #depthTexture = null;
    #vertexArray = [];
    #numColumns = 1;
    #numRows = 1;
    #commandsFinished = [];
    #renderPassDescriptor = null;
    #uniforms = new UniformsArray();
    #storage = [];
    #readStorage = [];
    #samplers = [];
    #textures2d = [];
    #texturesToCopy = [];
    #textures2dArray = [];
    #texturesExternal = [];
    #texturesStorage2d = [];
    #bindingTextures = [];
    #layers = new LayersArray();
    #originalCanvasWidth = null;
    #originalCanvasHeigth = null;
    #clock = new Clock();
    #time = 0;
    #delta = 0;
    #epoch = 0;
    #mouseX = 0;
    #mouseY = 0;
    #mouseDown = false;
    #mouseClick = false;
    #mouseWheel = false;
    #mouseDelta = [0, 0];
    #fullscreen = false;
    #fitWindow = false;
    #lastFitWindow = false;
    #sounds = []; // audio
    #events = new Map();
    #events_ids = 0;
    #dataSize = null;

    constructor(canvasId) {
        this.#canvasId = canvasId;
        this.#canvas = document.getElementById(this.#canvasId);
        if (this.#canvasId) {
            this.#canvas.addEventListener('click', e => {
                this.#mouseClick = true;
            });
            this.#canvas.addEventListener('mousemove', this.#onMouseMove, { passive: true });
            this.#canvas.addEventListener('mousedown', e => {
                this.#mouseDown = true;
            });
            this.#canvas.addEventListener('mouseup', e => {
                this.#mouseDown = false;
            });
            this.#canvas.addEventListener('wheel', e => {
                this.#mouseWheel = true;
                this.#mouseDelta = [e.deltaX, e.deltaY];
            }, { passive: true });
            this.#originalCanvasWidth = this.#canvas.clientWidth;
            this.#originalCanvasHeigth = this.#canvas.clientHeight;
            window.addEventListener('resize', this.#resizeCanvasToFitWindow, false);
            document.addEventListener("fullscreenchange", e => {
                this.#fullscreen = !!document.fullscreenElement;
                if (!this.#fullscreen &amp;&amp; !this.#fitWindow) {
                    this.#resizeCanvasToDefault();
                }
                if (!this.#fullscreen) {
                    this.fitWindow = this.#lastFitWindow;
                }
            });
        }
    }

    #resizeCanvasToFitWindow = () => {
        if (this.#fitWindow) {
            const { offsetWidth, offsetHeight } = this.#canvas.parentNode;
            this.#canvas.width = offsetWidth;
            this.#canvas.height = offsetHeight;
            this.#setScreenSize();
        }
    }

    #resizeCanvasToDefault = () => {
        this.#canvas.width = this.#originalCanvasWidth;
        this.#canvas.height = this.#originalCanvasHeigth;
        this.#setScreenSize();
    }

    #setScreenSize = () => {
        this.#presentationSize = [
            this.#canvas.clientWidth,
            this.#canvas.clientHeight,
        ];
        this.#context.configure({
            device: this.#device,
            format: this.#presentationFormat,
            //size: this.#presentationSize,
            width: this.#canvas.clientWidth,
            height: this.#canvas.clientHeight,
            alphaMode: 'premultiplied',
            // Specify we want both RENDER_ATTACHMENT and COPY_SRC since we
            // will copy out of the swapchain texture.
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
        });
        this.#depthTexture = this.#device.createTexture({
            size: this.#presentationSize,
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
        // this is to solve an issue that requires the texture to be resized
        // if the screen dimensions change, this for a `setTexture2d` with
        // `copyCurrentTexture` parameter set to `true`.
        this.#textures2d.forEach(texture2d => {
            if (!texture2d.imageTexture &amp;&amp; texture2d.texture) {
                this.#createTextureBindingToCopy(texture2d);
            }
        })
    }

    #onMouseMove = e => {
        // get position relative to canvas
        const rect = this.#canvas.getBoundingClientRect();
        this.#mouseX = e.clientX - rect.left;
        this.#mouseY = e.clientY - rect.top;
    }

    /**
     * Sets a `param` (predefined struct already in all shader)
     * as uniform to send to all shaders.
     * A Uniform is a value that can only be changed
     * from the outside (js side, not the wgsl side),
     * and unless changed it remains consistent.
     * @param {string} name name of the Param, you can invoke it later in shaders as `Params.[name]`
     * @param {Number|Boolean|Array&lt;Number>} value Single number or a list of numbers. Boolean is converted to Number.
     * @param {string} structName type as `f32` or a custom struct. Default `f32`.
     * @return {Object}
     *
     * @example
     * // js
     *  points.setUniform('color0', options.color0, 'vec3f');
     *  points.setUniform('color1', options.color1, 'vec3f');
     *  points.setUniform('scale', options.scale, 'f32');
     *
     * // wgsl string
     * let finalColor:vec4f = mix(color0, color1, params.scale);
     */
    setUniform(name, value, structName = null) {
        let uniformToUpdate = this.#nameExists(this.#uniforms, name);
        if (uniformToUpdate &amp;&amp; structName) {
            //if name exists is an update
            throw '`setUniform()` can\'t set the structName of an already defined uniform.';
        }
        if (uniformToUpdate) {
            uniformToUpdate.value = value;
            return;
        }
        if (structName &amp;&amp; isArray(structName)) {
            throw `${structName} is an array, which is currently not supported for Uniforms.`;
        }
        const uniform = {
            name: name,
            value: value,
            type: structName,
            size: null,
            internal: this.#internal
        }
        this.#uniforms.push(uniform);
        return uniform;
    }
    /**
     * Updates a list of uniforms
     * @param {Array&lt;{name:String, value:Number}>} arr object array of the type: `{name, value}`
     */
    updateUniforms(arr) {
        arr.forEach(uniform => {
            const variable = this.#uniforms.find(v => v.name === uniform.name);
            if (!variable) {
                throw '`updateUniform()` can\'t be called without first `setUniform()`.';
            }
            variable.value = uniform.value;
        })
    }

    /**
     * Creates a persistent memory buffer across every frame call. See [GPUBuffer](https://www.w3.org/TR/webgpu/#gpubuffer)
     * &lt;br>
     * Meaning it can be updated in the shaders across the execution of every frame.
     * &lt;br>
     * It can have almost any type, like `f32` or `vec2f` or even array&lt;f32>.
     * @param {string} name Name that the Storage will have in the shader
     * @param {string} structName Name of the struct already existing on the
     * shader. This will be the type of the Storage.
     * @param {boolean} read if this is going to be used to read data back
     * @param {ShaderType} shaderType this tells to what shader the storage is bound
     * @returns {Object}
     *
     * @example
     * // js
     * points.setStorage('result', 'f32');
     *
     * // wgsl string
     * result[index]  = 128.;
     *
     * @example
     * // js
     * points.setStorage('colors', 'array&lt;vec3f, 6>');
     *
     * // wgsl string
     * colors[index] = vec3f(248, 208, 146) / 255;
     */
    setStorage(name, structName, read, shaderType, arrayData) {
        if (this.#nameExists(this.#storage, name)) {
            throw `\`setStorage()\` You have already defined \`${name}\``;
        }
        const storage = {
            mapped: !!arrayData,
            name: name,
            structName: structName,
            // structSize: null,
            shaderType: shaderType,
            read: read,
            buffer: null,
            internal: this.#internal
        }
        this.#storage.push(storage);
        return storage;
    }

    /**
     * Creates a persistent memory buffer across every frame call that can be updated.
     * See [GPUBuffer](https://www.w3.org/TR/webgpu/#gpubuffer)
     * &lt;br>
     * Meaning it can be updated in the shaders across the execution of every frame.
     * &lt;br>
     * It can have almost any type, like `f32` or `vec2f` or even array&lt;f32>.
     * &lt;br>
     * The difference with {@link Points#setStorage|setStorage} is that this can be initialized
     * with data.
     * @param {string} name Name that the Storage will have in the shader.
     * @param {Uint8Array&lt;ArrayBuffer>} arrayData array with the data that must match the struct.
     * @param {string} structName Name of the struct already existing on the
     * shader. This will be the type of the Storage.
     * @param {boolean} read if this is going to be used to read data back.
     * @param {ShaderType} shaderType this tells to what shader the storage is bound
     *
     * @example
     * // js examples/data1
     * const firstMatrix = [
     *     2, 4 , // 2 rows 4 columns
     *     1, 2, 3, 4,
     *     5, 6, 7, 8
     * ];
     * const secondMatrix = [
     *     4, 2, // 4 rows 2 columns
     *     1, 2,
     *     3, 4,
     *     5, 6,
     *     7, 8
     * ];
     *
     * // Matrix should exist as a struct in the wgsl shader
     * points.setStorageMap('firstMatrix', firstMatrix, 'Matrix');
     * points.setStorageMap('secondMatrix', secondMatrix, 'Matrix');
     * points.setStorage('resultMatrix', 'Matrix', true); // this reads data back
     *
     * // wgsl string
     * struct Matrix {
     *     size : vec2&lt;f32>,
     *     numbers: array&lt;f32>,
     * }
     *
     * resultMatrix.size = vec2(firstMatrix.size.x, secondMatrix.size.y);
     */
    setStorageMap(name, arrayData, structName, read = false, shaderType = null) {
        const storageToUpdate = this.#nameExists(this.#storage, name)
        if (storageToUpdate) {
            storageToUpdate.array = arrayData;
            return storageToUpdate;
        }
        const storage = {
            mapped: true,
            name: name,
            structName: structName,
            shaderType: shaderType,
            array: arrayData,
            buffer: null,
            read: read,
            internal: this.#internal
        }
        this.#storage.push(storage);
        return storage;
    }
    async readStorage(name) {
        let storageItem = this.#readStorage.find(storageItem => storageItem.name === name);
        let arrayBuffer = null;
        let arrayBufferCopy = null;
        if (storageItem) {
            await storageItem.buffer.mapAsync(GPUMapMode.READ);
            arrayBuffer = storageItem.buffer.getMappedRange();
            arrayBufferCopy = new Float32Array(arrayBuffer.slice(0));
            storageItem.buffer.unmap();
        }
        return arrayBufferCopy;
    }

    /**
     * Layers of data made of `vec4f`.
     * This creates a storage array named `layers` of the size
     * of the screen in pixels;
     * @param {Number} numLayers
     * @param {ShaderType} shaderType
     *
     * @example
     * // js
     * points.setLayers(2);
     *
     * // wgsl string
     * var point = textureLoad(image, vec2&lt;i32>(ix,iy), 0);
     * layers[0][pointIndex] = point;
     * layers[1][pointIndex] = point;
     */
    setLayers(numLayers, shaderType) {
        // TODO: check what data to return
        // TODO: improve jsdoc because the array definition is confusing
        for (let layerIndex = 0; layerIndex &lt; numLayers; layerIndex++) {
            this.#layers.shaderType = shaderType;
            this.#layers.push({
                name: `layer${layerIndex}`,
                size: this.#canvas.width * this.#canvas.height,
                structName: 'vec4&lt;f32>',
                structSize: 16,
                array: null,
                buffer: null,
                internal: this.#internal
            });
        }
    }

    #nameExists(arrayOfObjects, name) {
        return arrayOfObjects.find(obj => obj.name == name);
    }

    /**
     * Creates a `sampler` to be sent to the shaders. Internally it will be a {@link GPUSampler}
     * @param {string} name Name of the `sampler` to be called in the shaders.
     * @param {GPUSamplerDescriptor} descriptor `Object` with properties that affect the image. See example below.
     * @returns {Object}
     *
     * @example
     * // js
     * const descriptor = {
     *  addressModeU: 'repeat',
     *  addressModeV: 'repeat',
     *  magFilter: 'nearest',
     *  minFilter: 'nearest',
     *  mipmapFilter: 'nearest',
     *  //maxAnisotropy: 10,
     * }
     *
     * points.setSampler('imageSampler', descriptor);
     *
     * // wgsl string
     * let value = texturePosition(image, imageSampler, position, uvr, true);
     */

    setSampler(name, descriptor, shaderType) {
        if ('sampler' == name) {
            throw 'setSampler: `name` can not be sampler since is a WebGPU keyword.';
        }
        const exists = this.#nameExists(this.#samplers, name)
        if (exists) {
            console.warn(`setSampler: \`${name}\` already exists.`);
            return exists;
        }
        // Create a sampler with linear filtering for smooth interpolation.
        descriptor = descriptor || {
            addressModeU: 'clamp-to-edge',
            addressModeV: 'clamp-to-edge',
            magFilter: 'linear',
            minFilter: 'linear',
            mipmapFilter: 'linear',
            //maxAnisotropy: 10,
        };
        const sampler = {
            name: name,
            descriptor: descriptor,
            shaderType: shaderType,
            resource: null,
            internal: this.#internal
        };
        this.#samplers.push(sampler);
        return sampler;
    }

    /**
     * Creates a `texture_2d` in the shaders.&lt;br>
     * Used to write data and then print to screen.&lt;br>
     * It can also be used for write the current render pass (what you see on the screen)
     * to this texture, to be used in the next cycle of this render pass; meaning
     * you effectively have the previous frame data before printing the next one.
     *
     * @param {String} name Name to call the texture in the shaders.
     * @param {boolean} copyCurrentTexture If you want the fragment output to be copied here.
     * @returns {Object}
     *
     * @example
     * // js
     * points.setTexture2d('feedbackTexture', true);
     *
     * // wgsl string
     * var rgba = textureSampleLevel(
     *     feedbackTexture, feedbackSampler,
     *     vec2&lt;f32>(f32(GlobalId.x), f32(GlobalId.y)),
     *     0.0
     * );
     *
     */
    setTexture2d(name, copyCurrentTexture, shaderType, renderPassIndex) {
        const exists = this.#nameExists(this.#textures2d, name);
        if (exists) {
            console.warn(`setTexture2d: \`${name}\` already exists.`);
            return exists;
        }
        const texture2d = {
            name: name,
            copyCurrentTexture: copyCurrentTexture,
            shaderType: shaderType,
            texture: null,
            renderPassIndex: renderPassIndex,
            internal: this.#internal
        }
        this.#textures2d.push(texture2d);
        return texture2d;
    }


    copyTexture(nameTextureA, nameTextureB) {
        const texture2d_A = this.#nameExists(this.#textures2d, nameTextureA);
        const texture2d_B = this.#nameExists(this.#textures2d, nameTextureB);
        if (!(texture2d_A &amp;&amp; texture2d_B)) {
            console.error('One of the textures does not exist.');
        }
        const a = texture2d_A.texture;
        const cubeTexture = this.#device.createTexture({
            size: [a.width, a.height, 1],
            format: 'rgba8unorm',
            usage:
                GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT,
        });
        texture2d_B.texture = cubeTexture;
        this.#texturesToCopy.push({ a, b: texture2d_B.texture });
    }

    /**
     * Loads an image as `texture_2d` and then it will be available to read
     * data from in the shaders.&lt;br>
     * Supports web formats like JPG, PNG.
     * @param {string} name identifier it will have in the shaders
     * @param {string} path image address in a web server
     * @param {ShaderType} shaderType in what shader type it will exist only
     * @returns {Object}
     *
     * @example
     * // js
     * await points.setTextureImage('image', './../myimage.jpg');
     *
     * // wgsl string
     * let rgba = texturePosition(image, imageSampler, position, uvr, true);
     */
    async setTextureImage(name, path, shaderType = null) {
        const texture2dToUpdate = this.#nameExists(this.#textures2d, name);
        const response = await fetch(path);
        const blob = await response.blob();
        const imageBitmap = await createImageBitmap(blob);
        if (texture2dToUpdate) {
            if (shaderType) {
                throw '`setTextureImage()` the param `shaderType` should not be updated after its creation.';
            }
            texture2dToUpdate.imageTexture.bitmap = imageBitmap;
            const cubeTexture = this.#device.createTexture({
                size: [imageBitmap.width, imageBitmap.height, 1],
                format: 'rgba8unorm',
                usage:
                    GPUTextureUsage.TEXTURE_BINDING |
                    GPUTextureUsage.COPY_SRC |
                    GPUTextureUsage.COPY_DST |
                    GPUTextureUsage.RENDER_ATTACHMENT,
            });
            this.#device.queue.copyExternalImageToTexture(
                { source: imageBitmap },
                { texture: cubeTexture },
                [imageBitmap.width, imageBitmap.height]
            );
            texture2dToUpdate.texture = cubeTexture;
            return texture2dToUpdate;
        }
        const texture2d = {
            name: name,
            copyCurrentTexture: false,
            shaderType: shaderType,
            texture: null,
            imageTexture: {
                bitmap: imageBitmap
            },
            internal: this.#internal
        }
        this.#textures2d.push(texture2d);
        return texture2d;
    }

    /**
     * Loads a text string as a texture.&lt;br>
     * Using an Atlas or a Spritesheet with UTF-16 chars (`path`) it will create a new texture
     * that contains only the `text` characters.&lt;br>
     * Characters in the atlas `path` must be in order of the UTF-16 chars.&lt;br>
     * It can have missing characters at the end or at the start, so the `offset` is added to take account for those chars.&lt;br>
     * For example, `A` is 65, but if one character is removed before the letter `A`, then offset is `-1`
     * @param {String} name id of the wgsl variable in the shader
     * @param {String} text text you want to load as texture
     * @param {String} path atlas to grab characters from, image address in a web server
     * @param {{x: number, y: number}} size size of a individual character e.g.: `{x:10, y:20}`
     * @param {Number} offset how many characters back or forward it must move to start
     * @param {String} shaderType
     * @returns {Object}
     *
     * @example
     * // js
     * await points.setTextureString(
     *     'textImg',
     *     'Custom Text',
     *     './../img/inconsolata_regular_8x22.png',
     *     size,
     *     -32
     * );
     *
     * // wgsl string
     * let textColors = texturePosition(textImg, imageSampler, position, uvr, true);
     *
     */
    async setTextureString(name, text, path, size, offset = 0, shaderType = null) {
        const atlas = await loadImage(path);
        const textImg = strToImage(text, atlas, size, offset);
        return this.setTextureImage(name, textImg, shaderType);
    }

    /**
     * Load images as texture_2d_array
     * @param {string} name id of the wgsl variable in the shader
     * @param {Array} paths image addresses in a web server
     * @param {ShaderType} shaderType
     */
    // TODO: verify if this can be updated after creation
    // TODO: return texture2dArray object
    async setTextureImageArray(name, paths, shaderType) {
        if (this.#nameExists(this.#textures2dArray, name)) {
            // TODO: throw exception here
            return;
        }
        const imageBitmaps = [];
        for await (const path of paths) {
            console.log(path);
            const response = await fetch(path);
            const blob = await response.blob();
            imageBitmaps.push(await createImageBitmap(blob));
        }
        this.#textures2dArray.push({
            name: name,
            copyCurrentTexture: false,
            shaderType: shaderType,
            texture: null,
            imageTextures: {
                bitmaps: imageBitmaps
            },
            internal: this.#internal,
        });
    }

    /**
     * Loads a video as `texture_external`and then
     * it will be available to read data from in the shaders.
     * Supports web formats like mp4 and webm.
     * @param {string} name id of the wgsl variable in the shader
     * @param {string} path video address in a web server
     * @param {ShaderType} shaderType
     * @returns {Object}
     *
     * @example
     * // js
     * await points.setTextureVideo('video', './../myvideo.mp4');
     *
     * // wgsl string
     * let rgba = textureExternalPosition(video, imageSampler, position, uvr, true);
     */
    async setTextureVideo(name, path, shaderType) {
        if (this.#nameExists(this.#texturesExternal, name)) {
            throw `setTextureVideo: ${name} already exists.`;
        }
        const video = document.createElement('video');
        video.loop = true;
        video.autoplay = true;
        video.muted = true;
        video.src = new URL(path, import.meta.url).toString();
        await video.play();
        const textureExternal = {
            name: name,
            shaderType: shaderType,
            video: video,
            internal: this.#internal
        };
        this.#texturesExternal.push(textureExternal);
        return textureExternal;
    }

    /**
     * Loads webcam as `texture_external`and then
     * it will be available to read data from in the shaders.
     * @param {String} name id of the wgsl variable in the shader
     * @param {ShaderType} shaderType
     * @returns {Object}
     *
     * @example
     * // js
     * await points.setTextureWebcam('video');
     *
     * // wgsl string
     * et rgba = textureExternalPosition(video, imageSampler, position, uvr, true);
     */
    async setTextureWebcam(name, shaderType) {
        if (this.#nameExists(this.#texturesExternal, name)) {
            throw `setTextureWebcam: ${name} already exists.`;
        }
        const video = document.createElement('video');
        //video.loop = true;
        //video.autoplay = true;
        video.muted = true;
        //document.body.appendChild(video);
        if (navigator.mediaDevices.getUserMedia) {
            await navigator.mediaDevices.getUserMedia({ video: true })
                .then(async function (stream) {
                    video.srcObject = stream;
                    await video.play();
                })
                .catch(function (err) {
                    console.log(err);
                });
        }
        const textureExternal = {
            name: name,
            shaderType: shaderType,
            video: video,
            internal: this.#internal
        };
        this.#texturesExternal.push(textureExternal);
        return textureExternal;
    }

    /**
     * Assigns an audio FrequencyData to a StorageMap.&lt;br>
     * Calling setAudio creates a Storage with `name` in the wgsl shaders.&lt;br>
     * From this storage you can read the audio data sent to the shader as numeric values.&lt;br>
     * Values in `audio.data` are composed of integers on a scale from 0..255
     * @param {string} name name of the Storage and prefix of the length variable e.g. `[name]Length`.
     * @param {string} path audio file address in a web server
     * @param {Number} volume
     * @param {boolean} loop
     * @param {boolean} autoplay
     * @returns {HTMLAudioElement}
     * @example
     * // js
     * const audio = points.setAudio('audio', 'audiofile.ogg', volume, loop, autoplay);
     *
     * // wgsl
     * let audioX = audio.data[ u32(uvr.x * params.audioLength)] / 256;
     */
    setAudio(name, path, volume, loop, autoplay) {
        const audio = new Audio(path);
        audio.volume = volume;
        audio.autoplay = autoplay;
        audio.loop = loop;
        const sound = {
            name: name,
            path: path,
            audio: audio,
            analyser: null,
            data: null
        }
        // this.#audio.play();
        // audio
        const audioContext = new AudioContext();
        let resume = _ => { audioContext.resume() }
        if (audioContext.state === 'suspended') {
            document.body.addEventListener('touchend', resume, false);
            document.body.addEventListener('click', resume, false);
        }
        const source = audioContext.createMediaElementSource(audio);
        // // audioContext.createMediaStreamSource()
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(analyser);
        analyser.connect(audioContext.destination);
        const bufferLength = analyser.fftSize;//analyser.frequencyBinCount;
        // const bufferLength = analyser.frequencyBinCount;
        const data = new Uint8Array(bufferLength);
        // analyser.getByteTimeDomainData(data);
        analyser.getByteFrequencyData(data);
        // storage that will have the data on WGSL
        this.setStorageMap(name, data,
            // `array&lt;f32, ${bufferLength}>`
            'Sound' // custom struct in defaultStructs.js
        );
        // uniform that will have the data length as a quick reference
        this.setUniform(`${name}Length`, analyser.frequencyBinCount);
        sound.analyser = analyser;
        sound.data = data;
        this.#sounds.push(sound);
        return audio;
    }


    // TODO: verify this method
    setTextureStorage2d(name, shaderType) {
        if (this.#nameExists(this.#texturesStorage2d, name)) {
            throw `setTextureStorage2d: ${name} already exists.`
        }
        const texturesStorage2d = {
            name: name,
            shaderType: shaderType,
            texture: null,
            internal: this.#internal
        };
        this.#texturesStorage2d.push(texturesStorage2d);
        return texturesStorage2d;
    }

    /**
     * Special texture where data can be written to it in the Compute Shader and
     * Is a one way communication method.
     * Ideal to store data to it in the Compute Shader and later visualize it in
     * the Fragment Shader.
     * @param {string} computeName name of the variable in the compute shader
     * @param {string} fragmentName name of the variable in the fragment shader
     * @param {Array&lt;number, 2>} size dimensions of the texture, by default screen
     * size
     * @returns {Object}
     *
     * @example
     *
     * // js
     * points.setBindingTexture('outputTex', 'computeTexture');
     *
     * // wgsl string
     * //// compute
     * textureStore(outputTex, GlobalId.xy, rgba);
     * //// fragment
     * let value = texturePosition(computeTexture, imageSampler, position, uv, false);
     */
    setBindingTexture(computeName, fragmentName, size) {
        // TODO: validate that names don't exist already
        const bindingTexture = {
            compute: {
                name: computeName,
                shaderType: ShaderType.COMPUTE
            },
            fragment: {
                name: fragmentName,
                shaderType: ShaderType.FRAGMENT
            },
            texture: null,
            size: size,
            internal: this.#internal
        }
        this.#bindingTextures.push(bindingTexture);
        return bindingTexture;
    }

    /**
     * Listens for an event dispatched from WGSL code
     * @param {String} name Number that represents an event Id
     * @param {Function} callback function to be called when the event occurs
     * @param {Number} structSize size of the data to be returned
     *
     * @example
     * // js
     * // the event name will be reflected as a variable name in the shader
     * points.addEventListener('click_event', data => {
     *     // response action in JS
     * }, 4);
     *
     * // wgsl string
     *  if(params.mouseClick == 1.){
     *      // Same name of the Event
     *      // we fire the event with a 1
     *      // it will be set to 0 in the next frame
     *      click_event.updated = 1;
     *  }
     *
     */
    addEventListener(name, callback, structSize) {
        // TODO: remove structSize
        // this extra 4 is for the boolean flag in the Event struct
        let data = new Uint8Array(Array(structSize + 4).fill(0));
        this.setStorageMap(name, data, 'Event', true);
        this.#events.set(this.#events_ids,
            {
                id: this.#events_ids,
                name: name,
                callback: callback,
            }
        );
        ++this.#events_ids;
    }
    /**
     * for internal use:
     * to flag add* methods and variables as part of the RenderPasses
     * @private
     * @ignore
     */
    _setInternal(value) {
        this.#internal = value;
    }
    /**
     * @param {ShaderType} shaderType
     * @param {boolean} internal
     * @returns {String} string with bindings
     */
    #createDynamicGroupBindings(shaderType, internal) {
        // `internal` here is a flag for a custom pass
        internal = internal || false;
        if (!shaderType) {
            throw '`ShaderType` is required';
        }
        const groupId = 0;
        let dynamicGroupBindings = '';
        let bindingIndex = 0;
        if (this.#uniforms.length) {
            dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var &lt;uniform> params: Params;\n`;
            bindingIndex += 1;
        }
        this.#storage.forEach(storageItem => {
            let internalCheck = internal == storageItem.internal;
            if (!storageItem.shaderType &amp;&amp; internalCheck || storageItem.shaderType == shaderType &amp;&amp; internalCheck) {
                let T = storageItem.structName;
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var &lt;storage, read_write> ${storageItem.name}: ${T};\n`
                bindingIndex += 1;
            }
        });
        if (this.#layers.length) {
            if (!this.#layers.shaderType || this.#layers.shaderType == shaderType) {
                let totalSize = 0;
                this.#layers.forEach(layerItem => totalSize += layerItem.size);
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var &lt;storage, read_write> layers: array&lt;array&lt;vec4&lt;f32>, ${totalSize}>>;\n`
                bindingIndex += 1;
            }
        }
        this.#samplers.forEach((sampler, index) => {
            let internalCheck = internal == sampler.internal;
            if (!sampler.shaderType &amp;&amp; internalCheck || sampler.shaderType == shaderType &amp;&amp; internalCheck) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${sampler.name}: sampler;\n`;
                bindingIndex += 1;
            }
        });
        this.#texturesStorage2d.forEach((texture, index) => {
            let internalCheck = internal &amp;&amp; texture.internal;
            if (!texture.shaderType &amp;&amp; internalCheck || texture.shaderType == shaderType &amp;&amp; internalCheck) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_storage_2d&lt;rgba8unorm, write>;\n`;
                bindingIndex += 1;
            }
        });
        this.#textures2d.forEach((texture, index) => {
            let internalCheck = internal == texture.internal;
            if (!texture.shaderType &amp;&amp; internalCheck || texture.shaderType == shaderType &amp;&amp; internalCheck) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_2d&lt;f32>;\n`;
                bindingIndex += 1;
            }
        });
        this.#textures2dArray.forEach((texture, index) => {
            let internalCheck = internal == texture.internal;
            if (!texture.shaderType &amp;&amp; internalCheck || texture.shaderType == shaderType &amp;&amp; internalCheck) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_2d_array&lt;f32>;\n`;
                bindingIndex += 1;
            }
        });
        this.#texturesExternal.forEach(externalTexture => {
            let internalCheck = internal == externalTexture.internal;
            if (!externalTexture.shaderType &amp;&amp; internalCheck || externalTexture.shaderType == shaderType &amp;&amp; internalCheck) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${externalTexture.name}: texture_external;\n`;
                bindingIndex += 1;
            }
        });
        this.#bindingTextures.forEach(bindingTexture => {
            let internalCheck = internal == bindingTexture.internal;
            if (bindingTexture.compute.shaderType == shaderType &amp;&amp; internalCheck) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.compute.name}: texture_storage_2d&lt;rgba8unorm, write>;\n`;
                bindingIndex += 1;
            }
            if (bindingTexture.fragment.shaderType == shaderType &amp;&amp; internalCheck) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.fragment.name}: texture_2d&lt;f32>;\n`;
                bindingIndex += 1;
            }
        });
        return dynamicGroupBindings;
    }
    /**
     * Establishes the density of the base mesh, by default 1x1, meaning two triangles.
     * The final number of triangles is `numColumns` * `numRows` * `2` ( 2 being the triangles )
     * @param {Number} numColumns quads horizontally
     * @param {Number} numRows quads vertically
     *
     * @example
     * // js
     * points.setMeshDensity(20,20);
     *
     * // wgsl string
     * //// vertex shader
     * var modifiedPosition = position;
     * modifiedPosition.w = modifiedPosition.w + sin(f32(vertexIndex) * (params.time) * .01) * .1;
     *
     * return defaultVertexBody(modifiedPosition, color, uv);
     */
    setMeshDensity(numColumns, numRows) {
        if (numColumns == 0 || numRows == 0) {
            throw 'Parameters should be greater than 0';
        }
        this.#numColumns = numColumns;
        this.#numRows = numRows;
    }

    #compileRenderPass = (renderPass, index) => {
        let vertexShader = renderPass.vertexShader;
        let computeShader = renderPass.computeShader;
        let fragmentShader = renderPass.fragmentShader;
        let colorsVertWGSL = vertexShader;
        let colorsComputeWGSL = computeShader;
        let colorsFragWGSL = fragmentShader;
        let dynamicGroupBindingsVertex = '';
        let dynamicGroupBindingsCompute = '';
        let dynamicGroupBindingsFragment = '';
        let dynamicStructParams = '';
        this.#uniforms.forEach(u => {
            u.type = u.type || 'f32';
            dynamicStructParams += /*wgsl*/`${u.name}:${u.type}, \n\t`;
        });
        if (this.#uniforms.length) {
            dynamicStructParams = /*wgsl*/`struct Params {\n\t${dynamicStructParams}\n}\n`;
        }
        renderPass.hasVertexShader &amp;&amp; (dynamicGroupBindingsVertex += dynamicStructParams);
        renderPass.hasComputeShader &amp;&amp; (dynamicGroupBindingsCompute += dynamicStructParams);
        renderPass.hasFragmentShader &amp;&amp; (dynamicGroupBindingsFragment += dynamicStructParams);
        renderPass.hasVertexShader &amp;&amp; (dynamicGroupBindingsVertex += this.#createDynamicGroupBindings(ShaderType.VERTEX, renderPass.internal));
        renderPass.hasComputeShader &amp;&amp; (dynamicGroupBindingsCompute += this.#createDynamicGroupBindings(ShaderType.COMPUTE, renderPass.internal));
        dynamicGroupBindingsFragment += this.#createDynamicGroupBindings(ShaderType.FRAGMENT, renderPass.internal);
        renderPass.hasVertexShader &amp;&amp; (colorsVertWGSL = dynamicGroupBindingsVertex + defaultStructs + defaultVertexBody + colorsVertWGSL);
        renderPass.hasComputeShader &amp;&amp; (colorsComputeWGSL = dynamicGroupBindingsCompute + defaultStructs + colorsComputeWGSL);
        renderPass.hasFragmentShader &amp;&amp; (colorsFragWGSL = dynamicGroupBindingsFragment + defaultStructs + colorsFragWGSL);
        console.groupCollapsed(`Render Pass ${index}`);
        console.groupCollapsed('VERTEX');
        console.log(colorsVertWGSL);
        console.groupEnd();
        if (renderPass.hasComputeShader) {
            console.groupCollapsed('COMPUTE');
            console.log(colorsComputeWGSL);
            console.groupEnd();
        }
        console.groupCollapsed('FRAGMENT');
        console.log(colorsFragWGSL);
        console.groupEnd();
        console.groupEnd();
        renderPass.hasVertexShader &amp;&amp; (renderPass.compiledShaders.vertex = colorsVertWGSL);
        renderPass.hasComputeShader &amp;&amp; (renderPass.compiledShaders.compute = colorsComputeWGSL);
        renderPass.hasFragmentShader &amp;&amp; (renderPass.compiledShaders.fragment = colorsFragWGSL);
    }
    #generateDataSize = () => {
        const allShaders = this.#renderPasses.map(renderPass => {
            const { vertex, compute, fragment } = renderPass.compiledShaders;
            return vertex + compute + fragment;;
        }).join('\n');
        this.#dataSize = dataSize(allShaders);
        // since uniforms are in a sigle struct
        // this is only required for storage
        this.#storage.forEach(s => {
            if (!s.mapped) {
                if (isArray(s.structName)) {
                    const typeData = getArrayTypeData(s.structName, this.#dataSize);
                    s.structSize = typeData.size;
                } else {
                    const d = this.#dataSize.get(s.structName) || typeSizes[s.structName];
                    if (!d) {
                        throw `${s.structName} has not been defined.`
                    }
                    s.structSize = d.bytes || d.size;
                }
            }
        });
    }
    /**
     * One time function call to initialize the shaders.
     * @param {Array&lt;RenderPass>} renderPasses Collection of {@link RenderPass}, which contain Vertex, Compute and Fragment shaders.
     * @returns {Boolean} false | undefined
     *
     * @example
     * await points.init(renderPasses)
     */
    async init(renderPasses) {
        this.#renderPasses = renderPasses.concat(this.#postRenderPasses);
        // initializing internal uniforms
        this.setUniform(UniformKeys.TIME, this.#time);
        this.setUniform(UniformKeys.DELTA, this.#delta);
        this.setUniform(UniformKeys.EPOCH, this.#epoch);
        this.setUniform(UniformKeys.SCREEN, [0, 0], 'vec2f');
        this.setUniform(UniformKeys.MOUSE, [0, 0], 'vec2f');
        this.setUniform(UniformKeys.MOUSE_CLICK, this.#mouseClick);
        this.setUniform(UniformKeys.MOUSE_DOWN, this.#mouseDown);
        this.setUniform(UniformKeys.MOUSE_WHEEL, this.#mouseWheel);
        this.setUniform(UniformKeys.MOUSE_DELTA, this.#mouseDelta, 'vec2f');
        let hasComputeShaders = this.#renderPasses.some(renderPass => renderPass.hasComputeShader);
        if (!hasComputeShaders &amp;&amp; this.#bindingTextures.length) {
            throw ' `setBindingTexture` requires at least one Compute Shader in a `RenderPass`'
        }
        this.#renderPasses.forEach(this.#compileRenderPass);
        this.#generateDataSize();
        //
        let adapter = null;
        try {
            adapter = await navigator.gpu.requestAdapter();
        } catch (err) {
            console.log(err);
        }
        if (!adapter) { return false; }
        this.#device = await adapter.requestDevice();
        this.#device.lost.then(info => {
            console.log(info);
        });
        if (this.#canvas !== null) this.#context = this.#canvas.getContext('webgpu');
        this.#presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        if (this.#canvasId) {
            if (this.#fitWindow) {
                this.#resizeCanvasToFitWindow();
            } else {
                this.#resizeCanvasToDefault();
            }
        }
        this.#renderPassDescriptor = {
            colorAttachments: [
                {
                    //view: textureView,
                    clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }
            ],
            depthStencilAttachment: {
                //view: this.#depthTexture.createView(),
                depthClearValue: 1.0,
                depthLoadOp: 'clear',
                depthStoreOp: 'store'
            }
        };
        await this.createScreen();
        return true;
    }

    /**
     * Mainly to be used with {@link RenderPasses}&lt;br>
     * Injects a render pass after all the render passes added by the user.
     * @param {RenderPass} renderPass
     * @ignore
     */
    addRenderPass(renderPass) {
        this.#postRenderPasses.push(renderPass);
    }

    /**
     * Get the active list of {@link RenderPass}
     */
    get renderPasses() {
        return this.#renderPasses;
    }

    /**
     * Adds two triangles called points per number of columns and rows
     * @ignore
     */
    async createScreen() {
        let hasVertexAndFragmentShader = this.#renderPasses.some(renderPass => renderPass.hasVertexAndFragmentShader)
        if (hasVertexAndFragmentShader) {
            let colors = [
                new RGBAColor(1, 0, 0),
                new RGBAColor(0, 1, 0),
                new RGBAColor(0, 0, 1),
                new RGBAColor(1, 1, 0),
            ];
            for (let xIndex = 0; xIndex &lt; this.#numRows; xIndex++) {
                for (let yIndex = 0; yIndex &lt; this.#numColumns; yIndex++) {
                    const coordinate = new Coordinate(xIndex * this.#canvas.clientWidth / this.#numColumns, yIndex * this.#canvas.clientHeight / this.#numRows, .3);
                    this.addPoint(coordinate, this.#canvas.clientWidth / this.#numColumns, this.#canvas.clientHeight / this.#numRows, colors);
                }
            }
            this.#createVertexBuffer(new Float32Array(this.#vertexArray));
        }
        this.#createComputeBuffers();
        await this.#createPipeline();
    }
    /**
     * @param {Float32Array} vertexArray
     * @returns buffer
     */
    #createVertexBuffer(vertexArray) {
        this.#vertexBufferInfo = new VertexBufferInfo(vertexArray);
        this.#buffer = this.#createAndMapBuffer(vertexArray, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
    }
    /**
     * @param {Float32Array} data
     * @param {GPUBufferUsageFlags} usage
     * @param {Boolean} mappedAtCreation
     * @param {Number} size
     * @returns {GPUBuffer} mapped buffer
     */
    #createAndMapBuffer(data, usage, mappedAtCreation = true, size = null) {
        const buffer = this.#device.createBuffer({
            mappedAtCreation: mappedAtCreation,
            size: size || data.byteLength,
            usage: usage,
        });
        new Float32Array(buffer.getMappedRange()).set(data);
        buffer.unmap();
        return buffer;
    }

    /**
     * It creates with size, no with data, so it's empty
     * @param {Number} size numItems * instanceByteSize ;
     * @param {GPUBufferUsageFlags} usage
     * @returns {GPUBuffer} buffer
     */
    #createBuffer(size, usage) {
        const buffer = this.#device.createBuffer({
            size: size,
            usage: usage,
        });
        return buffer
    }

    #createParametersUniforms() {
        const paramsDataSize = this.#dataSize.get('Params')
        const paddings = paramsDataSize.paddings;
        // we check the paddings list and add 0's to just the ones that need it
        const uniformsClone = JSON.parse(JSON.stringify(this.#uniforms));
        let arrayValues = uniformsClone.map(v => {
            const padding = paddings[v.name];
            if (padding) {
                if (v.value.constructor !== Array) {
                    v.value = [v.value];
                }
                for (let i = 0; i &lt; padding; i++) {
                    v.value.push(0);
                }
            }
            return v.value;
        }).flat(1);
        const finalPadding = paddings[''];
        if (finalPadding) {
            for (let i = 0; i &lt; finalPadding; i++) {
                arrayValues.push(0);
            }
        }
        const values = new Float32Array(arrayValues);
        this.#uniforms.buffer = this.#createAndMapBuffer(values, GPUBufferUsage.UNIFORM, true, paramsDataSize.bytes);
    }

    #createComputeBuffers() {
        //--------------------------------------------
        this.#createParametersUniforms();
        //--------------------------------------------
        this.#storage.forEach(storageItem => {
            let usage = GPUBufferUsage.STORAGE;
            if (storageItem.read) {
                let readStorageItem = {
                    name: storageItem.name,
                    size: storageItem.structSize
                }
                if (storageItem.mapped) {
                    readStorageItem = {
                        name: storageItem.name,
                        size: storageItem.array.length,
                    }
                }
                this.#readStorage.push(readStorageItem);
                usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC;
            }
            storageItem.usage = usage;
            if (storageItem.mapped) {
                const values = new Float32Array(storageItem.array);
                storageItem.buffer = this.#createAndMapBuffer(values, usage);
            } else {
                storageItem.buffer = this.#createBuffer(storageItem.structSize, usage);
            }
        });
        //--------------------------------------------
        this.#readStorage.forEach(readStorageItem => {
            readStorageItem.buffer = this.#device.createBuffer({
                size: readStorageItem.size,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });
        });
        //--------------------------------------------
        if (this.#layers.length) {
            //let layerValues = [];
            let layersSize = 0;
            this.#layers.forEach(layerItem => {
                layersSize += layerItem.size * layerItem.structSize;
            });
            this.#layers.buffer = this.#createBuffer(layersSize, GPUBufferUsage.STORAGE);
        }
        //--------------------------------------------
        this.#samplers.forEach(sampler => sampler.resource = this.#device.createSampler(sampler.descriptor));
        //--------------------------------------------
        this.#texturesStorage2d.forEach(textureStorage2d => {
            textureStorage2d.texture = this.#device.createTexture({
                size: this.#presentationSize,
                format: 'rgba8unorm',
                usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
            });
        });
        //--------------------------------------------
        this.#textures2d.forEach(texture2d => {
            if (texture2d.imageTexture) {
                let cubeTexture;
                const imageBitmap = texture2d.imageTexture.bitmap;
                cubeTexture = this.#device.createTexture({
                    label: texture2d.name,
                    size: [imageBitmap.width, imageBitmap.height, 1],
                    format: 'rgba8unorm',
                    usage:
                        GPUTextureUsage.TEXTURE_BINDING |
                        GPUTextureUsage.COPY_SRC |
                        GPUTextureUsage.COPY_DST |
                        GPUTextureUsage.RENDER_ATTACHMENT,
                });
                this.#device.queue.copyExternalImageToTexture(
                    { source: imageBitmap },
                    { texture: cubeTexture },
                    [imageBitmap.width, imageBitmap.height]
                );
                texture2d.texture = cubeTexture;
                // } else if (texture2d.copyCurrentTexture) {
            } else {
                this.#createTextureBindingToCopy(texture2d);
            }
        });
        //--------------------------------------------
        this.#textures2dArray.forEach(texture2dArray => {
            if (texture2dArray.imageTextures) {
                let cubeTexture;
                const imageBitmaps = texture2dArray.imageTextures.bitmaps;
                cubeTexture = this.#device.createTexture({
                    size: [imageBitmaps[0].width, imageBitmaps[0].height, imageBitmaps.length],
                    format: 'rgba8unorm',
                    usage:
                        GPUTextureUsage.TEXTURE_BINDING |
                        GPUTextureUsage.COPY_DST |
                        GPUTextureUsage.RENDER_ATTACHMENT,
                });
                imageBitmaps.forEach((imageBitmap, i) => {
                    this.#device.queue.copyExternalImageToTexture(
                        { source: imageBitmap },
                        { texture: cubeTexture, origin: { x: 0, y: 0, z: i } },
                        [imageBitmap.width, imageBitmap.height, 1]
                    );
                })

                texture2dArray.texture = cubeTexture;
            } else {
                this.#createTextureBindingToCopy(texture2dArray);
            }
        });
        //--------------------------------------------
        this.#texturesExternal.forEach(externalTexture => {
            externalTexture.texture = this.#device.importExternalTexture({
                source: externalTexture.video
            });
        });
        //--------------------------------------------
        this.#bindingTextures.forEach(bindingTexture => {
            bindingTexture.texture = this.#device.createTexture({
                size: bindingTexture.size || this.#presentationSize,
                format: 'rgba8unorm',
                usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
            });
        });
    }

    #createTextureBindingToCopy(texture2d) {
        texture2d.texture = this.#device.createTexture({
            label: texture2d.name,
            size: this.#presentationSize,
            format: this.#presentationFormat, // if 'depth24plus' throws error
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        });
    }

    #createTextureToSize(texture2d, width, height) {
        texture2d.texture = this.#device.createTexture({
            label: texture2d.name,
            size: [width, height],
            format: this.#presentationFormat, // if 'depth24plus' throws error
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        });
    }

    #createComputeBindGroup() {
        this.#renderPasses.forEach((renderPass, index) => {
            if (renderPass.hasComputeShader) {
                const entries = this.#createEntries(ShaderType.COMPUTE);
                if (entries.length) {
                    let bglEntries = [];
                    entries.forEach((entry, index) => {
                        let bglEntry = {
                            binding: index,
                            visibility: GPUShaderStage.COMPUTE
                        }
                        bglEntry[entry.type.name] = { 'type': entry.type.type };
                        if (entry.type.format) {
                            bglEntry[entry.type.name].format = entry.type.format
                        }
                        if (entry.type.viewDimension) {
                            bglEntry[entry.type.name].viewDimension = entry.type.viewDimension
                        }
                        bglEntries.push(bglEntry);
                    });
                    renderPass.bindGroupLayout = this.#device.createBindGroupLayout({ entries: bglEntries });
                    /**
                     * @type {GPUBindGroup}
                     */
                    renderPass.computeBindGroup = this.#device.createBindGroup({
                        label: `_createComputeBindGroup 0 - ${index}`,
                        layout: renderPass.bindGroupLayout,
                        entries: entries
                    });
                }
            }
        });
    }

    async #createPipeline() {
        this.#createComputeBindGroup();
        this.#renderPasses.forEach((renderPass, index) => {
            if (renderPass.hasComputeShader) {
                renderPass.computePipeline = this.#device.createComputePipeline({
                    layout: this.#device.createPipelineLayout({
                        bindGroupLayouts: [renderPass.bindGroupLayout]
                    }),
                    label: `_createPipeline() - ${index}`,
                    compute: {
                        module: this.#device.createShaderModule({
                            code: renderPass.compiledShaders.compute
                        }),
                        entryPoint: "main"
                    }
                });
            }
        });

        //--------------------------------------

        this.#createParams();
        //this.createVertexBuffer(new Float32Array(this.#vertexArray));
        // enum GPUPrimitiveTopology {
        //     'point-list',
        //     'line-list',
        //     'line-strip',
        //     'triangle-list',
        //     'triangle-strip',
        // };
        this.#renderPasses.forEach(renderPass => {
            if (renderPass.hasVertexAndFragmentShader) {
                renderPass.renderPipeline = this.#device.createRenderPipeline({
                    // layout: 'auto',
                    layout: this.#device.createPipelineLayout({
                        bindGroupLayouts: [renderPass.bindGroupLayout]
                    }),
                    //primitive: { topology: 'triangle-strip' },
                    primitive: { topology: 'triangle-list' },
                    depthStencil: {
                        depthWriteEnabled: true,
                        depthCompare: 'less',
                        format: 'depth24plus',
                    },
                    vertex: {
                        module: this.#device.createShaderModule({
                            code: renderPass.compiledShaders.vertex,
                        }),
                        entryPoint: 'main', // shader function name
                        buffers: [
                            {
                                arrayStride: this.#vertexBufferInfo.vertexSize,
                                attributes: [
                                    {
                                        // position
                                        shaderLocation: 0,
                                        offset: this.#vertexBufferInfo.vertexOffset,
                                        format: 'float32x4',
                                    },
                                    {
                                        // colors
                                        shaderLocation: 1,
                                        offset: this.#vertexBufferInfo.colorOffset,
                                        format: 'float32x4',
                                    },
                                    {
                                        // uv
                                        shaderLocation: 2,
                                        offset: this.#vertexBufferInfo.uvOffset,
                                        format: 'float32x2',
                                    },
                                ],
                            },
                        ],
                    },
                    fragment: {
                        module: this.#device.createShaderModule({
                            code: renderPass.compiledShaders.fragment,
                        }),
                        entryPoint: 'main', // shader function name
                        targets: [
                            {
                                format: this.#presentationFormat,
                                blend: {
                                    alpha: {
                                        srcFactor: 'src-alpha',
                                        dstFactor: 'one-minus-src-alpha',
                                        operation: 'add'
                                    },
                                    color: {
                                        srcFactor: 'src-alpha',
                                        dstFactor: 'one-minus-src-alpha',
                                        operation: 'add'
                                    },
                                },
                                writeMask: GPUColorWrite.ALL,
                            },
                        ],
                    },
                });
            }
        });
    }
    /**
     * Creates the entries for the pipeline
     * @returns an array with the entries
     */
    #createEntries(shaderType, internal) {
        internal = internal || false;
        let entries = [];
        let bindingIndex = 0;
        if (this.#uniforms.length) {
            entries.push(
                {
                    binding: bindingIndex++,
                    resource: {
                        label: 'uniform',
                        buffer: this.#uniforms.buffer
                    },
                    type: {
                        name: 'buffer',
                        type: 'uniform'
                    }
                }
            );
        }
        if (this.#storage.length) {
            this.#storage.forEach(storageItem => {
                let internalCheck = internal == storageItem.internal;
                if (!storageItem.shaderType &amp;&amp; internalCheck || storageItem.shaderType == shaderType &amp;&amp; internalCheck) {
                    entries.push(
                        {
                            binding: bindingIndex++,
                            resource: {
                                label: 'storage',
                                buffer: storageItem.buffer
                            },
                            type: {
                                name: 'buffer',
                                type: 'storage'
                            }
                        }
                    );
                }
            });
        }
        if (this.#layers.length) {
            if (!this.#layers.shaderType || this.#layers.shaderType == shaderType) {
                entries.push(
                    {
                        binding: bindingIndex++,
                        resource: {
                            label: 'layer',
                            buffer: this.#layers.buffer
                        },
                        type: {
                            name: 'buffer',
                            type: 'storage'
                        }
                    }
                );
            }
        }
        if (this.#samplers.length) {
            this.#samplers.forEach((sampler, index) => {
                let internalCheck = internal == sampler.internal;
                if (!sampler.shaderType &amp;&amp; internalCheck || sampler.shaderType == shaderType &amp;&amp; internalCheck) {
                    entries.push(
                        {
                            binding: bindingIndex++,
                            resource: sampler.resource,
                            type: {
                                name: 'sampler',
                                type: 'filtering'
                            }
                        }
                    );
                }
            });
        }
        if (this.#texturesStorage2d.length) {
            this.#texturesStorage2d.forEach((textureStorage2d, index) => {
                let internalCheck = internal == textureStorage2d.internal;
                if (!textureStorage2d.shaderType &amp;&amp; internalCheck || textureStorage2d.shaderType == shaderType &amp;&amp; internalCheck) {
                    entries.push(
                        {
                            label: 'texture storage 2d',
                            binding: bindingIndex++,
                            resource: textureStorage2d.texture.createView(),
                            type: {
                                name: 'storageTexture',
                                type: 'write-only'
                            }
                        }
                    );
                }
            });
        }
        if (this.#textures2d.length) {
            this.#textures2d.forEach((texture2d, index) => {
                let internalCheck = internal == texture2d.internal;
                if (!texture2d.shaderType &amp;&amp; internalCheck || texture2d.shaderType == shaderType &amp;&amp; internalCheck) {
                    entries.push(
                        {
                            label: 'texture 2d',
                            binding: bindingIndex++,
                            resource: texture2d.texture.createView(),
                            type: {
                                name: 'texture',
                                type: 'float'
                            }
                        }
                    );
                }
            });
        }
        if (this.#textures2dArray.length) {
            this.#textures2dArray.forEach((texture2dArray, index) => {
                let internalCheck = internal == texture2dArray.internal;
                if (!texture2dArray.shaderType &amp;&amp; internalCheck || texture2dArray.shaderType == shaderType &amp;&amp; internalCheck) {
                    entries.push(
                        {
                            label: 'texture 2d array',
                            binding: bindingIndex++,
                            resource: texture2dArray.texture.createView({
                                dimension: '2d-array',
                                baseArrayLayer: 0,
                                arrayLayerCount: texture2dArray.imageTextures.bitmaps.length
                            }),
                            type: {
                                name: 'texture',
                                type: 'float',
                                viewDimension: '2d-array'
                            }
                        }
                    );
                }
            });
        }
        if (this.#texturesExternal.length) {
            this.#texturesExternal.forEach(externalTexture => {
                let internalCheck = internal == externalTexture.internal;
                if (!externalTexture.shaderType &amp;&amp; internalCheck || externalTexture.shaderType == shaderType &amp;&amp; internalCheck) {
                    entries.push(
                        {
                            label: 'external texture',
                            binding: bindingIndex++,
                            resource: externalTexture.texture,
                            type: {
                                name: 'externalTexture',
                                // type: 'write-only'
                            }
                        }
                    );
                }
            });
        }
        if (this.#bindingTextures.length) {
            this.#bindingTextures.forEach(bindingTexture => {
                let internalCheck = internal == bindingTexture.internal;
                if (bindingTexture.compute.shaderType == shaderType &amp;&amp; internalCheck) {
                    entries.push(
                        {
                            label: 'binding texture',
                            binding: bindingIndex++,
                            resource: bindingTexture.texture.createView(),
                            type: {
                                name: 'storageTexture',
                                type: 'write-only',
                                format: 'rgba8unorm'
                            }
                        }
                    );
                }
            });
            this.#bindingTextures.forEach(bindingTexture => {
                let internalCheck = internal == bindingTexture.internal;
                if (bindingTexture.fragment.shaderType == shaderType &amp;&amp; internalCheck) {
                    entries.push(
                        {
                            label: 'binding texture 2',
                            binding: bindingIndex++,
                            resource: bindingTexture.texture.createView(),
                            type: {
                                name: 'texture',
                                type: 'float'
                            }
                        }
                    );
                }
            });
        }
        return entries;
    }

    #createParams() {
        this.#renderPasses.forEach(renderPass => {
            const entries = this.#createEntries(ShaderType.FRAGMENT, renderPass.internal);
            if (entries.length) {
                let bglEntries = [];
                entries.forEach((entry, index) => {
                    let bglEntry = {
                        binding: index,
                        visibility: GPUShaderStage.FRAGMENT
                    }
                    bglEntry[entry.type.name] = { 'type': entry.type.type };
                    if (entry.type.viewDimension) {
                        bglEntry[entry.type.name].viewDimension = entry.type.viewDimension
                    }
                    // TODO: 1262
                    // if you remove this there's an error that I think is not explained right
                    // it talks about a storage in index 1 but it was actually the 0
                    // and so is to this uniform you have to change the visibility
                    // not remove the type and leaving it empty as it seems you have to do here:
                    // https://gpuweb.github.io/gpuweb/#bindgroup-examples
                    if (entry.type.type == 'uniform') {
                        bglEntry.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT
                    }
                    bglEntries.push(bglEntry);
                });
                renderPass.bindGroupLayout = this.#device.createBindGroupLayout({ entries: bglEntries });
                renderPass.uniformBindGroup = this.#device.createBindGroup({
                    label: '_createParams() 0',
                    layout: renderPass.bindGroupLayout,
                    entries: entries
                });
            }
        });
    }

    /**
     * Method executed on each {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame | requestAnimationFrame}.
     * Here's where all the calls to update data will be executed.
     * @example
     * await points.init(renderPasses);
     * update();
     *
     * function update() {
     *     points.update();
     *     requestAnimationFrame(update);
     * }
     */
    async update() {
        if (!this.#canvas || !this.#device) return;
        //--------------------------------------------
        this.#delta = this.#clock.getDelta();
        this.#time = this.#clock.time;
        this.#epoch = +new Date() / 1000;
        this.setUniform(UniformKeys.TIME, this.#time);
        this.setUniform(UniformKeys.DELTA, this.#delta);
        this.setUniform(UniformKeys.EPOCH, this.#epoch);
        this.setUniform(UniformKeys.SCREEN, [this.#canvas.width, this.#canvas.height]);
        this.setUniform(UniformKeys.MOUSE, [this.#mouseX, this.#mouseY]);
        this.setUniform(UniformKeys.MOUSE_CLICK, this.#mouseClick);
        this.setUniform(UniformKeys.MOUSE_DOWN, this.#mouseDown);
        this.setUniform(UniformKeys.MOUSE_WHEEL, this.#mouseWheel);
        this.setUniform(UniformKeys.MOUSE_DELTA, this.#mouseDelta);
        //--------------------------------------------
        this.#createParametersUniforms();
        // TODO: create method for this
        this.#storage.forEach(storageItem => {
            if (storageItem.mapped) {
                const values = new Float32Array(storageItem.array);
                storageItem.buffer = this.#createAndMapBuffer(values, storageItem.usage);
            }
        });
        // AUDIO
        // this.#analyser.getByteTimeDomainData(this.#dataArray);
        this.#sounds.forEach(sound => {
            sound.analyser?.getByteFrequencyData(sound.data);
        });
        // END AUDIO
        this.#texturesExternal.forEach(externalTexture => {
            externalTexture.texture = this.#device.importExternalTexture({
                source: externalTexture.video
            });
            if ('requestVideoFrameCallback' in externalTexture.video) {
                externalTexture.video.requestVideoFrameCallback(() => { });
            }
        });

        this.#createComputeBindGroup();

        let commandEncoder = this.#device.createCommandEncoder();

        this.#renderPasses.forEach(renderPass => {
            if (renderPass.hasComputeShader) {
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(renderPass.computePipeline);
                if (this.#uniforms.length) {
                    passEncoder.setBindGroup(0, renderPass.computeBindGroup);
                }
                passEncoder.dispatchWorkgroups(
                    renderPass.workgroupCountX,
                    renderPass.workgroupCountY,
                    renderPass.workgroupCountZ
                );
                passEncoder.end();
            }
        });

        // ---------------------

        this.#renderPassDescriptor.colorAttachments[0].view = this.#context.getCurrentTexture().createView();
        this.#renderPassDescriptor.depthStencilAttachment.view = this.#depthTexture.createView();

        const swapChainTexture = this.#context.getCurrentTexture();

        //commandEncoder = this.#device.createCommandEncoder();
        this.#renderPasses.forEach((renderPass, renderPassIndex) => {
            if (renderPass.hasVertexAndFragmentShader) {
                const passEncoder = commandEncoder.beginRenderPass(this.#renderPassDescriptor);
                passEncoder.setPipeline(renderPass.renderPipeline);
                this.#createParams();
                if (this.#uniforms.length) {
                    passEncoder.setBindGroup(0, renderPass.uniformBindGroup);
                }
                passEncoder.setVertexBuffer(0, this.#buffer);
                /**
                 * vertexCount: number The number of vertices to draw
                 * instanceCount?: number | undefined The number of instances to draw
                 * firstVertex?: number | undefined Offset into the vertex buffers, in vertices, to begin drawing from
                 * firstInstance?: number | undefined First instance to draw
                 */
                //passEncoder.draw(3, 1, 0, 0);
                passEncoder.draw(this.#vertexBufferInfo.vertexCount);
                passEncoder.end();
                // Copy the rendering results from the swapchain into |texture2d.texture|.
                this.#textures2d.forEach(texture2d => {
                    if (texture2d.renderPassIndex == renderPassIndex || texture2d.renderPassIndex == null) {
                        if (texture2d.copyCurrentTexture) {
                            commandEncoder.copyTextureToTexture(
                                {
                                    texture: swapChainTexture,
                                },
                                {
                                    texture: texture2d.texture,
                                },
                                this.#presentationSize
                            );
                        }
                    }
                });
                this.#texturesToCopy.forEach(texturePair => {
                    // console.log(texturePair.a);
                    // this.#createTextureToSize(texturePair.b, texturePair.a.width, texturePair.a.height);
                    commandEncoder.copyTextureToTexture(
                        {
                            texture: texturePair.a,
                        },
                        {
                            texture: texturePair.b,
                        },
                        [texturePair.a.width, texturePair.a.height]
                    );
                });
                this.#texturesToCopy = [];
            }
        });

        if (this.#readStorage.length) {
            this.#readStorage.forEach(readStorageItem => {
                let storageItem = this.#storage.find(storageItem => storageItem.name === readStorageItem.name);
                commandEncoder.copyBufferToBuffer(
                    storageItem.buffer /* source buffer */,
                    0 /* source offset */,
                    readStorageItem.buffer /* destination buffer */,
                    0 /* destination offset */,
                    readStorageItem.buffer.size /* size */
                );
            });
        }
        // ---------------------
        this.#commandsFinished.push(commandEncoder.finish());
        this.#device.queue.submit(this.#commandsFinished);
        this.#commandsFinished = [];
        //
        //this.#vertexArray = [];
        // reset mouse values because it doesn't happen by itself
        this.#mouseClick = false;
        this.#mouseWheel = false;
        this.#mouseDelta = [0, 0];
        await this.read();
    }
    async read() {
        for (const [key, event] of this.#events) {
            let eventRead = await this.readStorage(event.name);
            if (eventRead) {
                let id = eventRead[0];
                if (id != 0) {
                    event.callback &amp;&amp; event.callback(eventRead.slice(1, -1));
                }
            }
        }
    }

    #getWGSLCoordinate(value, side, invert = false) {
        const direction = invert ? -1 : 1;
        const p = value / side;
        return (p * 2 - 1) * direction;
    };
    /**
     * - **currently for internal use**&lt;br>
     * - **might be private in the future**&lt;br>
     * Adds two triangles as a quad called Point
     * @param {Coordinate} coordinate `x` from 0 to canvas.width, `y` from 0 to canvas.height, `z` it goes from 0.0 to 1.0 and forward
     * @param {Number} width point width
     * @param {Number} height point height
     * @param {Array&lt;RGBAColor>} colors one color per corner
     * @param {Boolean} useTexture
     * @ignore
     */
    addPoint(coordinate, width, height, colors, useTexture = false) {
        const { x, y, z } = coordinate;
        const nx = this.#getWGSLCoordinate(x, this.#canvas.width);
        const ny = this.#getWGSLCoordinate(y, this.#canvas.height, true);
        const nz = z;
        const nw = this.#getWGSLCoordinate(x + width, this.#canvas.width);
        const nh = this.#getWGSLCoordinate(y + height, this.#canvas.height);
        const { r: r0, g: g0, b: b0, a: a0 } = colors[0];
        const { r: r1, g: g1, b: b1, a: a1 } = colors[1];
        const { r: r2, g: g2, b: b2, a: a2 } = colors[2];
        const { r: r3, g: g3, b: b3, a: a3 } = colors[3];
        this.#vertexArray.push(
            +nx, +ny, nz, 1, r0, g0, b0, a0, (+nx + 1) * .5, (+ny + 1) * .5,// 0 top left
            +nw, +ny, nz, 1, r1, g1, b1, a1, (+nw + 1) * .5, (+ny + 1) * .5,// 1 top right
            +nw, -nh, nz, 1, r3, g3, b3, a3, (+nw + 1) * .5, (-nh + 1) * .5,// 2 bottom right
            +nx, +ny, nz, 1, r0, g0, b0, a0, (+nx + 1) * .5, (+ny + 1) * .5,// 3 top left
            +nx, -nh, nz, 1, r2, g2, b2, a2, (+nx + 1) * .5, (-nh + 1) * .5,// 4 bottom left
            +nw, -nh, nz, 1, r3, g3, b3, a3, (+nw + 1) * .5, (-nh + 1) * .5,// 5 bottom right
        );
    }
    /**
     * Reference to the canvas assigned in the constructor
     * @type {HTMLCanvasElement}
     */
    get canvas() {
        return this.#canvas;
    }
    get device() {
        return this.#device;
    }
    get context() {
        return this.#context;
    }
    get presentationFormat() {
        return this.#presentationFormat;
    }
    get buffer() {
        return this.#buffer;
    }
    get fullscreen() {
        return this.#fullscreen;
    }

    /**
     * Triggers the app to run in full screen mode
     * @type {Boolean}
     *
     * @example
     * points.fullscreen = true
     */
    set fullscreen(value) {
        if (value) {
            this.#lastFitWindow = this.#fitWindow;
            this.fitWindow = value;
            this.#canvas.requestFullscreen().catch(err => {
                throw `Error attempting to enable fullscreen mode: ${err.message} (${err.name})`;
            });
            this.#fullscreen = true;
        } else {
            document.exitFullscreen();
            this.#fullscreen = false;
            this.#resizeCanvasToDefault();
        }
    }

    /**
     * If the canvas has a fixed size e.g. `800x800`, `fitWindow` will fill
     * the available window space.
     * @type {Boolean}
     * @throws {String} {@link Points#init} has not been called
     *
     * @example
     *  if (await points.init(renderPasses)) {
     *      points.fitWindow = isFitWindowData.isFitWindow;
     *      update();
     *  }
     */
    set fitWindow(value) {
        if (!this.#context) {
            throw 'fitWindow must be assigned after Points.init() call or you don\'t have a Canvas assigned in the constructor';
        }
        this.#fitWindow = value;
        if (this.#fitWindow) {
            this.#resizeCanvasToFitWindow();
        } else {
            this.#resizeCanvasToDefault();
        }
    }
}

export default Points;
export { ShaderType, RenderPass, RenderPasses };</code></pre>
</article>





        </main>
        <footer class="footer">
            
            <div class="lines">
                
                <p class="copyright">&copy; Sebastián Sanabria</p>
                
                
                <p class="license">MIT</p>
                
                
                <p class="generator">
                    Documentation generated by <a rel="external" href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a><wbr>
                    using <a rel="external" href="https://github.com/amekusa/docolatte">Docolatte</a> theme
                    
                    <wbr>on <time datetime="2025-08-05T20:09:58.901Z">Tue, 05 Aug 2025 20:09:58 GMT</time>
                    
                </p>
                
            </div>
            
            <div class="bottom">
                <a class="to-top" href="#">
                    <div class="label">Top<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-up icon"><polyline points="18 15 12 9 6 15"></polyline></svg></div>
                </a>
            </div>
        </footer>
    </div>

    <input id="docolatte-sidebar-toggle" type="checkbox">
    <label class="overlay" for="docolatte-sidebar-toggle"></label>
    <label class="menu-button" for="docolatte-sidebar-toggle">
        <div class="shape">
            <i class="icon burger">
                <span class="top"></span>
                <span class="middle"></span>
                <span class="bottom"></span>
            </i>
        </div>
    </label>

    <div class="sidebar">
        <div class="wrap" data-ready="0">
            
<div class="search-box">
	<input class="search" type="text" placeholder="type to search…"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search icon"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
	<ol class="dropdown"></ol>
	
	<div class="hint hidden not-for-mobile">
		<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-info icon"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg> Type <em>any key</em> to focus.
	</div>
	
</div>

            <div class="toc">
                <nav class="menu"><h3>Modules</h3><ul class="wbr"><li class="has-child"><a href="module-defaultFunctions.html">default<wbr>Functions</a><ul class="variables has-icons wbr"><li><a href="module-defaultFunctions.html#.defaultVertexBody">default<wbr>Vertex<wbr>Body</a></li></ul></li><li><a href="module-defaultStructs.html">default<wbr>Structs</a></li><li class="has-child"><a href="module-points_animation.html">points<wbr>/animation</a><ul class="variables has-icons wbr"><li><a href="module-points_animation.html#.fnusin">fnusin</a></li><li><a href="module-points_animation.html#.fucos">fucos</a></li><li><a href="module-points_animation.html#.fusin">fusin</a></li></ul></li><li class="has-child"><a href="module-points_audio.html">points<wbr>/audio</a><ul class="variables has-icons wbr"><li><a href="module-points_audio.html#.audioAverage">audio<wbr>Average</a></li><li><a href="module-points_audio.html#.audioAverageSegments">audio<wbr>Average<wbr>Segments</a></li></ul></li><li class="has-child"><a href="module-points_cellular2d.html">points<wbr>/cellular<wbr>2d</a><ul class="variables has-icons wbr"><li><a href="module-points_cellular2d.html#.cellular">cellular</a></li></ul></li><li class="has-child"><a href="module-points_classicnoise2d.html">points<wbr>/classicnoise<wbr>2d</a><ul class="variables has-icons wbr"><li><a href="module-points_classicnoise2d.html#.cnoise">cnoise</a></li><li><a href="module-points_classicnoise2d.html#.pnoise">pnoise</a></li></ul></li><li class="has-child"><a href="module-points_color.html">points<wbr>/color</a><ul class="variables has-icons wbr"><li><a href="module-points_color.html#.BLACK">BLACK</a></li><li><a href="module-points_color.html#.BLUE">BLUE</a></li><li><a href="module-points_color.html#.CYAN">CYAN</a></li><li><a href="module-points_color.html#.GREEN">GREEN</a></li><li><a href="module-points_color.html#.MAGENTA">MAGENTA</a></li><li><a href="module-points_color.html#.RED">RED</a></li><li><a href="module-points_color.html#.RGBAFromHSV">RGBAFrom<wbr>HSV</a></li><li><a href="module-points_color.html#.WHITE">WHITE</a></li><li><a href="module-points_color.html#.YELLOW">YELLOW</a></li><li><a href="module-points_color.html#.bloom">bloom</a></li><li><a href="module-points_color.html#.brightness">brightness</a></li><li><a href="module-points_color.html#.brightnessB">brightness<wbr>B</a></li><li><a href="module-points_color.html#.brightnessC">brightness<wbr>C</a></li><li><a href="module-points_color.html#.layer">layer</a></li></ul></li><li class="has-child"><a href="module-points_debug.html">points<wbr>/debug</a><ul class="variables has-icons wbr"><li><a href="module-points_debug.html#.showDebugCross">show<wbr>Debug<wbr>Cross</a></li><li><a href="module-points_debug.html#.showDebugFrame">show<wbr>Debug<wbr>Frame</a></li></ul></li><li class="has-child"><a href="module-points_effects.html">points<wbr>/effects</a><ul class="variables has-icons wbr"><li><a href="module-points_effects.html#.blur9">blur<wbr>9</a></li><li><a href="module-points_effects.html#.clearAlpha">clear<wbr>Alpha</a></li><li><a href="module-points_effects.html#.clearMix">clear<wbr>Mix</a></li><li><a href="module-points_effects.html#.euclideanDistance">euclidean<wbr>Distance</a></li><li><a href="module-points_effects.html#.getClosestColorInPalette">get<wbr>Closest<wbr>Color<wbr>In<wbr>Palette</a></li><li><a href="module-points_effects.html#.getColorsAround4Texture">get<wbr>Colors<wbr>Around<wbr>4Texture</a></li><li><a href="module-points_effects.html#.getColorsAroundTexture">get<wbr>Colors<wbr>Around<wbr>Texture</a></li><li><a href="module-points_effects.html#.orderedDithering">ordered<wbr>Dithering</a></li><li><a href="module-points_effects.html#.orderedDithering_threshold_map">ordered<wbr>Dithering<wbr>_threshold<wbr>_map</a></li><li><a href="module-points_effects.html#.soften4">soften<wbr>4</a></li><li><a href="module-points_effects.html#.soften8">soften<wbr>8</a></li></ul></li><li class="has-child"><a href="module-points_image.html">points<wbr>/image</a><ul class="variables has-icons wbr"><li><a href="module-points_image.html#.decodeNumberSprite">decode<wbr>Number<wbr>Sprite</a></li><li><a href="module-points_image.html#.flipTextureUV">flip<wbr>Texture<wbr>UV</a></li><li><a href="module-points_image.html#.pixelateTexture">pixelate<wbr>Texture</a></li><li><a href="module-points_image.html#.pixelateTexturePosition">pixelate<wbr>Texture<wbr>Position</a></li><li><a href="module-points_image.html#.sprite">sprite</a></li><li><a href="module-points_image.html#.textureExternalPosition">texture<wbr>External<wbr>Position</a></li><li><a href="module-points_image.html#.texturePosition">texture<wbr>Position</a></li></ul></li><li class="has-child"><a href="module-points_math.html">points<wbr>/math</a><ul class="variables has-icons wbr"><li><a href="module-points_math.html#.E">E</a></li><li><a href="module-points_math.html#.PHI">PHI</a></li><li><a href="module-points_math.html#.PI">PI</a></li><li><a href="module-points_math.html#.TAU">TAU</a></li><li><a href="module-points_math.html#.polar">polar</a></li><li><a href="module-points_math.html#.rotateVector">rotate<wbr>Vector</a></li></ul></li><li class="has-child"><a href="module-points_noise2d.html">points<wbr>/noise<wbr>2d</a><ul class="variables has-icons wbr"><li><a href="module-points_noise2d.html#.snoise">snoise</a></li></ul></li><li class="has-child"><a href="module-points_random.html">points<wbr>/random</a><ul class="variables has-icons wbr"><li><a href="module-points_random.html#.rand">rand</a></li><li><a href="module-points_random.html#.rand2">rand<wbr>2</a></li><li><a href="module-points_random.html#.random">random</a></li></ul></li><li class="has-child"><a href="module-points_sdf.html">points<wbr>/sdf</a><ul class="variables has-icons wbr"><li><a href="module-points_sdf.html#.sdfCircle">sdf<wbr>Circle</a></li><li><a href="module-points_sdf.html#.sdfLine">sdf<wbr>Line</a></li><li><a href="module-points_sdf.html#.sdfLine2">sdf<wbr>Line<wbr>2</a></li><li><a href="module-points_sdf.html#.sdfSegment">sdf<wbr>Segment</a></li><li><a href="module-points_sdf.html#.sdfSmooth">sdf<wbr>Smooth</a></li><li><a href="module-points_sdf.html#.sdfSquare">sdf<wbr>Square</a></li></ul></li><li class="has-child"><a href="module-points_valuenoise.html">points<wbr>/valuenoise</a><ul class="variables has-icons wbr"><li><a href="module-points_valuenoise.html#.valueNoise">value<wbr>Noise</a></li></ul></li><li class="has-child"><a href="module-points_voronoi.html">points<wbr>/voronoi</a><ul class="variables has-icons wbr"><li><a href="module-points_voronoi.html#.voronoi">voronoi</a></li></ul></li></ul></nav><nav class="menu"><h3>Classes</h3><ul class="wbr"><li class="has-child"><a href="CanvasRecorder.html">Canvas<wbr>Recorder</a><ul class="functions has-icons wbr"><li><a href="CanvasRecorder.html#getPNG">get<wbr>PNG</a></li><li><a href="CanvasRecorder.html#start">start</a></li><li><a href="CanvasRecorder.html#stop">stop</a></li></ul></li><li class="has-child"><a href="Points.html">Points</a><ul class="variables has-icons wbr"><li><a href="Points.html#canvas">canvas</a></li><li><a href="Points.html#fitWindow">fit<wbr>Window</a></li><li><a href="Points.html#fullscreen">fullscreen</a></li><li><a href="Points.html#renderPasses">render<wbr>Passes</a></li></ul><ul class="functions has-icons wbr"><li><a href="Points.html#addEventListener">add<wbr>Event<wbr>Listener</a></li><li><a href="Points.html#init">init</a></li><li><a href="Points.html#setAudio">set<wbr>Audio</a></li><li><a href="Points.html#setBindingTexture">set<wbr>Binding<wbr>Texture</a></li><li><a href="Points.html#setLayers">set<wbr>Layers</a></li><li><a href="Points.html#setMeshDensity">set<wbr>Mesh<wbr>Density</a></li><li><a href="Points.html#setSampler">set<wbr>Sampler</a></li><li><a href="Points.html#setStorage">set<wbr>Storage</a></li><li><a href="Points.html#setStorageMap">set<wbr>Storage<wbr>Map</a></li><li><a href="Points.html#setTexture2d">set<wbr>Texture<wbr>2d</a></li><li><a href="Points.html#setTextureImage">set<wbr>Texture<wbr>Image</a></li><li><a href="Points.html#setTextureImageArray">set<wbr>Texture<wbr>Image<wbr>Array</a></li><li><a href="Points.html#setTextureString">set<wbr>Texture<wbr>String</a></li><li><a href="Points.html#setTextureVideo">set<wbr>Texture<wbr>Video</a></li><li><a href="Points.html#setTextureWebcam">set<wbr>Texture<wbr>Webcam</a></li><li><a href="Points.html#setUniform">set<wbr>Uniform</a></li><li><a href="Points.html#update">update</a></li><li><a href="Points.html#updateUniforms">update<wbr>Uniforms</a></li></ul></li><li class="has-child"><a href="RenderPass.html">Render<wbr>Pass</a><ul class="variables has-icons wbr"><li><a href="RenderPass.html#computeShader">compute<wbr>Shader</a></li><li><a href="RenderPass.html#fragmentShader">fragment<wbr>Shader</a></li><li><a href="RenderPass.html#vertexShader">vertex<wbr>Shader</a></li></ul></li><li class="has-child"><a href="RenderPasses.html">Render<wbr>Passes</a><ul class="functions has-icons wbr"><li><a href="RenderPasses.html#.add">add</a></li><li><a href="RenderPasses.html#.bloom">bloom</a></li><li><a href="RenderPasses.html#.blur">blur</a></li><li><a href="RenderPasses.html#.chromaticAberration">chromatic<wbr>Aberration</a></li><li><a href="RenderPasses.html#.color">color</a></li><li><a href="RenderPasses.html#.filmgrain">filmgrain</a></li><li><a href="RenderPasses.html#.grayscale">grayscale</a></li><li><a href="RenderPasses.html#.lensDistortion">lens<wbr>Distortion</a></li><li><a href="RenderPasses.html#.pixelate">pixelate</a></li><li><a href="RenderPasses.html#.waves">waves</a></li></ul></li><li class="has-child"><a href="ShaderType.html">Shader<wbr>Type</a><ul class="variables has-icons wbr"><li><a href="ShaderType.html#COMPUTE">COMPUTE</a></li><li><a href="ShaderType.html#FRAGMENT">FRAGMENT</a></li><li><a href="ShaderType.html#VERTEX">VERTEX</a></li></ul></li></ul></nav>
            </div>
        </div>
    </div>
</div>

<script id="docolatte-search-items" type="application/json">[{"$":["module-defaultFunctions.html","defaultFunctions"],"a":"defaultFunctions","b":"module:defaultFunctions","c":"core/defaultFunctions.js","e":"The defaultFunctions are functions already incorporated onto the shaders you create, so you can call them without import.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader. Use the base example as reference: examples/base/vert.js"},{"$":["module-defaultFunctions.html#.defaultVertexBody","module:defaultFunctions.defaultVertexBody"],"a":"defaultVertexBody","b":"module:defaultFunctions.defaultVertexBody","c":"core/defaultFunctions.js","e":"The defaultVertexBody is used as a drop-in replacement of the vertex shader content.   This is not required, but useful if you plan to use the default parameters of the library.   All the examples in the examples directory use this function in their vert.js file.     Default function for the Vertex shader that takes charge of automating the creation of a few variables that are commonly used."},{"$":["module-defaultStructs.html","defaultStructs"],"a":"defaultStructs","b":"module:defaultStructs","c":"core/defaultStructs.js","e":"The defaultStructs are structs already incorporated onto the shaders you create, so you can call them without import.   Fragment, Sound, and Event structs.     Fragment used in Vertex Shaders.  Sound used along with {@link Points#setAudio}  Event used along with {@link Points#addEventListener} "},{"$":["module-points_animation.html","points/animation"],"a":"points/animation","b":"module:points/animation","c":"core/animation.js","e":"Utilities for animation.   Functions that use sine and params.time to increase and decrease a value over time.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_animation.html#.fnusin","module:points/animation.fnusin"],"a":"fnusin","b":"module:points/animation.fnusin","c":"core/animation.js","e":"Animates sin() over params.time and a provided speed. The value is normalized, so in the range 0..1"},{"$":["module-points_animation.html#.fucos","module:points/animation.fucos"],"a":"fucos","b":"module:points/animation.fucos","c":"core/animation.js","e":"Animates cos() over params.time and a provided speed. The value is not normalized, so in the range -1..1"},{"$":["module-points_animation.html#.fusin","module:points/animation.fusin"],"a":"fusin","b":"module:points/animation.fusin","c":"core/animation.js","e":"Animates sin() over params.time and a provided speed. The value is not normalized, so in the range -1..1"},{"$":["module-points_audio.html","points/audio"],"a":"points/audio","b":"module:points/audio","c":"core/audio.js","e":"Utilities for audio work.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_audio.html#.audioAverage","module:points/audio.audioAverage"],"a":"audioAverage","b":"module:points/audio.audioAverage","c":"core/audio.js","e":"Average of all the value in sound.data (Sound struct in {@link module:defaultStructs})"},{"$":["module-points_audio.html#.audioAverageSegments","module:points/audio.audioAverageSegments"],"a":"audioAverageSegments","b":"module:points/audio.audioAverageSegments","c":"core/audio.js","e":"WIP"},{"$":["module-points_cellular2d.html","points/cellular2d"],"a":"points/cellular2d","b":"module:points/cellular2d","c":"core/cellular2d.js","e":"original: Author :  Stefan Gustavson (stefan.gustavson@liu.se)  https://github.com/ashima/webgl-noise/blob/master/src/cellular2D.glsl    These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_cellular2d.html#.cellular","module:points/cellular2d.cellular"],"a":"cellular","b":"module:points/cellular2d.cellular","c":"core/cellular2d.js","e":"Cellular noise"},{"$":["module-points_classicnoise2d.html","points/classicnoise2d"],"a":"points/classicnoise2d","b":"module:points/classicnoise2d","c":"core/classicnoise2d.js","e":"original: Author :  Stefan Gustavson (stefan.gustavson@liu.se)  https://github.com/ashima/webgl-noise/blob/master/src/classicnoise2D.glsl    These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_classicnoise2d.html#.cnoise","module:points/classicnoise2d.cnoise"],"a":"cnoise","b":"module:points/classicnoise2d.cnoise","c":"core/classicnoise2d.js","e":"Classic Perlin Noise"},{"$":["module-points_classicnoise2d.html#.pnoise","module:points/classicnoise2d.pnoise"],"a":"pnoise","b":"module:points/classicnoise2d.pnoise","c":"core/classicnoise2d.js","e":"Classic Perlin Noise, periodic variant"},{"$":["module-points_color.html","points/color"],"a":"points/color","b":"module:points/color","c":"core/color.js","e":"A few color constants and wgsl methods to work with colors.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_color.html#.BLACK","module:points/color.BLACK"],"a":"BLACK","b":"module:points/color.BLACK","c":"core/color.js","e":"BLACK color;"},{"$":["module-points_color.html#.BLUE","module:points/color.BLUE"],"a":"BLUE","b":"module:points/color.BLUE","c":"core/color.js","e":"BLUE color;"},{"$":["module-points_color.html#.CYAN","module:points/color.CYAN"],"a":"CYAN","b":"module:points/color.CYAN","c":"core/color.js","e":"CYAN color;"},{"$":["module-points_color.html#.GREEN","module:points/color.GREEN"],"a":"GREEN","b":"module:points/color.GREEN","c":"core/color.js","e":"GREEN color;"},{"$":["module-points_color.html#.MAGENTA","module:points/color.MAGENTA"],"a":"MAGENTA","b":"module:points/color.MAGENTA","c":"core/color.js","e":"MAGENTA color;"},{"$":["module-points_color.html#.RED","module:points/color.RED"],"a":"RED","b":"module:points/color.RED","c":"core/color.js","e":"RED color;"},{"$":["module-points_color.html#.RGBAFromHSV","module:points/color.RGBAFromHSV"],"a":"RGBAFromHSV","b":"module:points/color.RGBAFromHSV","c":"core/color.js","e":"Creates a rgba vec4f from an hsv color value"},{"$":["module-points_color.html#.WHITE","module:points/color.WHITE"],"a":"WHITE","b":"module:points/color.WHITE","c":"core/color.js","e":"WHITE color;"},{"$":["module-points_color.html#.YELLOW","module:points/color.YELLOW"],"a":"YELLOW","b":"module:points/color.YELLOW","c":"core/color.js","e":"YELLOW color;"},{"$":["module-points_color.html#.bloom","module:points/color.bloom"],"a":"bloom","b":"module:points/color.bloom","c":"core/color.js","e":"Compute the FFT (Fast Fourier Transform)"},{"$":["module-points_color.html#.brightness","module:points/color.brightness"],"a":"brightness","b":"module:points/color.brightness","c":"core/color.js","e":"Returns the perceived brightness of a color by the eye.  // Standard  LuminanceA = (0.2126*R) + (0.7152*G) + (0.0722*B)"},{"$":["module-points_color.html#.brightnessB","module:points/color.brightnessB"],"a":"brightnessB","b":"module:points/color.brightnessB","c":"core/color.js","e":"Returns the perceived brightness of a color by the eye.  // Percieved A  LuminanceB = (0.299*R + 0.587*G + 0.114*B)"},{"$":["module-points_color.html#.brightnessC","module:points/color.brightnessC"],"a":"brightnessC","b":"module:points/color.brightnessC","c":"core/color.js","e":"Returns the perceived brightness of a color by the eye.  // Percieved B  slower to calculate  LuminanceC = sqrt(0.299*(R**2) + 0.587*(G**2) + 0.114*(B**2))"},{"$":["module-points_color.html#.layer","module:points/color.layer"],"a":"layer","b":"module:points/color.layer","c":"core/color.js","e":"Layers two colors by cropping the color in the back, based on the alpha value."},{"$":["module-points_debug.html","points/debug"],"a":"points/debug","b":"module:points/debug","c":"core/debug.js","e":"Visual debugging methods like drawing a cross on screen and drawing a square around the screen.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_debug.html#.showDebugCross","module:points/debug.showDebugCross"],"a":"showDebugCross","b":"module:points/debug.showDebugCross","c":"core/debug.js","e":"Draws an infinite cross. Useful to draw it where the mouse is."},{"$":["module-points_debug.html#.showDebugFrame","module:points/debug.showDebugFrame"],"a":"showDebugFrame","b":"module:points/debug.showDebugFrame","c":"core/debug.js","e":"Border around the screen"},{"$":["module-points_effects.html","points/effects"],"a":"points/effects","b":"module:points/effects","c":"core/effects.js","e":"These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_effects.html#.blur9","module:points/effects.blur9"],"a":"blur9","b":"module:points/effects.blur9","c":"core/effects.js","e":"Applies a blur to an image   based on https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl"},{"$":["module-points_effects.html#.clearAlpha","module:points/effects.clearAlpha"],"a":"clearAlpha","b":"module:points/effects.clearAlpha","c":"core/effects.js","e":"Takes a color and reduces its value but applied to the alpha channel."},{"$":["module-points_effects.html#.clearMix","module:points/effects.clearMix"],"a":"clearMix","b":"module:points/effects.clearMix","c":"core/effects.js","e":"Takes a color and reduces its values by a level"},{"$":["module-points_effects.html#.euclideanDistance","module:points/effects.euclideanDistance"],"a":"euclideanDistance","b":"module:points/effects.euclideanDistance","c":"core/effects.js","e":"Calculates the <a href=\"https://en.wikipedia.org/wiki/Euclidean_distance\">Euclidean Distance between colors."},{"$":["module-points_effects.html#.getClosestColorInPalette","module:points/effects.getClosestColorInPalette"],"a":"getClosestColorInPalette","b":"module:points/effects.getClosestColorInPalette","c":"core/effects.js","e":"This assumes you have declared a palette in a variable or constant called getClosestColorInPalette_palette   Gets the closest color based on the distance parameter."},{"$":["module-points_effects.html#.getColorsAround4Texture","module:points/effects.getColorsAround4Texture"],"a":"getColorsAround4Texture","b":"module:points/effects.getColorsAround4Texture","c":"core/effects.js","e":"From a given texture and its position, get top, botto, left and right color values"},{"$":["module-points_effects.html#.getColorsAroundTexture","module:points/effects.getColorsAroundTexture"],"a":"getColorsAroundTexture","b":"module:points/effects.getColorsAroundTexture","c":"core/effects.js","e":"From a given texture and its position, get the 9 color values around."},{"$":["module-points_effects.html#.orderedDithering","module:points/effects.orderedDithering"],"a":"orderedDithering","b":"module:points/effects.orderedDithering","c":"core/effects.js","e":"Applies <a href=\"https://en.wikipedia.org/wiki/Ordered_dithering\">Ordered Dithering to a color. Best with the colors of an image texture.   This requires orderedDithering_threshold_map to be imported or create your own version of it."},{"$":["module-points_effects.html#.orderedDithering_threshold_map","module:points/effects.orderedDithering_threshold_map"],"a":"orderedDithering_threshold_map","b":"module:points/effects.orderedDithering_threshold_map","c":"core/effects.js","e":"To be used with orderedDithering.  You can use this or create yours."},{"$":["module-points_effects.html#.soften4","module:points/effects.soften4"],"a":"soften4","b":"module:points/effects.soften4","c":"core/effects.js","e":"Softens a color based on list of colors around it or any list of 4 colors."},{"$":["module-points_effects.html#.soften8","module:points/effects.soften8"],"a":"soften8","b":"module:points/effects.soften8","c":"core/effects.js","e":"Softens a color based on list of colors around it or any list of 8 colors."},{"$":["module-points_image.html","points/image"],"a":"points/image","b":"module:points/image","c":"core/image.js","e":"These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_image.html#.decodeNumberSprite","module:points/image.decodeNumberSprite"],"a":"decodeNumberSprite","b":"module:points/image.decodeNumberSprite","c":"core/image.js","e":"From a provided number, get the sprite in an atlas that matches the value."},{"$":["module-points_image.html#.flipTextureUV","module:points/image.flipTextureUV"],"a":"flipTextureUV","b":"module:points/image.flipTextureUV","c":"core/image.js","e":"Flips texture in Y. This because it comes flipped, so this corrects it."},{"$":["module-points_image.html#.pixelateTexture","module:points/image.pixelateTexture"],"a":"pixelateTexture","b":"module:points/image.pixelateTexture","c":"core/image.js","e":"Increase the aparent pixel size of the texture image using textureSample. This reduces the quality of the image."},{"$":["module-points_image.html#.pixelateTexturePosition","module:points/image.pixelateTexturePosition"],"a":"pixelateTexturePosition","b":"module:points/image.pixelateTexturePosition","c":"core/image.js","e":"Increase the aparent pixel size of the texture image using texturePosition. This reduces the quality of the image."},{"$":["module-points_image.html#.sprite","module:points/image.sprite"],"a":"sprite","b":"module:points/image.sprite","c":"core/image.js","e":"Sprite or Atlas. Extract a piece of the sprite with an index."},{"$":["module-points_image.html#.textureExternalPosition","module:points/image.textureExternalPosition"],"a":"textureExternalPosition","b":"module:points/image.textureExternalPosition","c":"core/image.js","e":"Places texture_external in a position. Texture external being in this case a video loaded as texture in the JS side."},{"$":["module-points_image.html#.texturePosition","module:points/image.texturePosition"],"a":"texturePosition","b":"module:points/image.texturePosition","c":"core/image.js","e":"Places texture in a position. The texture being an image loaded from the JS side."},{"$":["module-points_math.html","points/math"],"a":"points/math","b":"module:points/math","c":"core/math.js","e":"Math utils These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_math.html#.E","module:points/math.E"],"a":"E","b":"module:points/math.E","c":"core/math.js","e":"E is a mathematical constant approximately equal to 2.71828 that is the base of the natural logarithm and exponential function. It is sometimes called Euler's number, after the Swiss mathematician Leonhard Euler."},{"$":["module-points_math.html#.PHI","module:points/math.PHI"],"a":"PHI","b":"module:points/math.PHI","c":"core/math.js","e":"PHI is the Golden Ratio"},{"$":["module-points_math.html#.PI","module:points/math.PI"],"a":"PI","b":"module:points/math.PI","c":"core/math.js","e":"PI is the ratio of a circle's circumference to its diameter."},{"$":["module-points_math.html#.TAU","module:points/math.TAU"],"a":"TAU","b":"module:points/math.TAU","c":"core/math.js","e":"TAU  is the ratio of a circle's circumference to its radius."},{"$":["module-points_math.html#.polar","module:points/math.polar"],"a":"polar","b":"module:points/math.polar","c":"core/math.js","e":"Using polar coordinates, calculates the final point as vec2f"},{"$":["module-points_math.html#.rotateVector","module:points/math.rotateVector"],"a":"rotateVector","b":"module:points/math.rotateVector","c":"core/math.js","e":"Rotates a vector an amount of radians"},{"$":["module-points_noise2d.html","points/noise2d"],"a":"points/noise2d","b":"module:points/noise2d","c":"core/noise2d.js","e":"original: Author : Ian McEwan, Ashima Arts. https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_noise2d.html#.snoise","module:points/noise2d.snoise"],"a":"snoise","b":"module:points/noise2d.snoise","c":"core/noise2d.js","e":"Sinplex Noise function"},{"$":["module-points_random.html","points/random"],"a":"points/random","b":"module:points/random","c":"core/random.js","e":"Various random functions. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_random.html#.rand","module:points/random.rand"],"a":"rand","b":"module:points/random.rand","c":"core/random.js","e":"Random number that returns a vec2f.  You have to set the rand_seed before calling rand()."},{"$":["module-points_random.html#.rand2","module:points/random.rand2"],"a":"rand2","b":"module:points/random.rand2","c":"core/random.js","e":"Random number from vec2f param"},{"$":["module-points_random.html#.random","module:points/random.random"],"a":"random","b":"module:points/random.random","c":"core/random.js","e":"Single random number. Use seed to change seed."},{"$":["module-points_sdf.html","points/sdf"],"a":"points/sdf","b":"module:points/sdf","c":"core/sdf.js","e":"A few signed distance functions.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_sdf.html#.sdfCircle","module:points/sdf.sdfCircle"],"a":"sdfCircle","b":"module:points/sdf.sdfCircle","c":"core/sdf.js","e":"Creates a circle"},{"$":["module-points_sdf.html#.sdfLine","module:points/sdf.sdfLine"],"a":"sdfLine","b":"module:points/sdf.sdfLine","c":"core/sdf.js","e":"Creates a line with a pixel stroke."},{"$":["module-points_sdf.html#.sdfLine2","module:points/sdf.sdfLine2"],"a":"sdfLine2","b":"module:points/sdf.sdfLine2","c":"core/sdf.js","e":"Better than sdfLine to create lines"},{"$":["module-points_sdf.html#.sdfSegment","module:points/sdf.sdfSegment"],"a":"sdfSegment","b":"module:points/sdf.sdfSegment","c":"core/sdf.js","e":"Function used to create lines. It's a dependency of them."},{"$":["module-points_sdf.html#.sdfSmooth","module:points/sdf.sdfSmooth"],"a":"sdfSmooth","b":"module:points/sdf.sdfSmooth","c":"core/sdf.js","e":"Special for letters and create an sdf version of a texture"},{"$":["module-points_sdf.html#.sdfSquare","module:points/sdf.sdfSquare"],"a":"sdfSquare","b":"module:points/sdf.sdfSquare","c":"core/sdf.js","e":"Creates a square"},{"$":["module-points_valuenoise.html","points/valuenoise"],"a":"points/valuenoise","b":"module:points/valuenoise","c":"core/valuenoise.js","e":"Value noise methods. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_valuenoise.html#.valueNoise","module:points/valuenoise.valueNoise"],"a":"valueNoise","b":"module:points/valuenoise.valueNoise","c":"core/valuenoise.js","e":"Implementation of a value noise function.  <a href=\"https://en.wikipedia.org/wiki/Value_noise\">value noise"},{"$":["module-points_voronoi.html","points/voronoi"],"a":"points/voronoi","b":"module:points/voronoi","c":"core/voronoi.js","e":"Voronoi functions. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_voronoi.html#.voronoi","module:points/voronoi.voronoi"],"a":"voronoi","b":"module:points/voronoi.voronoi","c":"core/voronoi.js","e":"Voronoi noise. Generated randomly."},{"$":["CanvasRecorder.html","CanvasRecorder"],"a":"CanvasRecorder","b":"CanvasRecorder","c":"CanvasRecorder.js","e":"Records video from a Canvas to a file."},{"$":["CanvasRecorder.html#getPNG","CanvasRecorder#getPNG"],"a":"getPNG","b":"CanvasRecorder#getPNG","c":"CanvasRecorder.js","e":"Retrieves the current frame as a PNG and downloads the image."},{"$":["CanvasRecorder.html#start","CanvasRecorder#start"],"a":"start","b":"CanvasRecorder#start","c":"CanvasRecorder.js","e":"Starts the video recording."},{"$":["CanvasRecorder.html#stop","CanvasRecorder#stop"],"a":"stop","b":"CanvasRecorder#stop","c":"CanvasRecorder.js","e":"Stops the video recording and downloads the video."},{"$":["Points.html","Points"],"a":"Points","b":"Points","c":"points.js","e":"Main class Points"},{"$":["Points.html#canvas","Points#canvas"],"a":"canvas","b":"Points#canvas","c":"points.js","e":"Reference to the canvas assigned in the constructor"},{"$":["Points.html#fitWindow","Points#fitWindow"],"a":"fitWindow","b":"Points#fitWindow","c":"points.js","e":"If the canvas has a fixed size e.g. 800x800, fitWindow will fill the available window space."},{"$":["Points.html#fullscreen","Points#fullscreen"],"a":"fullscreen","b":"Points#fullscreen","c":"points.js","e":"Triggers the app to run in full screen mode"},{"$":["Points.html#renderPasses","Points#renderPasses"],"a":"renderPasses","b":"Points#renderPasses","c":"points.js","e":"Get the active list of {@link RenderPass}"},{"$":["Points.html#addEventListener","Points#addEventListener"],"a":"addEventListener","b":"Points#addEventListener","c":"points.js","e":"Listens for an event dispatched from WGSL code"},{"$":["Points.html#init","Points#init"],"a":"init","b":"Points#init","c":"points.js","e":"One time function call to initialize the shaders."},{"$":["Points.html#setAudio","Points#setAudio"],"a":"setAudio","b":"Points#setAudio","c":"points.js","e":"Assigns an audio FrequencyData to a StorageMap.  Calling setAudio creates a Storage with name in the wgsl shaders.  From this storage you can read the audio data sent to the shader as numeric values.  Values in audio.data are composed of integers on a scale from 0..255"},{"$":["Points.html#setBindingTexture","Points#setBindingTexture"],"a":"setBindingTexture","b":"Points#setBindingTexture","c":"points.js","e":"Special texture where data can be written to it in the Compute Shader and Is a one way communication method. Ideal to store data to it in the Compute Shader and later visualize it in the Fragment Shader."},{"$":["Points.html#setLayers","Points#setLayers"],"a":"setLayers","b":"Points#setLayers","c":"points.js","e":"Layers of data made of vec4f. This creates a storage array named layers of the size of the screen in pixels;"},{"$":["Points.html#setMeshDensity","Points#setMeshDensity"],"a":"setMeshDensity","b":"Points#setMeshDensity","c":"points.js","e":"Establishes the density of the base mesh, by default 1x1, meaning two triangles. The final number of triangles is numColumns * numRows * 2 ( 2 being the triangles )"},{"$":["Points.html#setSampler","Points#setSampler"],"a":"setSampler","b":"Points#setSampler","c":"points.js","e":"Creates a sampler to be sent to the shaders. Internally it will be a {@link GPUSampler}"},{"$":["Points.html#setStorage","Points#setStorage"],"a":"setStorage","b":"Points#setStorage","c":"points.js","e":"Creates a persistent memory buffer across every frame call. See <a href=\"https://www.w3.org/TR/webgpu/#gpubuffer\">GPUBuffer   Meaning it can be updated in the shaders across the execution of every frame.   It can have almost any type, like f32 or vec2f or even array."},{"$":["Points.html#setStorageMap","Points#setStorageMap"],"a":"setStorageMap","b":"Points#setStorageMap","c":"points.js","e":"Creates a persistent memory buffer across every frame call that can be updated. See <a href=\"https://www.w3.org/TR/webgpu/#gpubuffer\">GPUBuffer   Meaning it can be updated in the shaders across the execution of every frame.   It can have almost any type, like f32 or vec2f or even array.   The difference with {@link Points#setStorage|setStorage} is that this can be initialized with data."},{"$":["Points.html#setTexture2d","Points#setTexture2d"],"a":"setTexture2d","b":"Points#setTexture2d","c":"points.js","e":"Creates a texture_2d in the shaders.  Used to write data and then print to screen.  It can also be used for write the current render pass (what you see on the screen) to this texture, to be used in the next cycle of this render pass; meaning you effectively have the previous frame data before printing the next one."},{"$":["Points.html#setTextureImage","Points#setTextureImage"],"a":"setTextureImage","b":"Points#setTextureImage","c":"points.js","e":"Loads an image as texture_2d and then it will be available to read data from in the shaders.  Supports web formats like JPG, PNG."},{"$":["Points.html#setTextureImageArray","Points#setTextureImageArray"],"a":"setTextureImageArray","b":"Points#setTextureImageArray","c":"points.js","e":"Load images as texture_2d_array"},{"$":["Points.html#setTextureString","Points#setTextureString"],"a":"setTextureString","b":"Points#setTextureString","c":"points.js","e":"Loads a text string as a texture.  Using an Atlas or a Spritesheet with UTF-16 chars (path) it will create a new texture that contains only the text characters.  Characters in the atlas path must be in order of the UTF-16 chars.  It can have missing characters at the end or at the start, so the offset is added to take account for those chars.  For example, A is 65, but if one character is removed before the letter A, then offset is -1"},{"$":["Points.html#setTextureVideo","Points#setTextureVideo"],"a":"setTextureVideo","b":"Points#setTextureVideo","c":"points.js","e":"Loads a video as texture_externaland then it will be available to read data from in the shaders. Supports web formats like mp4 and webm."},{"$":["Points.html#setTextureWebcam","Points#setTextureWebcam"],"a":"setTextureWebcam","b":"Points#setTextureWebcam","c":"points.js","e":"Loads webcam as texture_externaland then it will be available to read data from in the shaders."},{"$":["Points.html#setUniform","Points#setUniform"],"a":"setUniform","b":"Points#setUniform","c":"points.js","e":"Sets a param (predefined struct already in all shader) as uniform to send to all shaders. A Uniform is a value that can only be changed from the outside (js side, not the wgsl side), and unless changed it remains consistent."},{"$":["Points.html#update","Points#update"],"a":"update","b":"Points#update","c":"points.js","e":"Method executed on each {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame | requestAnimationFrame}. Here's where all the calls to update data will be executed."},{"$":["Points.html#updateUniforms","Points#updateUniforms"],"a":"updateUniforms","b":"Points#updateUniforms","c":"points.js","e":"Updates a list of uniforms"},{"$":["RenderPass.html","RenderPass"],"a":"RenderPass","b":"RenderPass","c":"RenderPass.js","d":"A RenderPass is a way to have a block of shaders to pass to your application pipeline and these render passes will be executed in the order you pass them in the {@link Points#init} method.","e":"A collection of Vertex, Compute and Fragment shaders that represent a RenderPass. This is useful for PostProcessing."},{"$":["RenderPass.html#computeShader","RenderPass#computeShader"],"a":"computeShader","b":"RenderPass#computeShader","c":"RenderPass.js","e":"get the compute shader content"},{"$":["RenderPass.html#fragmentShader","RenderPass#fragmentShader"],"a":"fragmentShader","b":"RenderPass#fragmentShader","c":"RenderPass.js","e":"get the fragment shader content"},{"$":["RenderPass.html#vertexShader","RenderPass#vertexShader"],"a":"vertexShader","b":"RenderPass#vertexShader","c":"RenderPass.js","e":"get the vertex shader content"},{"$":["RenderPasses.html","RenderPasses"],"a":"RenderPasses","b":"RenderPasses","c":"RenderPasses.js","d":"List of predefined Render Passes for Post Processing."},{"$":["RenderPasses.html#.add","RenderPasses.add"],"a":"add","b":"RenderPasses.add","c":"RenderPasses.js","e":"Adds a RenderPass from the RenderPasses list"},{"$":["RenderPasses.html#.bloom","RenderPasses.bloom"],"a":"bloom","b":"RenderPasses.bloom","c":"RenderPasses.js","e":"Bloom postprocessing. Increases brightness of already bright areas to create a haze effect."},{"$":["RenderPasses.html#.blur","RenderPasses.blur"],"a":"blur","b":"RenderPasses.blur","c":"RenderPasses.js","e":"Blur postprocessing. Softens an image by creating multiple samples."},{"$":["RenderPasses.html#.chromaticAberration","RenderPasses.chromaticAberration"],"a":"chromaticAberration","b":"RenderPasses.chromaticAberration","c":"RenderPasses.js","e":"Chromatic Aberration postprocessing. Color bleeds simulating a lens effect without distortion."},{"$":["RenderPasses.html#.color","RenderPasses.color"],"a":"color","b":"RenderPasses.color","c":"RenderPasses.js","e":"Color postprocessing"},{"$":["RenderPasses.html#.filmgrain","RenderPasses.filmgrain"],"a":"filmgrain","b":"RenderPasses.filmgrain","c":"RenderPasses.js","e":"Film grain postprocessing. White noise added to the output to simulate film irregularities."},{"$":["RenderPasses.html#.grayscale","RenderPasses.grayscale"],"a":"grayscale","b":"RenderPasses.grayscale","c":"RenderPasses.js","e":"Grayscale postprocessing. Takes the brightness of an image and returns it; that makes the grayscale result."},{"$":["RenderPasses.html#.lensDistortion","RenderPasses.lensDistortion"],"a":"lensDistortion","b":"RenderPasses.lensDistortion","c":"RenderPasses.js","e":"Lens Distortion postprocessing. A fisheye distortion with chromatic aberration."},{"$":["RenderPasses.html#.pixelate","RenderPasses.pixelate"],"a":"pixelate","b":"RenderPasses.pixelate","c":"RenderPasses.js","e":"Pixelate postprocessing. It reduces the amount of pixels in the output preserving the scale."},{"$":["RenderPasses.html#.waves","RenderPasses.waves"],"a":"waves","b":"RenderPasses.waves","c":"RenderPasses.js","e":"Waves postprocessing. Distorts the image with noise to create a water like effect."},{"$":["ShaderType.html","ShaderType"],"a":"ShaderType","b":"ShaderType","c":"ShaderType.js","e":"In different calls to the main {@link Points} class, it is used to tell the library in what stage of the shaders the data to be sent."},{"$":["ShaderType.html#COMPUTE","ShaderType#COMPUTE"],"a":"COMPUTE","b":"ShaderType#COMPUTE","c":"ShaderType.js","e":"Compute Shader"},{"$":["ShaderType.html#FRAGMENT","ShaderType#FRAGMENT"],"a":"FRAGMENT","b":"ShaderType#FRAGMENT","c":"ShaderType.js","e":"Fragment Shader"},{"$":["ShaderType.html#VERTEX","ShaderType#VERTEX"],"a":"VERTEX","b":"ShaderType#VERTEX","c":"ShaderType.js","e":"Vertex Shader"}]</script><script id="docolatte-search-index" type="application/json">{"keys":[{"path":["a"],"id":"a","weight":10,"src":"a"},{"path":["b"],"id":"b","weight":9,"src":"b"},{"path":["c"],"id":"c","weight":6,"src":"c"},{"path":["d"],"id":"d","weight":2,"src":"d"},{"path":["e"],"id":"e","weight":2,"src":"e"}],"records":[{"i":0,"$":{"0":{"v":"defaultFunctions","n":1},"1":{"v":"module:defaultFunctions","n":1},"2":{"v":"core/defaultFunctions.js","n":1},"4":{"v":"The defaultFunctions are functions already incorporated onto the shaders you create, so you can call them without import.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader. Use the base example as reference: examples/base/vert.js","n":0.136}}},{"i":1,"$":{"0":{"v":"defaultVertexBody","n":1},"1":{"v":"module:defaultFunctions.defaultVertexBody","n":1},"2":{"v":"core/defaultFunctions.js","n":1},"4":{"v":"The defaultVertexBody is used as a drop-in replacement of the vertex shader content.   This is not required, but useful if you plan to use the default parameters of the library.   All the examples in the examples directory use this function in their vert.js file.     Default function for the Vertex shader that takes charge of automating the creation of a few variables that are commonly used.","n":0.124}}},{"i":2,"$":{"0":{"v":"defaultStructs","n":1},"1":{"v":"module:defaultStructs","n":1},"2":{"v":"core/defaultStructs.js","n":1},"4":{"v":"The defaultStructs are structs already incorporated onto the shaders you create, so you can call them without import.   Fragment, Sound, and Event structs.     Fragment used in Vertex Shaders.  Sound used along with {@link Points#setAudio}  Event used along with {@link Points#addEventListener} ","n":0.158}}},{"i":3,"$":{"0":{"v":"points/animation","n":1},"1":{"v":"module:points/animation","n":1},"2":{"v":"core/animation.js","n":1},"4":{"v":"Utilities for animation.   Functions that use sine and params.time to increase and decrease a value over time.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.147}}},{"i":4,"$":{"0":{"v":"fnusin","n":1},"1":{"v":"module:points/animation.fnusin","n":1},"2":{"v":"core/animation.js","n":1},"4":{"v":"Animates sin() over params.time and a provided speed. The value is normalized, so in the range 0..1","n":0.243}}},{"i":5,"$":{"0":{"v":"fucos","n":1},"1":{"v":"module:points/animation.fucos","n":1},"2":{"v":"core/animation.js","n":1},"4":{"v":"Animates cos() over params.time and a provided speed. The value is not normalized, so in the range -1..1","n":0.236}}},{"i":6,"$":{"0":{"v":"fusin","n":1},"1":{"v":"module:points/animation.fusin","n":1},"2":{"v":"core/animation.js","n":1},"4":{"v":"Animates sin() over params.time and a provided speed. The value is not normalized, so in the range -1..1","n":0.236}}},{"i":7,"$":{"0":{"v":"points/audio","n":1},"1":{"v":"module:points/audio","n":1},"2":{"v":"core/audio.js","n":1},"4":{"v":"Utilities for audio work.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.174}}},{"i":8,"$":{"0":{"v":"audioAverage","n":1},"1":{"v":"module:points/audio.audioAverage","n":1},"2":{"v":"core/audio.js","n":1},"4":{"v":"Average of all the value in sound.data (Sound struct in {@link module:defaultStructs})","n":0.289}}},{"i":9,"$":{"0":{"v":"audioAverageSegments","n":1},"1":{"v":"module:points/audio.audioAverageSegments","n":1},"2":{"v":"core/audio.js","n":1},"4":{"v":"WIP","n":1}}},{"i":10,"$":{"0":{"v":"points/cellular2d","n":1},"1":{"v":"module:points/cellular2d","n":1},"2":{"v":"core/cellular2d.js","n":1},"4":{"v":"original: Author :  Stefan Gustavson (stefan.gustavson@liu.se)  https://github.com/ashima/webgl-noise/blob/master/src/cellular2D.glsl    These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.167}}},{"i":11,"$":{"0":{"v":"cellular","n":1},"1":{"v":"module:points/cellular2d.cellular","n":1},"2":{"v":"core/cellular2d.js","n":1},"4":{"v":"Cellular noise","n":0.707}}},{"i":12,"$":{"0":{"v":"points/classicnoise2d","n":1},"1":{"v":"module:points/classicnoise2d","n":1},"2":{"v":"core/classicnoise2d.js","n":1},"4":{"v":"original: Author :  Stefan Gustavson (stefan.gustavson@liu.se)  https://github.com/ashima/webgl-noise/blob/master/src/classicnoise2D.glsl    These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.167}}},{"i":13,"$":{"0":{"v":"cnoise","n":1},"1":{"v":"module:points/classicnoise2d.cnoise","n":1},"2":{"v":"core/classicnoise2d.js","n":1},"4":{"v":"Classic Perlin Noise","n":0.577}}},{"i":14,"$":{"0":{"v":"pnoise","n":1},"1":{"v":"module:points/classicnoise2d.pnoise","n":1},"2":{"v":"core/classicnoise2d.js","n":1},"4":{"v":"Classic Perlin Noise, periodic variant","n":0.447}}},{"i":15,"$":{"0":{"v":"points/color","n":1},"1":{"v":"module:points/color","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"A few color constants and wgsl methods to work with colors.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.158}}},{"i":16,"$":{"0":{"v":"BLACK","n":1},"1":{"v":"module:points/color.BLACK","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"BLACK color;","n":0.707}}},{"i":17,"$":{"0":{"v":"BLUE","n":1},"1":{"v":"module:points/color.BLUE","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"BLUE color;","n":0.707}}},{"i":18,"$":{"0":{"v":"CYAN","n":1},"1":{"v":"module:points/color.CYAN","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"CYAN color;","n":0.707}}},{"i":19,"$":{"0":{"v":"GREEN","n":1},"1":{"v":"module:points/color.GREEN","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"GREEN color;","n":0.707}}},{"i":20,"$":{"0":{"v":"MAGENTA","n":1},"1":{"v":"module:points/color.MAGENTA","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"MAGENTA color;","n":0.707}}},{"i":21,"$":{"0":{"v":"RED","n":1},"1":{"v":"module:points/color.RED","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"RED color;","n":0.707}}},{"i":22,"$":{"0":{"v":"RGBAFromHSV","n":1},"1":{"v":"module:points/color.RGBAFromHSV","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Creates a rgba vec4f from an hsv color value","n":0.333}}},{"i":23,"$":{"0":{"v":"WHITE","n":1},"1":{"v":"module:points/color.WHITE","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"WHITE color;","n":0.707}}},{"i":24,"$":{"0":{"v":"YELLOW","n":1},"1":{"v":"module:points/color.YELLOW","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"YELLOW color;","n":0.707}}},{"i":25,"$":{"0":{"v":"bloom","n":1},"1":{"v":"module:points/color.bloom","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Compute the FFT (Fast Fourier Transform)","n":0.408}}},{"i":26,"$":{"0":{"v":"brightness","n":1},"1":{"v":"module:points/color.brightness","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Returns the perceived brightness of a color by the eye.  // Standard  LuminanceA = (0.2126*R) + (0.7152*G) + (0.0722*B)","n":0.229}}},{"i":27,"$":{"0":{"v":"brightnessB","n":1},"1":{"v":"module:points/color.brightnessB","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Returns the perceived brightness of a color by the eye.  // Percieved A  LuminanceB = (0.299*R + 0.587*G + 0.114*B)","n":0.224}}},{"i":28,"$":{"0":{"v":"brightnessC","n":1},"1":{"v":"module:points/color.brightnessC","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Returns the perceived brightness of a color by the eye.  // Percieved B  slower to calculate  LuminanceC = sqrt(0.299*(R**2) + 0.587*(G**2) + 0.114*(B**2))","n":0.209}}},{"i":29,"$":{"0":{"v":"layer","n":1},"1":{"v":"module:points/color.layer","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Layers two colors by cropping the color in the back, based on the alpha value.","n":0.258}}},{"i":30,"$":{"0":{"v":"points/debug","n":1},"1":{"v":"module:points/debug","n":1},"2":{"v":"core/debug.js","n":1},"4":{"v":"Visual debugging methods like drawing a cross on screen and drawing a square around the screen.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.149}}},{"i":31,"$":{"0":{"v":"showDebugCross","n":1},"1":{"v":"module:points/debug.showDebugCross","n":1},"2":{"v":"core/debug.js","n":1},"4":{"v":"Draws an infinite cross. Useful to draw it where the mouse is.","n":0.289}}},{"i":32,"$":{"0":{"v":"showDebugFrame","n":1},"1":{"v":"module:points/debug.showDebugFrame","n":1},"2":{"v":"core/debug.js","n":1},"4":{"v":"Border around the screen","n":0.5}}},{"i":33,"$":{"0":{"v":"points/effects","n":1},"1":{"v":"module:points/effects","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.186}}},{"i":34,"$":{"0":{"v":"blur9","n":1},"1":{"v":"module:points/effects.blur9","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Applies a blur to an image   based on https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl","n":0.333}}},{"i":35,"$":{"0":{"v":"clearAlpha","n":1},"1":{"v":"module:points/effects.clearAlpha","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Takes a color and reduces its value but applied to the alpha channel.","n":0.277}}},{"i":36,"$":{"0":{"v":"clearMix","n":1},"1":{"v":"module:points/effects.clearMix","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Takes a color and reduces its values by a level","n":0.316}}},{"i":37,"$":{"0":{"v":"euclideanDistance","n":1},"1":{"v":"module:points/effects.euclideanDistance","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Calculates the <a href=\"https://en.wikipedia.org/wiki/Euclidean_distance\">Euclidean Distance between colors.","n":0.378}}},{"i":38,"$":{"0":{"v":"getClosestColorInPalette","n":1},"1":{"v":"module:points/effects.getClosestColorInPalette","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"This assumes you have declared a palette in a variable or constant called getClosestColorInPalette_palette   Gets the closest color based on the distance parameter.","n":0.209}}},{"i":39,"$":{"0":{"v":"getColorsAround4Texture","n":1},"1":{"v":"module:points/effects.getColorsAround4Texture","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"From a given texture and its position, get top, botto, left and right color values","n":0.258}}},{"i":40,"$":{"0":{"v":"getColorsAroundTexture","n":1},"1":{"v":"module:points/effects.getColorsAroundTexture","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"From a given texture and its position, get the 9 color values around.","n":0.277}}},{"i":41,"$":{"0":{"v":"orderedDithering","n":1},"1":{"v":"module:points/effects.orderedDithering","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Applies <a href=\"https://en.wikipedia.org/wiki/Ordered_dithering\">Ordered Dithering to a color. Best with the colors of an image texture.   This requires orderedDithering_threshold_map to be imported or create your own version of it.","n":0.189}}},{"i":42,"$":{"0":{"v":"orderedDithering_threshold_map","n":1},"1":{"v":"module:points/effects.orderedDithering_threshold_map","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"To be used with orderedDithering.  You can use this or create yours.","n":0.289}}},{"i":43,"$":{"0":{"v":"soften4","n":1},"1":{"v":"module:points/effects.soften4","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Softens a color based on list of colors around it or any list of 4 colors.","n":0.25}}},{"i":44,"$":{"0":{"v":"soften8","n":1},"1":{"v":"module:points/effects.soften8","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Softens a color based on list of colors around it or any list of 8 colors.","n":0.25}}},{"i":45,"$":{"0":{"v":"points/image","n":1},"1":{"v":"module:points/image","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.186}}},{"i":46,"$":{"0":{"v":"decodeNumberSprite","n":1},"1":{"v":"module:points/image.decodeNumberSprite","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"From a provided number, get the sprite in an atlas that matches the value.","n":0.267}}},{"i":47,"$":{"0":{"v":"flipTextureUV","n":1},"1":{"v":"module:points/image.flipTextureUV","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Flips texture in Y. This because it comes flipped, so this corrects it.","n":0.277}}},{"i":48,"$":{"0":{"v":"pixelateTexture","n":1},"1":{"v":"module:points/image.pixelateTexture","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Increase the aparent pixel size of the texture image using textureSample. This reduces the quality of the image.","n":0.236}}},{"i":49,"$":{"0":{"v":"pixelateTexturePosition","n":1},"1":{"v":"module:points/image.pixelateTexturePosition","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Increase the aparent pixel size of the texture image using texturePosition. This reduces the quality of the image.","n":0.236}}},{"i":50,"$":{"0":{"v":"sprite","n":1},"1":{"v":"module:points/image.sprite","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Sprite or Atlas. Extract a piece of the sprite with an index.","n":0.289}}},{"i":51,"$":{"0":{"v":"textureExternalPosition","n":1},"1":{"v":"module:points/image.textureExternalPosition","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Places texture_external in a position. Texture external being in this case a video loaded as texture in the JS side.","n":0.224}}},{"i":52,"$":{"0":{"v":"texturePosition","n":1},"1":{"v":"module:points/image.texturePosition","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Places texture in a position. The texture being an image loaded from the JS side.","n":0.258}}},{"i":53,"$":{"0":{"v":"points/math","n":1},"1":{"v":"module:points/math","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"Math utils These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.18}}},{"i":54,"$":{"0":{"v":"E","n":1},"1":{"v":"module:points/math.E","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"E is a mathematical constant approximately equal to 2.71828 that is the base of the natural logarithm and exponential function. It is sometimes called Euler's number, after the Swiss mathematician Leonhard Euler.","n":0.177}}},{"i":55,"$":{"0":{"v":"PHI","n":1},"1":{"v":"module:points/math.PHI","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"PHI is the Golden Ratio","n":0.447}}},{"i":56,"$":{"0":{"v":"PI","n":1},"1":{"v":"module:points/math.PI","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"PI is the ratio of a circle's circumference to its diameter.","n":0.302}}},{"i":57,"$":{"0":{"v":"TAU","n":1},"1":{"v":"module:points/math.TAU","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"TAU  is the ratio of a circle's circumference to its radius.","n":0.302}}},{"i":58,"$":{"0":{"v":"polar","n":1},"1":{"v":"module:points/math.polar","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"Using polar coordinates, calculates the final point as vec2f","n":0.333}}},{"i":59,"$":{"0":{"v":"rotateVector","n":1},"1":{"v":"module:points/math.rotateVector","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"Rotates a vector an amount of radians","n":0.378}}},{"i":60,"$":{"0":{"v":"points/noise2d","n":1},"1":{"v":"module:points/noise2d","n":1},"2":{"v":"core/noise2d.js","n":1},"4":{"v":"original: Author : Ian McEwan, Ashima Arts. https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.164}}},{"i":61,"$":{"0":{"v":"snoise","n":1},"1":{"v":"module:points/noise2d.snoise","n":1},"2":{"v":"core/noise2d.js","n":1},"4":{"v":"Sinplex Noise function","n":0.577}}},{"i":62,"$":{"0":{"v":"points/random","n":1},"1":{"v":"module:points/random","n":1},"2":{"v":"core/random.js","n":1},"4":{"v":"Various random functions. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.177}}},{"i":63,"$":{"0":{"v":"rand","n":1},"1":{"v":"module:points/random.rand","n":1},"2":{"v":"core/random.js","n":1},"4":{"v":"Random number that returns a vec2f.  You have to set the rand_seed before calling rand().","n":0.258}}},{"i":64,"$":{"0":{"v":"rand2","n":1},"1":{"v":"module:points/random.rand2","n":1},"2":{"v":"core/random.js","n":1},"4":{"v":"Random number from vec2f param","n":0.447}}},{"i":65,"$":{"0":{"v":"random","n":1},"1":{"v":"module:points/random.random","n":1},"2":{"v":"core/random.js","n":1},"4":{"v":"Single random number. Use seed to change seed.","n":0.354}}},{"i":66,"$":{"0":{"v":"points/sdf","n":1},"1":{"v":"module:points/sdf","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"A few signed distance functions.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.171}}},{"i":67,"$":{"0":{"v":"sdfCircle","n":1},"1":{"v":"module:points/sdf.sdfCircle","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Creates a circle","n":0.577}}},{"i":68,"$":{"0":{"v":"sdfLine","n":1},"1":{"v":"module:points/sdf.sdfLine","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Creates a line with a pixel stroke.","n":0.378}}},{"i":69,"$":{"0":{"v":"sdfLine2","n":1},"1":{"v":"module:points/sdf.sdfLine2","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Better than sdfLine to create lines","n":0.408}}},{"i":70,"$":{"0":{"v":"sdfSegment","n":1},"1":{"v":"module:points/sdf.sdfSegment","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Function used to create lines. It's a dependency of them.","n":0.316}}},{"i":71,"$":{"0":{"v":"sdfSmooth","n":1},"1":{"v":"module:points/sdf.sdfSmooth","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Special for letters and create an sdf version of a texture","n":0.302}}},{"i":72,"$":{"0":{"v":"sdfSquare","n":1},"1":{"v":"module:points/sdf.sdfSquare","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Creates a square","n":0.577}}},{"i":73,"$":{"0":{"v":"points/valuenoise","n":1},"1":{"v":"module:points/valuenoise","n":1},"2":{"v":"core/valuenoise.js","n":1},"4":{"v":"Value noise methods. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.177}}},{"i":74,"$":{"0":{"v":"valueNoise","n":1},"1":{"v":"module:points/valuenoise.valueNoise","n":1},"2":{"v":"core/valuenoise.js","n":1},"4":{"v":"Implementation of a value noise function.  <a href=\"https://en.wikipedia.org/wiki/Value_noise\">value noise","n":0.333}}},{"i":75,"$":{"0":{"v":"points/voronoi","n":1},"1":{"v":"module:points/voronoi","n":1},"2":{"v":"core/voronoi.js","n":1},"4":{"v":"Voronoi functions. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.18}}},{"i":76,"$":{"0":{"v":"voronoi","n":1},"1":{"v":"module:points/voronoi.voronoi","n":1},"2":{"v":"core/voronoi.js","n":1},"4":{"v":"Voronoi noise. Generated randomly.","n":0.5}}},{"i":77,"$":{"0":{"v":"CanvasRecorder","n":1},"1":{"v":"CanvasRecorder","n":1},"2":{"v":"CanvasRecorder.js","n":1},"4":{"v":"Records video from a Canvas to a file.","n":0.354}}},{"i":78,"$":{"0":{"v":"getPNG","n":1},"1":{"v":"CanvasRecorder#getPNG","n":1},"2":{"v":"CanvasRecorder.js","n":1},"4":{"v":"Retrieves the current frame as a PNG and downloads the image.","n":0.302}}},{"i":79,"$":{"0":{"v":"start","n":1},"1":{"v":"CanvasRecorder#start","n":1},"2":{"v":"CanvasRecorder.js","n":1},"4":{"v":"Starts the video recording.","n":0.5}}},{"i":80,"$":{"0":{"v":"stop","n":1},"1":{"v":"CanvasRecorder#stop","n":1},"2":{"v":"CanvasRecorder.js","n":1},"4":{"v":"Stops the video recording and downloads the video.","n":0.354}}},{"i":81,"$":{"0":{"v":"Points","n":1},"1":{"v":"Points","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Main class Points","n":0.577}}},{"i":82,"$":{"0":{"v":"canvas","n":1},"1":{"v":"Points#canvas","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Reference to the canvas assigned in the constructor","n":0.354}}},{"i":83,"$":{"0":{"v":"fitWindow","n":1},"1":{"v":"Points#fitWindow","n":1},"2":{"v":"points.js","n":1},"4":{"v":"If the canvas has a fixed size e.g. 800x800, fitWindow will fill the available window space.","n":0.25}}},{"i":84,"$":{"0":{"v":"fullscreen","n":1},"1":{"v":"Points#fullscreen","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Triggers the app to run in full screen mode","n":0.333}}},{"i":85,"$":{"0":{"v":"renderPasses","n":1},"1":{"v":"Points#renderPasses","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Get the active list of {@link RenderPass}","n":0.378}}},{"i":86,"$":{"0":{"v":"addEventListener","n":1},"1":{"v":"Points#addEventListener","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Listens for an event dispatched from WGSL code","n":0.354}}},{"i":87,"$":{"0":{"v":"init","n":1},"1":{"v":"Points#init","n":1},"2":{"v":"points.js","n":1},"4":{"v":"One time function call to initialize the shaders.","n":0.354}}},{"i":88,"$":{"0":{"v":"setAudio","n":1},"1":{"v":"Points#setAudio","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Assigns an audio FrequencyData to a StorageMap.  Calling setAudio creates a Storage with name in the wgsl shaders.  From this storage you can read the audio data sent to the shader as numeric values.  Values in audio.data are composed of integers on a scale from 0..255","n":0.147}}},{"i":89,"$":{"0":{"v":"setBindingTexture","n":1},"1":{"v":"Points#setBindingTexture","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Special texture where data can be written to it in the Compute Shader and Is a one way communication method. Ideal to store data to it in the Compute Shader and later visualize it in the Fragment Shader.","n":0.162}}},{"i":90,"$":{"0":{"v":"setLayers","n":1},"1":{"v":"Points#setLayers","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Layers of data made of vec4f. This creates a storage array named layers of the size of the screen in pixels;","n":0.218}}},{"i":91,"$":{"0":{"v":"setMeshDensity","n":1},"1":{"v":"Points#setMeshDensity","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Establishes the density of the base mesh, by default 1x1, meaning two triangles. The final number of triangles is numColumns * numRows * 2 ( 2 being the triangles )","n":0.183}}},{"i":92,"$":{"0":{"v":"setSampler","n":1},"1":{"v":"Points#setSampler","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates a sampler to be sent to the shaders. Internally it will be a {@link GPUSampler}","n":0.25}}},{"i":93,"$":{"0":{"v":"setStorage","n":1},"1":{"v":"Points#setStorage","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates a persistent memory buffer across every frame call. See <a href=\"https://www.w3.org/TR/webgpu/#gpubuffer\">GPUBuffer   Meaning it can be updated in the shaders across the execution of every frame.   It can have almost any type, like f32 or vec2f or even array.","n":0.16}}},{"i":94,"$":{"0":{"v":"setStorageMap","n":1},"1":{"v":"Points#setStorageMap","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates a persistent memory buffer across every frame call that can be updated. See <a href=\"https://www.w3.org/TR/webgpu/#gpubuffer\">GPUBuffer   Meaning it can be updated in the shaders across the execution of every frame.   It can have almost any type, like f32 or vec2f or even array.   The difference with {@link Points#setStorage|setStorage} is that this can be initialized with data.","n":0.134}}},{"i":95,"$":{"0":{"v":"setTexture2d","n":1},"1":{"v":"Points#setTexture2d","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates a texture_2d in the shaders.  Used to write data and then print to screen.  It can also be used for write the current render pass (what you see on the screen) to this texture, to be used in the next cycle of this render pass; meaning you effectively have the previous frame data before printing the next one.","n":0.13}}},{"i":96,"$":{"0":{"v":"setTextureImage","n":1},"1":{"v":"Points#setTextureImage","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Loads an image as texture_2d and then it will be available to read data from in the shaders.  Supports web formats like JPG, PNG.","n":0.204}}},{"i":97,"$":{"0":{"v":"setTextureImageArray","n":1},"1":{"v":"Points#setTextureImageArray","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Load images as texture_2d_array","n":0.5}}},{"i":98,"$":{"0":{"v":"setTextureString","n":1},"1":{"v":"Points#setTextureString","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Loads a text string as a texture.  Using an Atlas or a Spritesheet with UTF-16 chars (path) it will create a new texture that contains only the text characters.  Characters in the atlas path must be in order of the UTF-16 chars.  It can have missing characters at the end or at the start, so the offset is added to take account for those chars.  For example, A is 65, but if one character is removed before the letter A, then offset is -1","n":0.109}}},{"i":99,"$":{"0":{"v":"setTextureVideo","n":1},"1":{"v":"Points#setTextureVideo","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Loads a video as texture_externaland then it will be available to read data from in the shaders. Supports web formats like mp4 and webm.","n":0.204}}},{"i":100,"$":{"0":{"v":"setTextureWebcam","n":1},"1":{"v":"Points#setTextureWebcam","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Loads webcam as texture_externaland then it will be available to read data from in the shaders.","n":0.25}}},{"i":101,"$":{"0":{"v":"setUniform","n":1},"1":{"v":"Points#setUniform","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Sets a param (predefined struct already in all shader) as uniform to send to all shaders. A Uniform is a value that can only be changed from the outside (js side, not the wgsl side), and unless changed it remains consistent.","n":0.156}}},{"i":102,"$":{"0":{"v":"update","n":1},"1":{"v":"Points#update","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Method executed on each {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame | requestAnimationFrame}. Here's where all the calls to update data will be executed.","n":0.229}}},{"i":103,"$":{"0":{"v":"updateUniforms","n":1},"1":{"v":"Points#updateUniforms","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Updates a list of uniforms","n":0.447}}},{"i":104,"$":{"0":{"v":"RenderPass","n":1},"1":{"v":"RenderPass","n":1},"2":{"v":"RenderPass.js","n":1},"3":{"v":"A RenderPass is a way to have a block of shaders to pass to your application pipeline and these render passes will be executed in the order you pass them in the {@link Points#init} method.","n":0.169},"4":{"v":"A collection of Vertex, Compute and Fragment shaders that represent a RenderPass. This is useful for PostProcessing.","n":0.243}}},{"i":105,"$":{"0":{"v":"computeShader","n":1},"1":{"v":"RenderPass#computeShader","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"get the compute shader content","n":0.447}}},{"i":106,"$":{"0":{"v":"fragmentShader","n":1},"1":{"v":"RenderPass#fragmentShader","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"get the fragment shader content","n":0.447}}},{"i":107,"$":{"0":{"v":"vertexShader","n":1},"1":{"v":"RenderPass#vertexShader","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"get the vertex shader content","n":0.447}}},{"i":108,"$":{"0":{"v":"RenderPasses","n":1},"1":{"v":"RenderPasses","n":1},"2":{"v":"RenderPasses.js","n":1},"3":{"v":"List of predefined Render Passes for Post Processing.","n":0.354}}},{"i":109,"$":{"0":{"v":"add","n":1},"1":{"v":"RenderPasses.add","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Adds a RenderPass from the RenderPasses list","n":0.378}}},{"i":110,"$":{"0":{"v":"bloom","n":1},"1":{"v":"RenderPasses.bloom","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Bloom postprocessing. Increases brightness of already bright areas to create a haze effect.","n":0.277}}},{"i":111,"$":{"0":{"v":"blur","n":1},"1":{"v":"RenderPasses.blur","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Blur postprocessing. Softens an image by creating multiple samples.","n":0.333}}},{"i":112,"$":{"0":{"v":"chromaticAberration","n":1},"1":{"v":"RenderPasses.chromaticAberration","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Chromatic Aberration postprocessing. Color bleeds simulating a lens effect without distortion.","n":0.302}}},{"i":113,"$":{"0":{"v":"color","n":1},"1":{"v":"RenderPasses.color","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Color postprocessing","n":0.707}}},{"i":114,"$":{"0":{"v":"filmgrain","n":1},"1":{"v":"RenderPasses.filmgrain","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Film grain postprocessing. White noise added to the output to simulate film irregularities.","n":0.277}}},{"i":115,"$":{"0":{"v":"grayscale","n":1},"1":{"v":"RenderPasses.grayscale","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Grayscale postprocessing. Takes the brightness of an image and returns it; that makes the grayscale result.","n":0.25}}},{"i":116,"$":{"0":{"v":"lensDistortion","n":1},"1":{"v":"RenderPasses.lensDistortion","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Lens Distortion postprocessing. A fisheye distortion with chromatic aberration.","n":0.333}}},{"i":117,"$":{"0":{"v":"pixelate","n":1},"1":{"v":"RenderPasses.pixelate","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Pixelate postprocessing. It reduces the amount of pixels in the output preserving the scale.","n":0.267}}},{"i":118,"$":{"0":{"v":"waves","n":1},"1":{"v":"RenderPasses.waves","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Waves postprocessing. Distorts the image with noise to create a water like effect.","n":0.277}}},{"i":119,"$":{"0":{"v":"ShaderType","n":1},"1":{"v":"ShaderType","n":1},"2":{"v":"ShaderType.js","n":1},"4":{"v":"In different calls to the main {@link Points} class, it is used to tell the library in what stage of the shaders the data to be sent.","n":0.192}}},{"i":120,"$":{"0":{"v":"COMPUTE","n":1},"1":{"v":"ShaderType#COMPUTE","n":1},"2":{"v":"ShaderType.js","n":1},"4":{"v":"Compute Shader","n":0.707}}},{"i":121,"$":{"0":{"v":"FRAGMENT","n":1},"1":{"v":"ShaderType#FRAGMENT","n":1},"2":{"v":"ShaderType.js","n":1},"4":{"v":"Fragment Shader","n":0.707}}},{"i":122,"$":{"0":{"v":"VERTEX","n":1},"1":{"v":"ShaderType#VERTEX","n":1},"2":{"v":"ShaderType.js","n":1},"4":{"v":"Vertex Shader","n":0.707}}}]}</script><script id="docolatte-search-options" type="application/json">{"keys":[{"name":"a","weight":10},{"name":"b","weight":9},{"name":"c","weight":6},{"name":"d","weight":2},{"name":"e","weight":2}]}</script>

</body>
</html>
