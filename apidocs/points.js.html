
<!DOCTYPE html>
<html lang="en" data-color-scheme="auto">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Source: points.js | Points</title>
    <meta name="description" content="A Generative Art library made in WebGPU"><meta name="keywords" content="javascript, webgl, crative-coding, shaders, generative-art, webgpu, genart, wgsl">
    <link rel="icon" title="dummy" href="data:image/x-icon;base64,AA">
    <script src="scripts/docolatte.min.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/simplebar.min.css"><link type="text/css" rel="stylesheet" href="styles/hljs/nord.css"><link type="text/css" rel="stylesheet" href="styles/docolatte.min.css">
    <script>window.$docolatte.config = {"searchLimit":8,"syncHash":"scrollend"}</script>
    <noscript><style>[data-ready] { visibility: visible !important; }</style></noscript>
    <style>.header .masthead .title { font-size: 1.5em; font-family: Helvetica, sans-serif; }</style>
</head>
<body class="config">
<div class="site">

    <header class="header">
        <div class="masthead">
            <a class="link" href="https://github.com/Absulit/points"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home icon"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg></a>
            <a class="title" href="index.html">Points</a>
        </div>
        <div class="topbar">
            <h1 class="page-title">
                <a href="#">Source: points.js</a>
            </h1>
            <a class="light-switch" title="Switch light/dark mode" href="#"><i class="label auto">
<svg  class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	<path d="M 12 3 A 9 9 0 0 0 12 21 Z" stroke="none" fill="currentColor"/>
	<circle cx="12" cy="12" r="9"/>
</svg></i><i class="label light"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun icon"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></i><i class="label dark"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon icon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></i></a>
        </div>
    </header>

    <div class="primary">
        <main class="main">
            



    
<article class="src">
    <pre class="prettyprint source linenums lang-js"><span class="_char">_</span><code>import UniformKeys from './UniformKeys.js';
import VertexBufferInfo from './VertexBufferInfo.js';
import RenderPass, { PrimitiveTopology, LoadOp, CullMode } from './RenderPass.js';
import RenderPasses from './RenderPasses.js';
import Coordinate from './coordinate.js';
import RGBAColor from './color.js';
import Clock from './clock.js';
import defaultStructs from './core/defaultStructs.js';
import { defaultVertexBody } from './core/defaultFunctions.js';
import { dataSize, getArrayTypeData, isArray, typeSizes } from './data-size.js';
import { loadImage, strToImage } from './texture-string.js';
import LayersArray from './LayersArray.js';
import UniformsArray from './UniformsArray.js';
import getStorageAccessMode, { bindingModes, entriesModes } from './storage-accessmode.js';
import { cross, dot, normalize, sub } from './matrix.js';

class PresentationFormat {
    static BGRA8UNORM = 'bgra8unorm';
    static RGBA8UNORM = 'rgba8unorm';
    static RGBA16FLOAT = 'rgba16float';
    static RGBA32FLOAT = 'rgba32float';
}

/**
 * Main class Points, this is the entry point of an application with this library.
 * @example
 * import Points from 'points';
 * const points = new Points('canvas');
 *
 * let renderPasses = [
 *     new RenderPass(vert1, frag1, compute1),
 *     new RenderPass(vert2, frag2, compute2)
 * ];
 *
 * await points.init(renderPasses);
 * update();
 *
 * function update() {
 *     points.update();
 *     requestAnimationFrame(update);
 * }
 *
 */
class Points {
    #canvasId = null;
    #canvas = null;
    /** @type {GPUAdapter} */
    #adapter = null;
    /** @type {GPUDevice} */
    #device = null;
    #context = null;
    #presentationFormat = null;
    /** @type {Array&lt;RenderPass>} */
    #renderPasses = null;
    #postRenderPasses = [];
    #buffer = null;
    #presentationSize = null;
    #numColumns = 1;
    #numRows = 1;
    #commandsFinished = [];
    #uniforms = new UniformsArray();
    #meshUniforms = new UniformsArray();
    #cameraUniforms = new UniformsArray();
    #constants = [];
    #storage = [];
    #readStorage = [];
    #samplers = [];
    #textures2d = [];
    #texturesDepth2d = [];
    #texturesToCopy = [];
    #textures2dArray = [];
    #texturesExternal = [];
    #texturesStorage2d = [];
    #bindingTextures = [];
    #layers = new LayersArray();
    #originalCanvasWidth = null;
    #originalCanvasHeigth = null;
    #clock = new Clock();
    #time = 0;
    #delta = 0;
    #epoch = 0;
    #mouseX = 0;
    #mouseY = 0;
    #mouseDown = false;
    #mouseClick = false;
    #mouseWheel = false;
    #mouseDelta = [0, 0];
    #fullscreen = false;
    #fitWindow = false;
    #lastFitWindow = false;
    #sounds = []; // audio
    #events = new Map();
    #events_ids = 0;
    #dataSize = null;
    #screenResized = false;
    #textureUpdated = false;

    constructor(canvasId) {
        this.#canvasId = canvasId;
        this.#canvas = document.getElementById(this.#canvasId);
        if (this.#canvasId) {
            this.#canvas.addEventListener('click', e => {
                this.#mouseClick = true;
            });
            this.#canvas.addEventListener('mousemove', this.#onMouseMove, { passive: true });
            this.#canvas.addEventListener('mousedown', e => {
                this.#mouseDown = true;
            });
            this.#canvas.addEventListener('mouseup', e => {
                this.#mouseDown = false;
            });
            this.#canvas.addEventListener('wheel', e => {
                this.#mouseWheel = true;
                this.#mouseDelta = [e.deltaX, e.deltaY];
            }, { passive: true });
            this.#originalCanvasWidth = this.#canvas.clientWidth;
            this.#originalCanvasHeigth = this.#canvas.clientHeight;
            window.addEventListener('resize', this.#resizeCanvasToFitWindow, false);
            document.addEventListener('fullscreenchange', e => {
                this.#fullscreen = !!document.fullscreenElement;
                if (!this.#fullscreen &amp;&amp; !this.#fitWindow) {
                    this.#resizeCanvasToDefault();
                }
                if (!this.#fullscreen) {
                    this.fitWindow = this.#lastFitWindow;
                }
            });
        }

        // initializing internal uniforms
        this.setUniform(UniformKeys.TIME, this.#time);
        this.setUniform(UniformKeys.DELTA, this.#delta);
        this.setUniform(UniformKeys.EPOCH, this.#epoch);
        this.setUniform(UniformKeys.MOUSE_CLICK, this.#mouseClick);
        this.setUniform(UniformKeys.MOUSE_DOWN, this.#mouseDown);
        this.setUniform(UniformKeys.MOUSE_WHEEL, this.#mouseWheel);
        this.setUniform(UniformKeys.SCREEN, [0, 0], 'vec2f');
        this.setUniform(UniformKeys.MOUSE, [0, 0], 'vec2f');
        this.setUniform(UniformKeys.MOUSE_DELTA, this.#mouseDelta, 'vec2f');
    }

    #resizeCanvasToFitWindow = () => {
        this.#screenResized = true;
        if (this.#fitWindow) {
            const { offsetWidth, offsetHeight } = this.#canvas.parentNode;
            this.#canvas.width = offsetWidth;
            this.#canvas.height = offsetHeight;
            this.#setScreenSize();
        }
    }

    #resizeCanvasToDefault = () => {
        this.#screenResized = true;
        this.#canvas.width = this.#originalCanvasWidth;
        this.#canvas.height = this.#originalCanvasHeigth;
        this.#setScreenSize();
    }

    #setScreenSize = () => {
        // assigning size here because both sizes must match for the full screen
        // this was not happening before the speed up refactor
        this.#canvas.width = canvas.clientWidth;
        this.#canvas.height = canvas.clientHeight;

        this.#presentationSize = [
            this.#canvas.clientWidth,
            this.#canvas.clientHeight,
        ];
        this.#context.configure({
            label: '_context',
            device: this.#device,
            format: this.#presentationFormat,
            //size: this.#presentationSize,
            width: this.#presentationSize[0],
            height: this.#presentationSize[1],
            alphaMode: 'premultiplied',
            // Specify we want both RENDER_ATTACHMENT and COPY_SRC since we
            // will copy out of the swapchain texture.
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
        });

        this.#renderPasses.forEach(renderPass => {
            renderPass.textureDepth = this.#createTextureDepth('_depthTexture');
        })

        // this is to solve an issue that requires the texture to be resized
        // if the screen dimensions change, this for a `setTexture2d` with
        // `copyCurrentTexture` parameter set to `true`.
        this.#textures2d.forEach(texture2d => {
            if (!texture2d.imageTexture &amp;&amp; texture2d.texture) {
                this.#createTextureBindingToCopy(texture2d);
            }
        })
    }

    #onMouseMove = e => {
        // get position relative to canvas
        const rect = this.#canvas.getBoundingClientRect();
        this.#mouseX = e.clientX - rect.left;
        this.#mouseY = e.clientY - rect.top;
    }

    /**
     * Sets a `param` (predefined struct already in all shaders)
     * as uniform to send to all shaders.
     * A Uniform is a value that can only be changed
     * from the outside (js side, not the wgsl side),
     * and unless changed it remains consistent.
     * @param {string} name name of the Param, you can invoke it later in shaders as `Params.[name]`
     * @param {Number|Boolean|Array&lt;Number>} value Single number or a list of numbers. Boolean is converted to Number.
     * @param {string} structName type as `f32` or a custom struct. Default `f32`.
     * @return {Object}
     *
     * @example
     * // js
     *  points.setUniform('color0', options.color0, 'vec3f');
     *  points.setUniform('color1', options.color1, 'vec3f');
     *  points.setUniform('scale', options.scale, 'f32');
     *
     * // wgsl string
     * let color0 = vec4(params.color0/255, 1.);
     * let color1 = vec4(params.color1/255, 1.);
     * let finalColor:vec4f = mix(color0, color1, params.scale);
     */
    setUniform(name, value, structName = null) {
        const uniformToUpdate = this.#nameExists(this.#uniforms, name);
        if (uniformToUpdate &amp;&amp; structName) {
            // if name exists is an update
            console.warn(`setUniform(${name}, [${value}], ${structName}) can't set the structName of an already defined uniform.`);
        }
        if (uniformToUpdate) {
            uniformToUpdate.value = value;
            return uniformToUpdate;
        }
        if (structName &amp;&amp; isArray(structName)) {
            throw `${structName} is an array, which is currently not supported for Uniforms.`;
        }
        const uniform = {
            name: name,
            value: value,
            type: structName,
            size: null
        }
        Object.seal(uniform);
        this.#uniforms.push(uniform);
        return uniform;
    }

    #setMeshUniform(name, value, structName = null) {
        const uniformToUpdate = this.#nameExists(this.#meshUniforms, name);
        if (uniformToUpdate &amp;&amp; structName) {
            // if name exists is an update
            console.warn(`#setMeshUniform(${name}, [${value}], ${structName}) can't set the structName of an already defined uniform.`);
        }
        if (uniformToUpdate) {
            uniformToUpdate.value = value;
            return uniformToUpdate;
        }
        if (structName &amp;&amp; isArray(structName)) {
            throw `${structName} is an array, which is currently not supported for Uniforms.`;
        }
        const uniform = {
            name: name,
            value: value,
            type: structName,
            size: null
        }
        Object.seal(uniform);
        this.#meshUniforms.push(uniform);
        return uniform;
    }

    #setCameraUniform(name, value, structName = null) {
        const uniformToUpdate = this.#nameExists(this.#cameraUniforms, name);
        if (uniformToUpdate &amp;&amp; structName) {
            // if name exists is an update
            // console.warn(`#setCameraUniform(${name}, [${value}], ${structName}) can't set the structName of an already defined uniform.`);
        }
        if (uniformToUpdate) {
            uniformToUpdate.value = value;
            return uniformToUpdate;
        }
        if (structName &amp;&amp; isArray(structName)) {
            throw `${structName} is an array, which is currently not supported for Uniforms.`;
        }
        const uniform = {
            name: name,
            value: value,
            type: structName,
            size: null
        }
        Object.seal(uniform);
        this.#cameraUniforms.push(uniform);
        return uniform;
    }

    /**
     * Updates a list of uniforms
     * @param {Array&lt;{name:String, value:Number}>} arr object array of the type: `{name, value}`
     */
    updateUniforms(arr) {
        arr.forEach(uniform => {
            const variable = this.#uniforms.find(v => v.name === uniform.name);
            if (!variable) {
                throw '`updateUniform()` can\'t be called without first `setUniform()`.';
            }
            variable.value = uniform.value;
        })
    }

    /**
     * Create a WGSL `const` initialized from JS.
     * Useful to set a value you can't initialize in WGSL because you don't have
     * the value yet.
     * The constant will be ready to use on the WGSL shder string.
     * @param {String} name
     * @param {string|Number} value
     * @param {String} structName
     * @returns {Object}
     *
     * @example
     *
     * // js side
     * points.setConstant('NUMPARTICLES', 64, 'f32')
     *
     * // wgsl string
     * // this should print `NUMPARTICLES` and be ready to use.
     * const NUMPARTICLES:f32 = 64; // this will be hidden to the developer
     *
     * // your code:
     * const particles = array&lt;Particle, NUMPARTICLES>();
     */
    setConstant(name, value, structName) {
        const constantToUpdate = this.#nameExists(this.#constants, name);

        if (constantToUpdate) {
            // if name exists is an update
            throw '`setConstant()` can\'t update a const after it has been set.';
        }

        const constant = {
            name,
            value,
            structName,
        }

        this.#constants.push(constant);

        return constant;
    }

    /**
     * Creates a persistent memory buffer across every frame call. See [GPUBuffer](https://www.w3.org/TR/webgpu/#gpubuffer)
     * &lt;br>
     * Meaning it can be updated in the shaders across the execution of every frame.
     * &lt;br>
     * It can have almost any type, like `f32` or `vec2f` or even array&lt;f32>.
     * @param {string} name Name that the Storage will have in the shader
     * @param {string} structName Name of the struct already existing on the
     * shader. This will be the type of the Storage.
     * @param {boolean} read if this is going to be used to read data back
     * @param {GPUShaderStage} shaderType this tells to what shader the storage is bound
     * @returns {Object}
     *
     * @example
     * // js
     * points.setStorage('result', 'f32');
     *
     * // wgsl string
     * result[index]  = 128.;
     *
     * @example
     * // js
     * points.setStorage('colors', 'array&lt;vec3f, 6>');
     *
     * // wgsl string
     * colors[index] = vec3f(248, 208, 146) / 255;
     */
    setStorage(name, structName, read, shaderType = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, arrayData = null) {
        if (this.#nameExists(this.#storage, name)) {
            throw `\`setStorage()\` You have already defined \`${name}\``;
        }
        const storage = {
            mapped: !!arrayData,
            name,
            structName,
            // structSize: null,
            shaderType,
            read,
            buffer: null,
            internal: false
        }
        this.#storage.push(storage);
        return storage;
    }

    /**
     * Creates a persistent memory buffer across every frame call that can be updated.
     * See [GPUBuffer](https://www.w3.org/TR/webgpu/#gpubuffer)
     * &lt;br>
     * Meaning it can be updated in the shaders across the execution of every frame.
     * &lt;br>
     * It can have almost any type, like `f32` or `vec2f` or even array&lt;f32>.
     * &lt;br>
     * The difference with {@link Points#setStorage|setStorage} is that this can be initialized
     * with data.
     * @param {string} name Name that the Storage will have in the shader.
     * @param {Uint8Array&lt;ArrayBuffer>|Array&lt;Number>|Number} arrayData array with the data that must match the struct.
     * @param {string} structName Name of the struct already existing on the
     * shader. This will be the type of the Storage.
     * @param {boolean} read if this is going to be used to read data back.
     * @param {GPUShaderStage} shaderType this tells to what shader the storage is bound
     *
     * @example
     * // js examples/data1
     * const firstMatrix = [
     *     2, 4 , // 2 rows 4 columns
     *     1, 2, 3, 4,
     *     5, 6, 7, 8
     * ];
     * const secondMatrix = [
     *     4, 2, // 4 rows 2 columns
     *     1, 2,
     *     3, 4,
     *     5, 6,
     *     7, 8
     * ];
     *
     * // Matrix should exist as a struct in the wgsl shader
     * points.setStorageMap('firstMatrix', firstMatrix, 'Matrix');
     * points.setStorageMap('secondMatrix', secondMatrix, 'Matrix');
     * points.setStorage('resultMatrix', 'Matrix', true); // this reads data back
     *
     * // wgsl string
     * struct Matrix {
     *     size : vec2f,
     *     numbers: array&lt;f32>,
     * }
     *
     * resultMatrix.size = vec2(firstMatrix.size.x, secondMatrix.size.y);
     */
    setStorageMap(name, arrayData, structName, read = false, shaderType = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE) {
        const storageToUpdate = this.#nameExists(this.#storage, name);

        if (!Array.isArray(arrayData) &amp;&amp; arrayData.constructor !== Uint8Array) {
            arrayData = new Uint8Array([arrayData]);
        }

        if (storageToUpdate) {
            storageToUpdate.array = arrayData;
            storageToUpdate.updated = true;
            return storageToUpdate;
        }
        // TODO document the stream feature
        /**
         * `updated` is set to true in data updates, but this is not true in
         * something like audio, where the data streams and needs to be updated
         * constantly, so if the storage map needs to be updated constantly then
         * `stream` needs to be set to true.
         */
        const storage = {
            stream: false, // permanently updated as true
            updated: true,
            mapped: true,
            name,
            structName,
            shaderType,
            array: arrayData,
            buffer: null,
            read,
            internal: false
        }
        this.#storage.push(storage);
        return storage;
    }
    async readStorage(name) {
        let storageItem = this.#readStorage.find(storageItem => storageItem.name === name);
        let arrayBuffer = null;
        let arrayBufferCopy = null;
        if (storageItem) {
            await storageItem.buffer.mapAsync(GPUMapMode.READ);
            arrayBuffer = storageItem.buffer.getMappedRange();
            arrayBufferCopy = new Float32Array(arrayBuffer.slice(0));
            storageItem.buffer.unmap();
        }
        return arrayBufferCopy;
    }

    /**
     * Layers of data made of `vec4f`.
     * This creates a storage array named `layers` of the size
     * of the screen in pixels;
     * @param {Number} numLayers
     * @param {GPUShaderStage} shaderType
     *
     * @example
     * // js
     * points.setLayers(2);
     *
     * // wgsl string
     * var point = textureLoad(image, vec2&lt;i32>(ix,iy), 0);
     * layers[0][pointIndex] = point;
     * layers[1][pointIndex] = point;
     */
    setLayers(numLayers, shaderType) {
        // TODO: check what data to return
        // TODO: improve jsdoc because the array definition is confusing
        for (let layerIndex = 0; layerIndex &lt; numLayers; layerIndex++) {
            this.#layers.shaderType = shaderType;
            this.#layers.push({
                name: `layer${layerIndex}`,
                size: this.#canvas.width * this.#canvas.height,
                structName: 'vec4f',
                structSize: 16,
                array: null,
                buffer: null
            });
        }
    }

    #nameExists(arrayOfObjects, name) {
        return arrayOfObjects.find(obj => obj.name == name);
    }

    /**
     * Creates a `sampler` to be sent to the shaders. Internally it will be a {@link GPUSampler}
     * @param {string} name Name of the `sampler` to be called in the shaders.
     * @param {GPUSamplerDescriptor} descriptor `Object` with properties that affect the image. See example below.
     * @returns {Object}
     *
     * @example
     * // js
     * const descriptor = {
     *  addressModeU: 'repeat',
     *  addressModeV: 'repeat',
     *  magFilter: 'nearest',
     *  minFilter: 'nearest',
     *  mipmapFilter: 'nearest',
     *  //maxAnisotropy: 10,
     * }
     *
     * points.setSampler('imageSampler', descriptor);
     *
     * // wgsl string
     * let value = texturePosition(image, imageSampler, position, uvr, true);
     */

    setSampler(name, descriptor, shaderType) {
        if ('sampler' == name) {
            throw 'setSampler: `name` can not be sampler since is a WebGPU keyword.';
        }
        const exists = this.#nameExists(this.#samplers, name)
        if (exists) {
            console.warn(`setSampler: \`${name}\` already exists.`);
            return exists;
        }
        // Create a sampler with linear filtering for smooth interpolation.
        descriptor = descriptor || {
            addressModeU: 'clamp-to-edge',
            addressModeV: 'clamp-to-edge',
            magFilter: 'linear',
            minFilter: 'linear',
            mipmapFilter: 'linear',
            //maxAnisotropy: 10,
        };
        const sampler = {
            name: name,
            descriptor: descriptor,
            shaderType: shaderType,
            resource: null,
            internal: false
        };
        this.#samplers.push(sampler);
        return sampler;
    }

    /**
     * Creates a `texture_2d` in the shaders.&lt;br>
     * Used to write data and then print to screen.&lt;br>
     * It can also be used for write the current render pass (what you see on the screen)
     * to this texture, to be used in the next cycle of this render pass; meaning
     * you effectively have the previous frame data before printing the next one.
     *
     * @param {String} name Name to call the texture in the shaders.
     * @param {boolean} copyCurrentTexture If you want the fragment output to be copied here.
     * @param {GPUShaderStage} shaderType To what {@link GPUShaderStage} you want to exclusively use this variable.
     * @param {Number} renderPassIndex If using `copyCurrentTexture`
     * this tells which RenderPass it should get the data from. If not set then it will grab the last pass.
     * @returns {Object}
     *
     * @example
     * // js
     * points.setTexture2d('feedbackTexture', true);
     *
     * // wgsl string
     * var rgba = textureSampleLevel(
     *     feedbackTexture, feedbackSampler,
     *     vec2f(f32(GlobalId.x), f32(GlobalId.y)),
     *     0.0
     * );
     *
     */
    setTexture2d(name, copyCurrentTexture, shaderType, renderPassIndex) {
        const exists = this.#nameExists(this.#textures2d, name);
        if (exists) {
            console.warn(`setTexture2d: \`${name}\` already exists.`);
            return exists;
        }
        const texture2d = {
            name,
            copyCurrentTexture,
            shaderType,
            texture: null,
            renderPassIndex,
            internal: false
        }
        this.#textures2d.push(texture2d);
        return texture2d;
    }

    /**
     * Creates a depth map from the selected `renderPassIndex`
     * @param {String} name
     * @param {GPUShaderStage} shaderType
     * @param {Number} renderPassIndex
     * @returns
     */
    setTextureDepth2d(name, shaderType, renderPassIndex) {
        const exists = this.#nameExists(this.#texturesDepth2d, name);
        if (exists) {
            console.warn(`setTextureDepth2d: \`${name}\` already exists.`);
            return exists;
        }
        renderPassIndex ||= 0;
        const textureDepth2d = {
            name,
            shaderType,
            texture: null,
            renderPassIndex,
            internal: false,
        }
        this.#texturesDepth2d.push(textureDepth2d);
        return textureDepth2d;
    }

    copyTexture(nameTextureA, nameTextureB) {
        const texture2d_A = this.#nameExists(this.#textures2d, nameTextureA);
        const texture2d_B = this.#nameExists(this.#textures2d, nameTextureB);
        if (!(texture2d_A &amp;&amp; texture2d_B)) {
            console.error('One of the textures does not exist.');
        }
        const a = texture2d_A.texture;
        const cubeTexture = this.#device.createTexture({
            label: '_cubeTexture',
            size: [a.width, a.height, 1],
            format: 'rgba8unorm',
            usage:
                GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT,
        });
        texture2d_B.texture = cubeTexture;
        this.#texturesToCopy.push({ a, b: texture2d_B.texture });
    }

    /**
     * Loads an image as `texture_2d` and then it will be available to read
     * data from in the shaders.&lt;br>
     * Supports web formats like JPG, PNG.
     * @param {string} name identifier it will have in the shaders
     * @param {string} path image address in a web server
     * @param {GPUShaderStage} shaderType in what shader type it will exist only
     * @returns {Object}
     *
     * @example
     * // js
     * await points.setTextureImage('image', './../myimage.jpg');
     *
     * // wgsl string
     * let rgba = texturePosition(image, imageSampler, position, uvr, true);
     */
    async setTextureImage(name, path, shaderType = null) {
        const texture2dToUpdate = this.#nameExists(this.#textures2d, name);
        const response = await fetch(path);
        const blob = await response.blob();
        const imageBitmap = await createImageBitmap(blob);
        if (texture2dToUpdate) {
            if (shaderType) {
                throw '`setTextureImage()` the param `shaderType` should not be updated after its creation.';
            }
            this.#textureUpdated = true;
            texture2dToUpdate.imageTexture.bitmap = imageBitmap;
            const cubeTexture = this.#device.createTexture({
                label: '_cubeTexture setTextureImage',
                size: [imageBitmap.width, imageBitmap.height, 1],
                format: 'rgba8unorm',
                usage:
                    GPUTextureUsage.TEXTURE_BINDING |
                    GPUTextureUsage.COPY_SRC |
                    GPUTextureUsage.COPY_DST |
                    GPUTextureUsage.RENDER_ATTACHMENT,
            });
            this.#device.queue.copyExternalImageToTexture(
                { source: imageBitmap },
                { texture: cubeTexture },
                [imageBitmap.width, imageBitmap.height]
            );
            texture2dToUpdate.texture = cubeTexture;
            return texture2dToUpdate;
        }
        const texture2d = {
            name: name,
            copyCurrentTexture: false,
            shaderType: shaderType,
            texture: null,
            renderPassIndex: null,
            imageTexture: {
                bitmap: imageBitmap
            },
            internal: false
        }
        this.#textures2d.push(texture2d);
        return texture2d;
    }

    /**
     * Loads a text string as a texture.&lt;br>
     * Using an Atlas or a Spritesheet with UTF-16 chars (`path`) it will create a new texture
     * that contains only the `text` characters.&lt;br>
     * Characters in the atlas `path` must be in order of the UTF-16 chars.&lt;br>
     * It can have missing characters at the end or at the start, so the `offset` is added to take account for those chars.&lt;br>
     * For example, `A` is 65, but if one character is removed before the letter `A`, then offset is `-1`
     * @param {String} name id of the wgsl variable in the shader
     * @param {String} text text you want to load as texture
     * @param {String} path atlas to grab characters from, image address in a web server
     * @param {{x: number, y: number}} size size of a individual character e.g.: `{x:10, y:20}`
     * @param {Number} offset how many characters back or forward it must move to start
     * @param {GPUShaderStage} shaderType To what {@link GPUShaderStage} you want to exclusively use this variable.
     * @returns {Object}
     *
     * @example
     * // js
     * await points.setTextureString(
     *     'textImg',
     *     'Custom Text',
     *     './../img/inconsolata_regular_8x22.png',
     *     size,
     *     -32
     * );
     *
     * // wgsl string
     * let textColors = texturePosition(textImg, imageSampler, position, uvr, true);
     *
     */
    async setTextureString(name, text, path, size, offset = 0, shaderType = null) {
        const atlas = await loadImage(path);
        const textImg = strToImage(text, atlas, size, offset);
        return this.setTextureImage(name, textImg, shaderType);
    }

    /**
     * Load images as texture_2d_array
     * @param {string} name id of the wgsl variable in the shader
     * @param {Array} paths image addresses in a web server
     * @param {GPUShaderStage} shaderType
     */
    // TODO: verify if this can be updated after creation
    // TODO: return texture2dArray object
    async setTextureImageArray(name, paths, shaderType) {
        if (this.#nameExists(this.#textures2dArray, name)) {
            // TODO: throw exception here
            return;
        }
        const imageBitmaps = [];
        for await (const path of paths) {
            const response = await fetch(path);
            const blob = await response.blob();
            imageBitmaps.push(await createImageBitmap(blob));
        }

        const texture2dArrayItem = {
            name: name,
            copyCurrentTexture: false,
            shaderType: shaderType,
            texture: null,
            imageTextures: {
                bitmaps: imageBitmaps
            },
            internal: false
        }

        this.#textures2dArray.push(texture2dArrayItem);
        return texture2dArrayItem;
    }

    /**
     * Loads a video as `texture_external`and then
     * it will be available to read data from in the shaders.
     * Supports web formats like mp4 and webm.
     * @param {string} name id of the wgsl variable in the shader
     * @param {string} path video address in a web server
     * @param {GPUShaderStage} shaderType
     * @returns {Object}
     *
     * @example
     * // js
     * await points.setTextureVideo('video', './../myvideo.mp4');
     *
     * // wgsl string
     * let rgba = textureExternalPosition(video, imageSampler, position, uvr, true);
     */
    async setTextureVideo(name, path, shaderType) {
        if (this.#nameExists(this.#texturesExternal, name)) {
            throw `setTextureVideo: ${name} already exists.`;
        }
        const video = document.createElement('video');
        video.loop = true;
        video.autoplay = true;
        video.muted = true;
        video.src = new URL(path, import.meta.url).toString();
        await video.play();
        const textureExternal = {
            name: name,
            shaderType: shaderType,
            video: video,
            internal: false
        };
        this.#texturesExternal.push(textureExternal);
        return textureExternal;
    }

    /**
     * Loads webcam as `texture_external`and then
     * it will be available to read data from in the shaders.
     * @param {String} name id of the wgsl variable in the shader
     * @param {{width:Number, height:Number}} size to crop the video. WebGPU might throw an error if size does not match.
     * @param {GPUShaderStage} shaderType
     * @returns {Object}
     * @throws a WGSL error if the size doesn't match possible crop size
     * @example
     * // js
     * await points.setTextureWebcam('video');
     *
     * // wgsl string
     * et rgba = textureExternalPosition(video, imageSampler, position, uvr, true);
     */
    async setTextureWebcam(name, size = { width: 1080, height: 1080 }, shaderType) {
        if (this.#nameExists(this.#texturesExternal, name)) {
            throw `setTextureWebcam: ${name} already exists.`;
        }
        const video = document.createElement('video');
        video.muted = true;
        if (navigator.mediaDevices.getUserMedia) {
            await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: size.width }, height: { ideal: size.height } } })
                .then(async stream => {
                    video.srcObject = stream;
                    await video.play();
                })
                .catch(err => { throw err });
        }
        const textureExternal = {
            name,
            shaderType,
            video,
            size,
            internal: false
        };
        this.#texturesExternal.push(textureExternal);

        return await new Promise(resolve => resolve(textureExternal));
    }

    /**
     * Assigns an audio FrequencyData to a StorageMap.&lt;br>
     * Calling setAudio creates a Storage with `name` in the wgsl shaders.&lt;br>
     * From this storage you can read the audio data sent to the shader as numeric values.&lt;br>
     * Values in `audio.data` are composed of integers on a scale from 0..255
     * @param {string} name name of the Storage and prefix of the length variable e.g. `[name]Length`.
     * @param {string} path audio file address in a web server
     * @param {Number} volume
     * @param {boolean} loop
     * @param {boolean} autoplay
     * @returns {HTMLAudioElement}
     * @example
     * // js
     * const audio = points.setAudio('audio', 'audiofile.ogg', volume, loop, autoplay);
     *
     * // wgsl
     * let audioX = audio.data[ u32(uvr.x * params.audioLength)] / 256;
     */
    setAudio(name, path, volume, loop, autoplay) {
        const audio = new Audio(path);
        audio.volume = volume;
        audio.autoplay = autoplay;
        audio.loop = loop;
        const sound = {
            name: name,
            path: path,
            audio: audio,
            analyser: null,
            data: null
        }
        // this.#audio.play();
        // audio
        const audioContext = new AudioContext();
        const resume = _ => { audioContext.resume() }
        if (audioContext.state === 'suspended') {
            document.body.addEventListener('touchend', resume, false);
            document.body.addEventListener('click', resume, false);
        }
        const source = audioContext.createMediaElementSource(audio);
        // // audioContext.createMediaStreamSource()
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(analyser);
        analyser.connect(audioContext.destination);
        const bufferLength = analyser.fftSize;//analyser.frequencyBinCount;
        // const bufferLength = analyser.frequencyBinCount;
        const data = new Uint8Array(bufferLength);
        // analyser.getByteTimeDomainData(data);
        analyser.getByteFrequencyData(data);
        // storage that will have the data on WGSL
        this.setStorageMap(name, data,
            // `array&lt;f32, ${bufferLength}>`
            'Sound' // custom struct in defaultStructs.js
        ).stream = true;
        // uniform that will have the data length as a quick reference
        this.setUniform(`${name}Length`, analyser.frequencyBinCount);
        sound.analyser = analyser;
        sound.data = data;
        this.#sounds.push(sound);
        return audio;
    }


    // TODO: verify this method
    setTextureStorage2d(name, shaderType) {
        if (this.#nameExists(this.#texturesStorage2d, name)) {
            throw `setTextureStorage2d: ${name} already exists.`
        }
        const texturesStorage2d = {
            name: name,
            shaderType: shaderType,
            texture: null,
            internal: false
        };
        this.#texturesStorage2d.push(texturesStorage2d);
        return texturesStorage2d;
    }

    /**
     * Special texture where data can be written to it in the Compute Shader and
     * read from in the Fragment Shader OR from a {@link RenderPass} to another.
     * If you use writeIndex and readIndex it will share data between `RenderPasse`s
     * Is a one way communication method.
     * Ideal to store data to it in the Compute Shader and later visualize it in
     * the Fragment Shader.
     * @param {string} writeName name of the variable in the compute shader
     * @param {string} readName name of the variable in the fragment shader
     * @param {number} writeIndex RenderPass allowed to write into `outputTex`
     * @param {number} readIndex RenderPass allowed to read from `computeTexture`
     * @param {Array&lt;number, 2>} size dimensions of the texture, by default screen
     * size
     * @returns {Object}
     *
     * @example
     *
     * // js
     * points.setBindingTexture('outputTex', 'computeTexture');
     *
     * // wgsl string
     * //// compute
     * textureStore(outputTex, GlobalId.xy, rgba);
     * //// fragment
     * let value = texturePosition(computeTexture, imageSampler, position, uv, false);
     */
    setBindingTexture(writeName, readName, writeIndex, readIndex, size) {
        if ((Number.isInteger(writeIndex) &amp;&amp; !Number.isInteger(readIndex)) || (!Number.isInteger(writeIndex) &amp;&amp; Number.isInteger(readIndex))) {
            throw 'The parameters writeIndex and readIndex must both be declared.';
        }
        const usesRenderPass = Number.isInteger(writeIndex) &amp;&amp; Number.isInteger(readIndex);
        // TODO: validate that names don't exist already
        const bindingTexture = {
            write: {
                name: writeName,
                shaderType: GPUShaderStage.COMPUTE,
                renderPassIndex: writeIndex
            },
            read: {
                name: readName,
                shaderType: GPUShaderStage.FRAGMENT,
                renderPassIndex: readIndex
            },
            texture: null,
            size: size,
            usesRenderPass,
            internal: false
        }
        this.#bindingTextures.push(bindingTexture);
        return bindingTexture;
    }

    /**
     * Creates a Perspective camera with a given name to be used in the shaders.
     * The name is used as identifier in the shaders for the Projection and View matrices.
     *
     * The name will be inside the `camera` uniform and composed with the
     * projection and view identifiers: e.g.:
     * name: mycamera
     * uniform buffers:
     *  camera.mycamera_projection;
     *  camera.mycamera_view
     *
     * The camera must be called on the update method so the aspect is updated by default
     * with the canvas width and height.
     * @param {String} name camera name in the shader for the projection and view
     * @param {vec3f} position
     * @param {Number} fov field of view angle
     * @param {Number} near clipping near
     * @param {Number} far clipping far
     * @param {Number} aspect ratio of the camera, by default it choses the canvas aspect ratio
     *
     * @example
     * // js
     *  points.setCameraPerspective('camera', [0, 0, -5]);
     *
     * // wgsl string
     * let clip = camera.camera_projection * camera.camera_view * vec4f(world, 1.);
     */
    setCameraPerspective(name, position = [0, 0, -5], lookAt = [0, 0, 0], fov = 45, near = .1, far = 100, aspect = null) {
        const fov_radians = fov * (Math.PI / 180);
        const f = 1.0 / Math.tan(fov_radians / 2); // â‰ˆ 2.414
        const nf = 1 / (near - far);
        aspect ??= this.#canvas.width / this.#canvas.height;

        const perspectiveMatrix = [
            f / aspect, 0, 0, 0,
            0, f, 0, 0,
            0, 0, (far + near) * nf, -1,
            0, 0, (2 * far * near) * nf, 0
        ]

        this.#setCameraUniform(
            `${name}_projection`,
            perspectiveMatrix,
            'mat4x4&lt;f32>'
        );

        const up = [0, 1, 0];
        const ff = normalize(sub(lookAt, position));
        const r = normalize(cross(ff, up));
        const u = cross(r, ff);

        const viewMatrix = [
            r[0], u[0], -ff[0], 0,
            r[1], u[1], -ff[1], 0,
            r[2], u[2], -ff[2], 0,
            -dot(r, position), -dot(u, position), dot(ff, position), 1
        ]

        this.#setCameraUniform(`${name}_view`, viewMatrix, 'mat4x4&lt;f32>');
    }

    /**
     * Creates an Orthographic camera with a given name to be used in the shaders.
     * The name is used as identifier in the shaders for the Projection matrix.
     *
     * The name will be inside the `camera` uniform and composed with the
     * projection identifier: e.g.:
     * name: mycamera
     * uniform buffer:
     *  camera.mycamera_projection;
     *
     * @param {String} name
     * @param {Number} left
     * @param {Number} right
     * @param {Number} top
     * @param {Number} bottom
     * @param {Number} near
     * @param {Number} far
     *
     * @example
     * // js
     * points.setCameraOrthographic('camera');
     *
     * // wgsl string
     * let clip = camera.camera_projection * vec4f(world, 0.0, 1.0);
     *
     */
    setCameraOrthographic(name, left = -1, right = 1, top = 1, bottom = -1, near = -1, far = 1, position = [0, 0, -5], lookAt = [0, 0, 0]) {
        // const aspect = canvas.width / canvas.height; // alternative to aspect in shader

        const lr = 1 / (right - left);
        const bt = 1 / (top - bottom);
        const nf = 1 / (near - far);

        const orthoMatrix = [
            2 * lr, 0, 0, 0,
            0, 2 * bt, 0, 0,
            0, 0, nf, 0,
            -(right + left) * lr,
            -(top + bottom) * bt,
            near * nf,
            1
        ];

        this.#setCameraUniform(`${name}_projection`, orthoMatrix, 'mat4x4&lt;f32>');


        const up = [0, 1, 0];
        const ff = normalize(sub(lookAt, position));
        const r = normalize(cross(ff, up));
        const u = cross(r, ff);

        const viewMatrix = [
            r[0], u[0], -ff[0], 0,
            r[1], u[1], -ff[1], 0,
            r[2], u[2], -ff[2], 0,
            -dot(r, position), -dot(u, position), dot(ff, position), 1
        ]

        this.#setCameraUniform(`${name}_view`, viewMatrix, 'mat4x4&lt;f32>');
    }

    /**
     * Listens for an event dispatched from WGSL code
     * @param {String} name Number that represents an event Id
     * @param {Function} callback function to be called when the event occurs
     * @param {Number} structSize size of the array data to be returned
     *
     * @example
     * // js
     * // the event name will be reflected as a variable name in the shader
     * // and a data variable that starts with the name
     * points.addEventListener('click_event', data => {
     *     // response action in JS
     *      const [a, b, c, d] = data;
     *      console.log({a, b, c, d});
     * }, 4); // data will have 4 items
     *
     * // wgsl string
     *  if(params.mouseClick == 1.){
     *      // we update our event response data with something we need
     *      // on the js side
     *      // click_event_data has 4 items to fill
     *      click_event_data[0] = params.time;
     *      // Same name of the Event
     *      // we fire the event with a 1
     *      // it will be set to 0 in the next frame
     *      click_event.updated = 1;
     *  }
     *
     */
    addEventListener(name, callback, structSize = 1) {
        // TODO: remove structSize
        // this extra 1 is for the boolean flag in the Event struct
        const data = Array(4).fill(0);
        this.setStorageMap(name, data, 'Event', true, GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT);
        this.setStorage(`${name}_data`, `array&lt;f32, ${structSize}>`, true, GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT);
        this.#events.set(this.#events_ids,
            {
                id: this.#events_ids,
                name,
                callback,
            }
        );
        ++this.#events_ids;
    }

    /**
     * @param {GPUShaderStage} shaderType
     * @param {RenderPass} renderPass
     * @returns {String} string with bindings
     */
    #createDynamicGroupBindings(shaderType, { index: renderPassIndex, internal }, groupId = 0) {
        if (!shaderType) {
            throw '`GPUShaderStage` is required';
        }
        // const groupId = 0;
        let dynamicGroupBindings = '';
        let bindingIndex = 0;
        if (this.#uniforms.length) {
            dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var &lt;uniform> params: Params;\n`;
            bindingIndex += 1;
        }
        if (this.#meshUniforms.length) {
            dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var &lt;uniform> mesh: Mesh;\n`;
            bindingIndex += 1;
        }
        if (this.#cameraUniforms.length) {
            dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var &lt;uniform> camera: Camera;\n`;
            bindingIndex += 1;
        }
        this.#storage.forEach(storageItem => {
            const isInternal = internal === storageItem.internal;
            if (isInternal &amp;&amp; (!storageItem.shaderType || storageItem.shaderType &amp; shaderType)) {
                const T = storageItem.structName;

                // note:
                // shaderType means: this is the current GPUShaderStage we are at
                // and storageItem.shaderType is the stage required by the buffer in setStorage

                let accessMode = getStorageAccessMode(shaderType, storageItem.shaderType);
                accessMode = bindingModes[accessMode];

                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var &lt;storage, ${accessMode}> ${storageItem.name}: ${T};\n`
                bindingIndex += 1;
            }
        });
        if (this.#layers.length) {
            if (!this.#layers.shaderType || this.#layers.shaderType &amp; shaderType) {
                let totalSize = 0;
                this.#layers.forEach(layerItem => totalSize += layerItem.size);
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var &lt;storage, read_write> layers: array&lt;array&lt;vec4f, ${totalSize}>>;\n`
                bindingIndex += 1;
            }
        }
        this.#samplers.forEach(sampler => {
            const isInternal = internal === sampler.internal;
            if (isInternal &amp;&amp; (!sampler.shaderType || sampler.shaderType &amp; shaderType)) {
                const T = sampler.descriptor.compare ? 'sampler_comparison' : 'sampler';
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${sampler.name}: ${T};\n`;
                bindingIndex += 1;
            }
        });
        this.#texturesStorage2d.forEach(texture => {
            const isInternal = internal === texture.internal;
            if (isInternal &amp;&amp; (!texture.shaderType || texture.shaderType &amp; shaderType)) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_storage_2d&lt;rgba8unorm, write>;\n`;
                bindingIndex += 1;
            }
        });
        this.#textures2d.forEach(texture => {
            const isInternal = internal === texture.internal;
            if (isInternal &amp;&amp; (!texture.shaderType || texture.shaderType &amp; shaderType)) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_2d&lt;f32>;\n`;
                bindingIndex += 1;
            }
        });
        this.#texturesDepth2d.forEach(texture => {
            const isInternal = internal === texture.internal;
            if (isInternal &amp;&amp; (!texture.shaderType || texture.shaderType &amp; shaderType)) {
                if (texture.renderPassIndex !== renderPassIndex) {
                    dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_depth_2d;\n`;
                    bindingIndex += 1;
                }
            }
        });
        this.#textures2dArray.forEach(texture => {
            const isInternal = internal === texture.internal;
            if (isInternal &amp;&amp; (!texture.shaderType || texture.shaderType &amp; shaderType)) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_2d_array&lt;f32>;\n`;
                bindingIndex += 1;
            }
        });
        this.#texturesExternal.forEach(externalTexture => {
            const isInternal = internal === externalTexture.internal;
            if (isInternal &amp;&amp; (!externalTexture.shaderType || externalTexture.shaderType &amp; shaderType)) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${externalTexture.name}: texture_external;\n`;
                bindingIndex += 1;
            }
        });
        this.#bindingTextures.forEach(bindingTexture => {
            const { usesRenderPass } = bindingTexture;
            if (usesRenderPass) {
                if (GPUShaderStage.VERTEX === shaderType) { // to avoid binding texture in vertex
                    return;
                }
                if (renderPassIndex === bindingTexture.write.renderPassIndex) {
                    dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.write.name}: texture_storage_2d&lt;rgba8unorm, write>;\n`;
                    bindingIndex += 1;
                }
                if (renderPassIndex === bindingTexture.read.renderPassIndex) {
                    dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.read.name}: texture_2d&lt;f32>;\n`;
                    bindingIndex += 1;
                }

                return;
            }

            const isInternal = internal === bindingTexture.internal;
            if (isInternal &amp;&amp; (bindingTexture.write.shaderType &amp; shaderType)) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.write.name}: texture_storage_2d&lt;rgba8unorm, write>;\n`;
                bindingIndex += 1;
            }
            if (isInternal &amp;&amp; (bindingTexture.read.shaderType &amp; shaderType)) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.read.name}: texture_2d&lt;f32>;\n`;
                bindingIndex += 1;
            }
        });
        return dynamicGroupBindings;
    }

    #createDynamicGroupBindingsUpdate(shaderType, { index: renderPassIndex, internal }, groupId = 0) {
        if (!shaderType) {
            throw '`GPUShaderStage` is required';
        }
        // const groupId = 0;
        let dynamicGroupBindings = '';
        let bindingIndex = 0;

        this.#texturesExternal.forEach(externalTexture => {
            const isInternal = internal === externalTexture.internal;
            if (isInternal &amp;&amp; (!externalTexture.shaderType || externalTexture.shaderType &amp; shaderType)) {
                dynamicGroupBindings += /*wgsl*/`@group(${groupId}) @binding(${bindingIndex}) var ${externalTexture.name}: texture_external;\n`;
                bindingIndex += 1;
            }
        });

        return dynamicGroupBindings;

    }

    /**
     * Establishes the density of the base mesh, by default 1x1, meaning two triangles.
     * The final number of triangles is `numColumns` * `numRows` * `2` ( 2 being the triangles )
     * @param {Number} numColumns quads horizontally
     * @param {Number} numRows quads vertically
     *
     * @example
     * // js
     * points.setMeshDensity(20,20);
     *
     * // wgsl string
     * //// vertex shader
     * var modifiedPosition = position;
     * modifiedPosition.w = modifiedPosition.w + sin(f32(vertexIndex) * (params.time) * .01) * .1;
     *
     * return defaultVertexBody(modifiedPosition, color, uv);
     */
    setMeshDensity(numColumns, numRows) {
        if (numColumns == 0 || numRows == 0) {
            throw 'Parameters should be greater than 0';
        }
        this.#numColumns = numColumns;
        this.#numRows = numRows;
    }

    /**
     *
     * @param {RenderPass} renderPass
     * @param {Number} index
     */
    #compileRenderPass = (renderPass, index) => {
        let vertexShader = renderPass.vertexShader;
        let computeShader = renderPass.computeShader;
        let fragmentShader = renderPass.fragmentShader;
        let colorsVertWGSL = vertexShader;
        let colorsComputeWGSL = computeShader;
        let colorsFragWGSL = fragmentShader;
        let dynamicGroupBindingsVertex = '';
        let dynamicGroupBindingsCompute = '';
        let dynamicGroupBindingsFragment = '';
        let dynamicStructParams = '';
        let dynamicStructMesh = '';
        let dynamicStructCamera = '';
        this.#uniforms.forEach(u => {
            u.type = u.type || 'f32';
            dynamicStructParams += /*wgsl*/`${u.name}:${u.type}, \n\t`;
        });
        if (this.#uniforms.length) {
            dynamicStructParams = /*wgsl*/`struct Params {\n\t${dynamicStructParams}\n}\n`;
        }
        this.#meshUniforms.forEach(u => {
            u.type = u.type || 'f32';
            dynamicStructMesh += /*wgsl*/`${u.name}:${u.type}, \n\t`;
        });
        if (this.#meshUniforms.length) {
            dynamicStructMesh = /*wgsl*/`struct Mesh {\n\t${dynamicStructMesh}\n}\n`;
        }
        this.#cameraUniforms.forEach(u => {
            u.type = u.type || 'f32';
            dynamicStructCamera += /*wgsl*/`${u.name}:${u.type}, \n\t`;
        });
        if (this.#cameraUniforms.length) {
            dynamicStructCamera = /*wgsl*/`struct Camera {\n\t${dynamicStructCamera}\n}\n`;
        }
        this.#constants.forEach(c => {
            dynamicStructParams += /*wgsl*/`const ${c.name}:${c.structName} = ${c.value};\n`;
        })
        dynamicStructParams += dynamicStructMesh;
        dynamicStructParams += dynamicStructCamera;

        renderPass.index = index;
        renderPass.hasVertexShader &amp;&amp; (dynamicGroupBindingsVertex += dynamicStructParams);
        renderPass.hasComputeShader &amp;&amp; (dynamicGroupBindingsCompute += dynamicStructParams);
        renderPass.hasFragmentShader &amp;&amp; (dynamicGroupBindingsFragment += dynamicStructParams);

        renderPass.hasVertexShader &amp;&amp; (dynamicGroupBindingsVertex += this.#createDynamicGroupBindings(GPUShaderStage.VERTEX, renderPass));
        renderPass.hasComputeShader &amp;&amp; (dynamicGroupBindingsCompute += this.#createDynamicGroupBindings(GPUShaderStage.COMPUTE, renderPass));
        dynamicGroupBindingsFragment += this.#createDynamicGroupBindings(GPUShaderStage.FRAGMENT, renderPass, 1);

        // renderPass.hasVertexShader &amp;&amp; (dynamicGroupBindingsVertex += this.#createDynamicGroupBindingsUpdate(GPUShaderStage.VERTEX, renderPass, 2));
        // renderPass.hasComputeShader &amp;&amp; (dynamicGroupBindingsCompute += this.#createDynamicGroupBindingsUpdate(GPUShaderStage.COMPUTE, renderPass, 2));
        // dynamicGroupBindingsFragment += this.#createDynamicGroupBindingsUpdate(GPUShaderStage.FRAGMENT, renderPass, 2);


        renderPass.hasVertexShader &amp;&amp; (colorsVertWGSL = dynamicGroupBindingsVertex + defaultStructs + defaultVertexBody + colorsVertWGSL);
        renderPass.hasComputeShader &amp;&amp; (colorsComputeWGSL = dynamicGroupBindingsCompute + defaultStructs + colorsComputeWGSL);
        renderPass.hasFragmentShader &amp;&amp; (colorsFragWGSL = dynamicGroupBindingsFragment + defaultStructs + colorsFragWGSL);
        console.groupCollapsed(`Render Pass ${index}: (${renderPass.name})`);
        console.groupCollapsed('VERTEX');
        console.log(colorsVertWGSL);
        console.groupEnd();
        if (renderPass.hasComputeShader) {
            console.groupCollapsed('COMPUTE');
            console.log(colorsComputeWGSL);
            console.groupEnd();
        }
        console.groupCollapsed('FRAGMENT');
        console.log(colorsFragWGSL);
        console.groupEnd();
        console.groupEnd();
        renderPass.hasVertexShader &amp;&amp; (renderPass.compiledShaders.vertex = colorsVertWGSL);
        renderPass.hasComputeShader &amp;&amp; (renderPass.compiledShaders.compute = colorsComputeWGSL);
        renderPass.hasFragmentShader &amp;&amp; (renderPass.compiledShaders.fragment = colorsFragWGSL);
    }
    #generateDataSize = () => {
        const allShaders = this.#renderPasses.map(renderPass => {
            const { vertex, compute, fragment } = renderPass.compiledShaders;
            return vertex + compute + fragment;;
        }).join('\n');
        this.#dataSize = dataSize(allShaders);
        // since uniforms are in a sigle struct
        // this is only required for storage
        this.#storage.forEach(s => {
            if (!s.mapped) {
                if (isArray(s.structName)) {
                    const typeData = getArrayTypeData(s.structName, this.#dataSize);
                    s.structSize = typeData.size;
                } else {
                    const d = this.#dataSize.get(s.structName) || typeSizes[s.structName];
                    if (!d) {
                        throw `${s.structName} has not been defined.`
                    }
                    s.structSize = d.bytes || d.size;
                }
            }
        });
    }
    /**
     * One time function call to initialize the shaders.
     * @param {Array&lt;RenderPass>} renderPasses Collection of {@link RenderPass}, which contain Vertex, Compute and Fragment shaders.
     * @returns {Boolean} false | undefined
     *
     * @example
     * await points.init(renderPasses)
     */
    async init(renderPasses) {
        this.#renderPasses = renderPasses.concat(this.#postRenderPasses);
        let hasComputeShaders = this.#renderPasses.some(renderPass => renderPass.hasComputeShader);
        if (!hasComputeShaders &amp;&amp; this.#bindingTextures.length) {
            throw ' `setBindingTexture` requires at least one Compute Shader in a `RenderPass`'
        }

        //
        // let adapter = null;
        if (!this.#adapter) {
            try {
                this.#adapter = await navigator.gpu.requestAdapter();
            } catch (err) {
                console.log(err);
            }
        }
        if (!this.#adapter) { return false; }
        if (!this.#device) {
            this.#device = await this.#adapter.requestDevice();
            this.#device.label = (new Date()).getMilliseconds();
        }

        console.log(this.#device.limits);

        this.#device.lost.then(info => console.log(info));
        if (this.#canvas !== null) this.#context = this.#canvas.getContext('webgpu');
        this.#presentationFormat ||= navigator.gpu.getPreferredCanvasFormat();
        if (this.#canvasId) {
            if (this.#fitWindow) {
                this.#resizeCanvasToFitWindow();
            } else {
                this.#resizeCanvasToDefault();
            }
        }

        // TODO: this should be inside RenderPass, to not call vertexArray outside
        this.#renderPasses.forEach((r, i) => {
            r.init?.(this);
            r.meshes.forEach(mesh => this.#setMeshUniform(mesh.name, mesh.id, 'u32'));

            this.createScreen(r);
            r.vertexBufferInfo = new VertexBufferInfo(r.vertexArray);
            r.vertexBuffer = this.#createAndMapBuffer(r.vertexArray, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);

            this.#compileRenderPass(r, i);
        });

        this.#generateDataSize();
        this.#createBuffers();
        this.#createPipeline();

        return true;
    }

    /**
     * Injects a render pass after all the render passes added by the user.
     * @param {RenderPass} renderPass
     * @param {Object} params
     */
    addRenderPass(renderPass, params) {
        if (this.renderPasses?.length) {
            throw '`addPostRenderPass` should be called prior `Points.init()`';
        }

        renderPass.params = params || {};

        const requiredNotFound = renderPass.required?.filter(i => !renderPass.params[i] &amp;&amp; !Number.isInteger(renderPass.params[i]));

        if (requiredNotFound?.length) {
            const paramsRequired = requiredNotFound.join(', ');
            console.warn(`addRenderPass: (${renderPass.name}) parameters required: ${paramsRequired}`);
        }

        this.#postRenderPasses.push(renderPass);
        renderPass.init(this);
    }

    /**
     * Get the active list of {@link RenderPass}
     */
    get renderPasses() {
        return this.#renderPasses;
    }

    /**
     * Adds two triangles called points per number of columns and rows
     * @ignore
     */
    createScreen(renderPass) {
        if (renderPass.vertexArray.length !== 0) {
            return;
        }
        const hasVertexAndFragmentShader = this.#renderPasses.some(renderPass => renderPass.hasVertexAndFragmentShader)
        if (hasVertexAndFragmentShader) {
            let colors = [
                new RGBAColor(1, 0, 0),
                new RGBAColor(0, 1, 0),
                new RGBAColor(0, 0, 1),
                new RGBAColor(1, 1, 0),
            ];
            for (let xIndex = 0; xIndex &lt; this.#numRows; xIndex++) {
                for (let yIndex = 0; yIndex &lt; this.#numColumns; yIndex++) {
                    const coordinate = new Coordinate(xIndex * this.#canvas.clientWidth / this.#numColumns, yIndex * this.#canvas.clientHeight / this.#numRows, .3);
                    renderPass.addPoint(coordinate, this.#canvas.clientWidth / this.#numColumns, this.#canvas.clientHeight / this.#numRows, colors, this.#canvas);
                }
            }
        }
    }

    /**
     * @param {Float32Array} data
     * @param {GPUBufferUsageFlags} usage
     * @param {Boolean} mappedAtCreation
     * @param {Number} size
     * @returns {GPUBuffer} mapped buffer
     */
    #createAndMapBuffer(data, usage, mappedAtCreation = true, size = null) {
        // the size comes from dataSize
        // but in some cases size is null and we have to use byteLength
        // sometimes both arrive and we have to use the bigger one
        const buffer = this.#device.createBuffer({
            mappedAtCreation,
            size: Math.max(size, data.byteLength),
            usage,
        });
        new Float32Array(buffer.getMappedRange()).set(data);
        buffer.unmap();
        return buffer;
    }

    /**
     * It creates with size, not with data, so it's empty
     * @param {Number} size numItems * instanceByteSize ;
     * @param {GPUBufferUsageFlags} usage
     * @returns {GPUBuffer} buffer
     */
    #createBuffer(size, usage) {
        return this.#device.createBuffer({ size, usage });
    }

    /**
     * To update a buffer instead of recreating it
     * @param {GPUBuffer} buffer
     * @param {Float32Array} values
     */
    #writeBuffer(buffer, values) {
        this.#device.queue.writeBuffer(
            buffer,
            0,
            new Float32Array(values)
        );
    }

    /**
     *
     * @param {Array} uniformsArray
     * @param {String} structName
     * @returns {{values:Float32Array, paramsDataSize:Object}}
     */
    #createUniformValues(uniformsArray, structName = 'Params') {
        const paramsDataSize = this.#dataSize.get(structName)
        const paddings = paramsDataSize.paddings;
        // we check the paddings list and add 0's to just the ones that need it
        const uniformsClone = structuredClone(uniformsArray);
        let arrayValues = uniformsClone.map(v => {
            const padding = paddings[v.name] / 4;
            if (padding) {
                if (v.value.constructor !== Array) {
                    v.value = [v.value];
                }
                for (let i = 0; i &lt; padding; i++) {
                    v.value.push(0);
                }
            }
            return v.value;
        }).flat(1);

        return { values: new Float32Array(arrayValues), paramsDataSize };
    }

    #createParametersUniforms() {
        const { values, paramsDataSize } = this.#createUniformValues(this.#uniforms);
        this.#uniforms.buffer = this.#createAndMapBuffer(values, GPUBufferUsage.UNIFORM + GPUBufferUsage.COPY_DST, true, paramsDataSize.bytes);

        if (this.#meshUniforms.length) {
            const { values, paramsDataSize } = this.#createUniformValues(this.#meshUniforms);
            this.#meshUniforms.buffer = this.#createAndMapBuffer(values, GPUBufferUsage.UNIFORM + GPUBufferUsage.COPY_DST, true, paramsDataSize.bytes);
        }
        if (this.#cameraUniforms.length) {
            const { values, paramsDataSize } = this.#createUniformValues(this.#cameraUniforms);
            this.#cameraUniforms.buffer = this.#createAndMapBuffer(values, GPUBufferUsage.UNIFORM + GPUBufferUsage.COPY_DST, true, paramsDataSize.bytes);
        }
    }

    /**
     * Updates all uniforms (for the update function)
     */
    #writeParametersUniforms() {
        if (!this.#uniforms.buffer) {
            console.error('An attempt to create uniforms has been made but no setUniform has been called. Maybe an update was called before a setUniform.')
        }
        const { values } = this.#createUniformValues(this.#uniforms);
        this.#writeBuffer(this.#uniforms.buffer, values);

        if (this.#meshUniforms.length) {
            const { values } = this.#createUniformValues(this.#meshUniforms);
            this.#writeBuffer(this.#meshUniforms.buffer, values);
        }
        if (this.#cameraUniforms.length) {
            const { values } = this.#createUniformValues(this.#cameraUniforms);
            this.#writeBuffer(this.#cameraUniforms.buffer, values);
        }
    }

    /**
     * Updates all the storages (for the update function)
     */
    #writeStorages() {
        this.#storage.forEach(storageItem => {
            // since audio is something constant
            // the stream flag allows to keep this write open
            const { updated, stream } = storageItem;
            if (storageItem.mapped &amp;&amp; (updated || stream)) {
                const values = new Float32Array(storageItem.array);
                this.#writeBuffer(storageItem.buffer, values);
                if (!stream) {
                    storageItem.updated = false;
                }
            }
        });
    }

    /**
     * For each set of arrays with set* data, it creates their corresponding
     * buffer
     */
    #createBuffers() {
        //--------------------------------------------
        this.#createParametersUniforms();
        //--------------------------------------------
        this.#storage.forEach(storageItem => {
            let usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
            if (storageItem.read) {
                let readStorageItem = {
                    name: storageItem.name,
                    size: storageItem.structSize
                }
                if (storageItem.mapped) {
                    readStorageItem = {
                        name: storageItem.name,
                        size: storageItem.array.length,
                    }
                }
                this.#readStorage.push(readStorageItem);
                usage = usage | GPUBufferUsage.COPY_SRC;
            }
            storageItem.usage = usage;
            if (storageItem.mapped) {
                const values = new Float32Array(storageItem.array);
                storageItem.buffer = this.#createAndMapBuffer(values, usage);
            } else {
                storageItem.buffer = this.#createBuffer(storageItem.structSize, usage);
            }
        });
        //--------------------------------------------
        this.#readStorage.forEach(readStorageItem => {
            readStorageItem.buffer = this.#device.createBuffer({
                size: readStorageItem.size,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });
        });
        //--------------------------------------------
        if (this.#layers.length) {
            //let layerValues = [];
            let layersSize = 0;
            this.#layers.forEach(layerItem => {
                layersSize += layerItem.size * layerItem.structSize;
            });
            this.#layers.buffer = this.#createBuffer(layersSize, GPUBufferUsage.STORAGE);
        }
        //--------------------------------------------
        this.#samplers.forEach(sampler => sampler.resource = this.#device.createSampler(sampler.descriptor));
        //--------------------------------------------
        this.#texturesStorage2d.forEach(textureStorage2d => {
            textureStorage2d.texture = this.#device.createTexture({
                label: `_createBuffers, texturesStorage2d: ${textureStorage2d.name}`,
                size: this.#presentationSize,
                format: 'rgba8unorm',
                usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
            });
        });
        //--------------------------------------------
        this.#textures2d.forEach(texture2d => {
            if (texture2d.imageTexture) {
                const imageBitmap = texture2d.imageTexture.bitmap;
                const cubeTexture = this.#device.createTexture({
                    label: `_createBuffers, textures2d: ${texture2d.name}`,
                    size: [imageBitmap.width, imageBitmap.height, 1],
                    format: 'rgba8unorm',
                    usage:
                        GPUTextureUsage.TEXTURE_BINDING |
                        GPUTextureUsage.COPY_SRC |
                        GPUTextureUsage.COPY_DST |
                        GPUTextureUsage.RENDER_ATTACHMENT,
                });
                this.#device.queue.copyExternalImageToTexture(
                    { source: imageBitmap },
                    { texture: cubeTexture },
                    [imageBitmap.width, imageBitmap.height]
                );
                texture2d.texture = cubeTexture;
                // } else if (texture2d.copyCurrentTexture) {
            } else {
                this.#createTextureBindingToCopy(texture2d);
            }
        });
        //--------------------------------------------
        // this.#texturesDepth2d.forEach(texture2d => this.#createTextureDepth(texture2d));

        this.#texturesDepth2d.forEach(texture2d => {
            const renderPass = this.#renderPasses.find(renderPass => renderPass.index === texture2d.renderPassIndex)
            texture2d.texture = renderPass.textureDepth;
        });
        //--------------------------------------------
        this.#textures2dArray.forEach(texture2dArray => {
            if (texture2dArray.imageTextures) {
                let cubeTexture;
                const imageBitmaps = texture2dArray.imageTextures.bitmaps;
                cubeTexture = this.#device.createTexture({
                    label: `_createBuffers cubeTexture texture2dArray: ${texture2dArray.name}`,
                    size: [imageBitmaps[0].width, imageBitmaps[0].height, imageBitmaps.length],
                    format: 'rgba8unorm',
                    usage:
                        GPUTextureUsage.TEXTURE_BINDING |
                        GPUTextureUsage.COPY_DST |
                        GPUTextureUsage.RENDER_ATTACHMENT,
                });
                imageBitmaps.forEach((imageBitmap, i) => {
                    this.#device.queue.copyExternalImageToTexture(
                        { source: imageBitmap },
                        { texture: cubeTexture, origin: { x: 0, y: 0, z: i } },
                        [imageBitmap.width, imageBitmap.height, 1]
                    );
                })

                texture2dArray.texture = cubeTexture;
            } else {
                this.#createTextureBindingToCopy(texture2dArray);
            }
        });
        //--------------------------------------------
        this.#texturesExternal.forEach(externalTexture => {
            externalTexture.texture = this.#device.importExternalTexture({
                label: `_createBuffers, externalTexture: ${externalTexture.name}`,
                source: externalTexture.video
            });
        });
        //--------------------------------------------
        this.#bindingTextures.forEach(bindingTexture => {
            bindingTexture.texture = this.#device.createTexture({
                label: `_createBuffers, bindingTexture: ${bindingTexture.name}`,
                size: bindingTexture.size || this.#presentationSize,
                format: 'rgba8unorm',
                usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
            });
        });
    }

    #createTextureBindingToCopy(texture2d) {
        texture2d.texture = this.#device.createTexture({
            label: texture2d.name,
            size: this.#presentationSize,
            format: this.#presentationFormat, // if 'depth24plus' throws error
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        });
    }

    #createTextureDepth(name) {
        return this.#device.createTexture({
            label: name,
            size: this.#presentationSize,
            format: 'depth32float',
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
        });
    }

    #createTextureToSize(texture2d, width, height) {
        texture2d.texture = this.#device.createTexture({
            label: texture2d.name,
            size: [width, height],
            format: this.#presentationFormat, // if 'depth24plus' throws error
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        });
    }

    #createPipeline() {
        this.#renderPasses.forEach(renderPass => {
            if (renderPass.hasComputeShader) {
                this.#createBindGroup(renderPass, GPUShaderStage.COMPUTE);
                renderPass.computePipeline = this.#device.createComputePipeline({
                    layout: this.#device.createPipelineLayout({
                        bindGroupLayouts: [renderPass.bindGroupLayoutCompute]
                    }),
                    label: `_createPipeline() - ${renderPass.index}`,
                    compute: {
                        module: this.#device.createShaderModule({
                            code: renderPass.compiledShaders.compute
                        }),
                        entryPoint: 'main'
                    }
                });
            }

            //--------------------------------------

            if (renderPass.hasVertexAndFragmentShader) {
                this.#createBindGroup(renderPass, GPUShaderStage.VERTEX);
                this.#createBindGroup(renderPass, GPUShaderStage.FRAGMENT);
                let depthStencil = undefined;
                if (renderPass.depthWriteEnabled) {
                    depthStencil = {
                        depthWriteEnabled: renderPass.depthWriteEnabled,
                        depthCompare: 'less',
                        format: 'depth32float',
                    }
                }
                renderPass.renderPipeline = this.#device.createRenderPipeline({
                    label: `render pipeline: renderPass ${renderPass.index} (${renderPass.name})`,
                    // layout: 'auto',
                    layout: this.#device.createPipelineLayout({
                        bindGroupLayouts: [renderPass.bindGroupLayoutVertex, renderPass.bindGroupLayoutFragment]
                    }),
                    //primitive: { topology: 'triangle-strip' },
                    primitive: { topology: renderPass.topology, cullMode: renderPass.cullMode, frontFace: renderPass.frontFace },
                    depthStencil,
                    vertex: {
                        module: this.#device.createShaderModule({
                            code: renderPass.compiledShaders.vertex,
                        }),
                        entryPoint: 'main', // shader function name
                        buffers: [
                            {
                                arrayStride: renderPass.vertexBufferInfo.vertexSize,
                                attributes: [
                                    {
                                        // position
                                        shaderLocation: 0,
                                        offset: renderPass.vertexBufferInfo.vertexOffset,
                                        format: 'float32x4',
                                    },
                                    {
                                        // colors
                                        shaderLocation: 1,
                                        offset: renderPass.vertexBufferInfo.colorOffset,
                                        format: 'float32x4',
                                    },
                                    {
                                        // uv
                                        shaderLocation: 2,
                                        offset: renderPass.vertexBufferInfo.uvOffset,
                                        format: 'float32x2',
                                    },
                                    {
                                        // normals
                                        shaderLocation: 3,
                                        offset: renderPass.vertexBufferInfo.normalOffset,
                                        format: 'float32x3',
                                    },
                                    {
                                        // id -> meshCounter
                                        shaderLocation: 4,
                                        offset: renderPass.vertexBufferInfo.idOffset,
                                        format: 'uint32',
                                    },
                                    {
                                        // barycentrics
                                        shaderLocation: 5,
                                        offset: renderPass.vertexBufferInfo.barycentricsOffset,
                                        format: 'float32x3',
                                    },
                                ],
                            },
                        ],
                    },
                    fragment: {
                        module: this.#device.createShaderModule({
                            code: renderPass.compiledShaders.fragment,
                        }),
                        entryPoint: 'main', // shader function name
                        targets: [
                            {
                                format: this.#presentationFormat,
                                blend: {
                                    alpha: {
                                        srcFactor: 'src-alpha',
                                        dstFactor: 'one-minus-src-alpha',
                                        operation: 'add'
                                    },
                                    color: {
                                        srcFactor: 'src-alpha',
                                        dstFactor: 'one-minus-src-alpha',
                                        operation: 'add'
                                    },
                                },
                                writeMask: GPUColorWrite.ALL,
                            },
                        ],
                    },
                });
            }
        });
    }
    /**
     * Creates the entries for the pipeline
     * @returns an array with the entries
     */
    #createEntries(shaderType, { index: renderPassIndex, internal }) {
        let entries = [];
        let bindingIndex = 0;
        if (this.#uniforms.length) {
            // TODO: 1262
            // if you remove this there's an error that I think is not explained right
            // it talks about a storage in index 1 but it was actually the 0
            // and so is to this uniform you have to change the visibility
            // not remove the type and leaving it empty as it seems you have to do here:
            // https://gpuweb.github.io/gpuweb/#bindgroup-examples
            // originally:
            // if (entry.buffer?.type === 'uniform') {
            //     entry.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT
            // }
            // the call is split here and at the end of the method with the foreach |= assignment
            // const visibility = shaderType === GPUShaderStage.FRAGMENT ? GPUShaderStage.VERTEX : null;
            entries.push(
                {
                    binding: bindingIndex++,
                    resource: {
                        label: 'uniform',
                        buffer: this.#uniforms.buffer
                    },
                    buffer: {
                        type: 'uniform'
                    },
                    // visibility
                }
            );
        }
        if (this.#meshUniforms.length) {
            entries.push(
                {
                    binding: bindingIndex++,
                    resource: {
                        label: 'uniform',
                        buffer: this.#meshUniforms.buffer
                    },
                    buffer: {
                        type: 'uniform'
                    },
                    // visibility
                }
            );
        }
        if (this.#cameraUniforms.length) {
            entries.push(
                {
                    binding: bindingIndex++,
                    resource: {
                        label: 'uniform',
                        buffer: this.#cameraUniforms.buffer
                    },
                    buffer: {
                        type: 'uniform'
                    },
                    // visibility
                }
            );
        }
        this.#storage.forEach(storageItem => {
            const isInternal = internal === storageItem.internal;
            if (isInternal &amp;&amp; (!storageItem.shaderType || storageItem.shaderType &amp; shaderType)) {

                let type = getStorageAccessMode(shaderType, storageItem.shaderType);
                type = entriesModes[type];

                entries.push(
                    {
                        binding: bindingIndex++,
                        resource: {
                            label: 'storage',
                            buffer: storageItem.buffer
                        },
                        buffer: {
                            type
                        },
                        // visibility
                    }
                );
            }
        });
        if (this.#layers.length) {
            if (!this.#layers.shaderType || this.#layers.shaderType &amp; shaderType) {
                entries.push(
                    {
                        binding: bindingIndex++,
                        resource: {
                            label: 'layer',
                            buffer: this.#layers.buffer
                        },
                        buffer: {
                            type: 'storage'
                        }
                    }
                );
            }
        }
        this.#samplers.forEach(sampler => {
            const isInternal = internal === sampler.internal;
            if (isInternal &amp;&amp; (!sampler.shaderType || sampler.shaderType &amp; shaderType)) {
                entries.push(
                    {
                        binding: bindingIndex++,
                        resource: sampler.resource,
                        sampler: {
                            type: sampler.descriptor.compare ? 'comparison' : 'filtering'
                        }
                    }
                );
            }
        });
        this.#texturesStorage2d.forEach(textureStorage2d => {
            const isInternal = internal === textureStorage2d.internal;
            if (isInternal &amp;&amp; (!textureStorage2d.shaderType || textureStorage2d.shaderType &amp; shaderType)) {
                entries.push(
                    {
                        label: 'texture storage 2d',
                        binding: bindingIndex++,
                        resource: textureStorage2d.texture.createView(),
                        storageTexture: {
                            type: 'write-only'
                        }
                    }
                );
            }
        });
        this.#textures2d.forEach(texture2d => {
            const isInternal = internal === texture2d.internal;
            if (isInternal &amp;&amp; (!texture2d.shaderType || texture2d.shaderType &amp; shaderType)) {
                entries.push(
                    {
                        label: 'texture 2d',
                        binding: bindingIndex++,
                        resource: texture2d.texture.createView(),
                        texture: {
                            type: 'float'
                        }
                    }
                );
            }
        });
        this.#texturesDepth2d.forEach(texture2d => {
            if (texture2d.renderPassIndex !== renderPassIndex) {
                const isInternal = internal === texture2d.internal;
                if (isInternal &amp;&amp; (!texture2d.shaderType || texture2d.shaderType &amp; shaderType)) {
                    const renderPass = this.#renderPasses.find(renderPass => renderPass.index === texture2d.renderPassIndex)
                    texture2d.texture = renderPass.textureDepth;
                    entries.push(
                        {
                            label: 'texture depth 2d',
                            binding: bindingIndex++,
                            resource: texture2d.texture.createView(),
                            texture: {
                                sampleType: 'depth',
                                viewDimension: '2d',
                                multisampled: false,
                            }
                        }
                    );
                }
            }
        });
        this.#textures2dArray.forEach(texture2dArray => {
            const isInternal = internal === texture2dArray.internal;
            if (isInternal &amp;&amp; (!texture2dArray.shaderType || texture2dArray.shaderType &amp; shaderType)) {
                entries.push(
                    {
                        label: 'texture 2d array',
                        binding: bindingIndex++,
                        resource: texture2dArray.texture.createView({
                            dimension: '2d-array',
                            baseArrayLayer: 0,
                            arrayLayerCount: texture2dArray.imageTextures.bitmaps.length
                        }),
                        texture: {
                            type: 'float',
                            viewDimension: '2d-array'
                        }
                    }
                );
            }
        });
        this.#texturesExternal.forEach(externalTexture => {
            const isInternal = internal === externalTexture.internal;
            if (isInternal &amp;&amp; (!externalTexture.shaderType || externalTexture.shaderType &amp; shaderType)) {
                entries.push(
                    {
                        label: 'external texture',
                        binding: bindingIndex++,
                        resource: externalTexture.texture,
                        externalTexture: {
                            // type: 'write-only'
                        }
                    }
                );
            }
        });
        // TODO: repeated entry blocks
        this.#bindingTextures.forEach(bindingTexture => {
            const { usesRenderPass } = bindingTexture;
            if (usesRenderPass) {
                if (GPUShaderStage.VERTEX === shaderType) { // to avoid binding texture in vertex
                    return;
                }
                if (bindingTexture.read.renderPassIndex === renderPassIndex) {
                    entries.push(
                        {
                            label: `binding texture 2: name: ${bindingTexture.read.name}`,
                            binding: bindingIndex++,
                            resource: bindingTexture.texture.createView(),
                            texture: {
                                type: 'float'
                            }
                        }
                    );
                }
                if (bindingTexture.write.renderPassIndex === renderPassIndex) {
                    entries.push(
                        {
                            label: `binding texture: name: ${bindingTexture.write.name}`,
                            binding: bindingIndex++,
                            resource: bindingTexture.texture.createView(),
                            storageTexture: {
                                type: 'write-only',
                                format: 'rgba8unorm'
                            }
                        }
                    );
                }
                return;
            }

            const isInternal = internal === bindingTexture.internal;
            if (isInternal &amp;&amp; (bindingTexture.read.shaderType &amp; shaderType)) {
                entries.push(
                    {
                        label: `binding texture 2: name: ${bindingTexture.read.name}`,
                        binding: bindingIndex++,
                        resource: bindingTexture.texture.createView(),
                        texture: {
                            type: 'float'
                        }
                    }
                );
            }

            if (isInternal &amp;&amp; (bindingTexture.write.shaderType &amp; shaderType)) {
                entries.push(
                    {
                        label: `binding texture: name: ${bindingTexture.write.name}`,
                        binding: bindingIndex++,
                        resource: bindingTexture.texture.createView(),
                        storageTexture: {
                            type: 'write-only',
                            format: 'rgba8unorm'
                        }
                    }
                );
            }
        });

        entries.forEach(entry => entry.visibility = shaderType);

        return entries;
    }

    #createEntriesUpdate(shaderType, { index: renderPassIndex, internal }) {
        let entries = [];
        let bindingIndex = 0;
        this.#texturesExternal.forEach(externalTexture => {
            const isInternal = internal === externalTexture.internal;
            if (isInternal &amp;&amp; (!externalTexture.shaderType || externalTexture.shaderType &amp; shaderType)) {
                entries.push(
                    {
                        label: 'external texture',
                        binding: bindingIndex++,
                        resource: externalTexture.texture,
                        externalTexture: {
                            // type: 'write-only'
                        }
                    }
                );
            }
        });
        entries.forEach(entry => entry.visibility = shaderType);

        return entries;
    }

    /**
     * This was originally 3 methods, one per GPUShaderStage.
     * This might seem a bit more complicated but I wanted to have everything
     * in a single method to avoid duplication and possible bifurcations without
     * me knowing.
     * @param {RenderPass} renderPass
     * @param {GPUShaderStage} shaderType
     */
    #createBindGroup(renderPass, shaderType) {
        const hasComputeShader = (shaderType === GPUShaderStage.COMPUTE) &amp;&amp; renderPass.hasComputeShader;
        const hasVertexShader = (shaderType === GPUShaderStage.VERTEX) &amp;&amp; renderPass.hasVertexShader;
        const hasFragmentShader = (shaderType === GPUShaderStage.FRAGMENT) &amp;&amp; renderPass.hasFragmentShader;

        const entries = this.#createEntries(shaderType, renderPass);

        if (entries.length) {
            const bindGroupLayout = this.#device.createBindGroupLayout({ entries });
            const bindGroup = this.#device.createBindGroup({
                label: `_createBindGroup a ${shaderType} - ${renderPass.name}`,
                layout: bindGroupLayout,
                entries
            });

            if (hasComputeShader) {
                renderPass.bindGroupLayoutCompute = bindGroupLayout;
                renderPass.computeBindGroup = bindGroup
            }
            if (hasVertexShader) {
                renderPass.bindGroupLayoutVertex = bindGroupLayout;
                renderPass.vertexBindGroup = bindGroup
            }
            if (hasFragmentShader) {
                renderPass.bindGroupLayoutFragment = bindGroupLayout;
                renderPass.fragmentBindGroup = bindGroup
            }

            // const entriesUpdate = this.#createEntriesUpdate(shaderType, renderPass);
            // const bindGroup2 = this.#device.createBindGroup({
            //     label: `_createBindGroup b ${shaderType} - ${renderPass.name}`,
            //     layout: bindGroupLayout,
            //     entries: entriesUpdate
            // });
            // renderPass.updateBindgroup = bindGroup2
        }

    }

    /**
     * This is a slimmed down version of {@link #createBindGroup}.
     * We don't create the bindGroupLayout since it already exists.
     * We do update the entries. We have to update them because of
     * changing textures like videos.
     * TODO: this can be optimized even further by setting a flag to
     * NOT CALL the createBindGroup if the texture (video/other)
     * is not being updated at all. I have to make the createBindGroup call
     * only if the texture is updated.
     * @param {RenderPass} renderPass
     * @param {GPUShaderStage} shaderType
     */
    #passBindGroup(renderPass, shaderType) {
        const hasComputeShader = (shaderType === GPUShaderStage.COMPUTE) &amp;&amp; renderPass.hasComputeShader;
        const hasVertexShader = (shaderType === GPUShaderStage.VERTEX) &amp;&amp; renderPass.hasVertexShader;
        const hasFragmentShader = (shaderType === GPUShaderStage.FRAGMENT) &amp;&amp; renderPass.hasFragmentShader;

        const entries = this.#createEntries(shaderType, renderPass);

        if (entries.length) {
            let bindGroupLayout = null;

            if (hasComputeShader) {
                bindGroupLayout = renderPass.bindGroupLayoutCompute;
            }
            if (hasVertexShader) {
                bindGroupLayout = renderPass.bindGroupLayoutVertex;
            }
            if (hasFragmentShader) {
                bindGroupLayout = renderPass.bindGroupLayoutFragment;
            }

            const bindGroup = this.#device.createBindGroup({
                label: `_passBindGroup 0`,
                layout: bindGroupLayout,
                entries
            });

            if (hasComputeShader) {
                renderPass.computeBindGroup = bindGroup
            }
            if (hasVertexShader) {
                renderPass.vertexBindGroup = bindGroup
            }
            if (hasFragmentShader) {
                renderPass.fragmentBindGroup = bindGroup
            }


            // const entriesUpdate = this.#createEntriesUpdate(shaderType, renderPass);
            // if (entriesUpdate.length) {
            //     const bindGroup = this.#device.createBindGroup({
            //         label: `passBindGroup ${shaderType} - ${renderPass.name}`,
            //         layout: bindGroupLayout,
            //         entries: entriesUpdate
            //     });
            //     renderPass.updateBindgroup = bindGroup
            // }


        }
    }

    /**
     * Method executed on each {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame | requestAnimationFrame}.
     * Here's where all the calls to update data will be executed.
     * @example
     * await points.init(renderPasses);
     * update();
     *
     * function update() {
     *     points.update();
     *     requestAnimationFrame(update);
     * }
     */
    async update() {
        if (!this.#canvas || !this.#device) return;
        //--------------------------------------------
        this.#delta = this.#clock.getDelta();
        this.#time = this.#clock.time;
        this.#epoch = +new Date() / 1000;
        this.setUniform(UniformKeys.TIME, this.#time);
        this.setUniform(UniformKeys.DELTA, this.#delta);
        this.setUniform(UniformKeys.EPOCH, this.#epoch);
        this.setUniform(UniformKeys.MOUSE_CLICK, this.#mouseClick);
        this.setUniform(UniformKeys.MOUSE_DOWN, this.#mouseDown);
        this.setUniform(UniformKeys.MOUSE_WHEEL, this.#mouseWheel);
        this.setUniform(UniformKeys.SCREEN, [this.#canvas.width, this.#canvas.height]);
        this.setUniform(UniformKeys.MOUSE, [this.#mouseX, this.#mouseY]);
        this.setUniform(UniformKeys.MOUSE_DELTA, this.#mouseDelta);
        //--------------------------------------------
        this.#writeParametersUniforms();
        this.#writeStorages();
        // AUDIO
        // this.#analyser.getByteTimeDomainData(this.#dataArray);
        this.#sounds.forEach(sound => sound.analyser?.getByteFrequencyData(sound.data));
        // END AUDIO
        this.#texturesExternal.forEach(externalTexture => {
            externalTexture.texture = this.#device.importExternalTexture({
                label: `update, externalTexture: ${externalTexture.name}`,
                source: externalTexture.video
            });
            if ('requestVideoFrameCallback' in externalTexture.video) {
                externalTexture.video.requestVideoFrameCallback(_ => { });
            }
        });

        /**
         * @type {GPUCommandEncoder}
         */
        const commandEncoder = this.#device.createCommandEncoder();

        // ---------------------
        const swapChainTexture = this.#context.getCurrentTexture();

        this.#renderPasses.forEach(renderPass => {
            if (renderPass.hasVertexAndFragmentShader) {
                renderPass.descriptor.colorAttachments[0].view = swapChainTexture.createView();
                if (renderPass.depthWriteEnabled &amp;&amp; (!renderPass.descriptor.depthStencilAttachment.view || this.#screenResized)) {
                    renderPass.descriptor.depthStencilAttachment.view = renderPass.textureDepth.createView();
                }

                const isSameDevice = this.#device === renderPass.device;

                // texturesExternal means there's a video
                // if there's a video it needs to be updated no matter what.
                // Also, it needs to be updated if the screen size changes
                if (!isSameDevice || !renderPass.bundle || this.#texturesExternal.length || this.#screenResized || this.#textureUpdated) {
                    this.#passBindGroup(renderPass, GPUShaderStage.FRAGMENT);
                    this.#passBindGroup(renderPass, GPUShaderStage.VERTEX);
                    /** @type {GPURenderBundleEncoderDescriptor} */
                    const bundleEncoderDescriptor = {
                        colorFormats: [this.#presentationFormat],
                        sampleCount: 1
                    }

                    if (renderPass.depthWriteEnabled) {
                        bundleEncoderDescriptor.depthStencilFormat = 'depth32float'
                    }

                    /** @type {GPURenderBundleEncoder} */
                    const bundleEncoder = this.#device.createRenderBundleEncoder(bundleEncoderDescriptor);

                    bundleEncoder.setPipeline(renderPass.renderPipeline);

                    if (this.#uniforms.length) {
                        bundleEncoder.setBindGroup(0, renderPass.vertexBindGroup);
                        bundleEncoder.setBindGroup(1, renderPass.fragmentBindGroup);
                    }
                    bundleEncoder.setVertexBuffer(0, renderPass.vertexBuffer);

                    // TODO: move this to renderPass because we can ask this just one time and have it as property
                    const isThereInstancing = renderPass.meshes.some(mesh => mesh.instanceCount > 1);
                    if (isThereInstancing) {
                        let vertexOffset = 0;
                        renderPass.meshes.forEach(mesh => {
                            bundleEncoder.draw(mesh.verticesCount, mesh.instanceCount, vertexOffset, 0);
                            vertexOffset = mesh.verticesCount;
                        })
                    } else {
                        // no instancing, regular draw with all the meshes
                        bundleEncoder.draw(renderPass.vertexBufferInfo.vertexCount, 1);
                    }
                    renderPass.bundle = bundleEncoder.finish();
                    renderPass.device = this.#device;
                }

                const passEncoder = commandEncoder.beginRenderPass(renderPass.descriptor);
                // passEncoder.setBindGroup(1, renderPass.updateBindgroup);
                passEncoder.executeBundles([renderPass.bundle]);
                passEncoder.end();


                // Copy the rendering results from the swapchain into |texture2d.texture|.
                this.#textures2d.forEach(texture2d => {
                    if (texture2d.renderPassIndex === renderPass.index || !Number.isInteger(texture2d.renderPassIndex)) {
                        if (texture2d.copyCurrentTexture) {
                            commandEncoder.copyTextureToTexture(
                                {
                                    texture: swapChainTexture,
                                },
                                {
                                    texture: texture2d.texture,
                                },
                                this.#presentationSize
                            );
                        }
                    }
                });
                this.#texturesToCopy.forEach(texturePair => {
                    // this.#createTextureToSize(texturePair.b, texturePair.a.width, texturePair.a.height);
                    commandEncoder.copyTextureToTexture(
                        {
                            texture: texturePair.a,
                        },
                        {
                            texture: texturePair.b,
                        },
                        [texturePair.a.width, texturePair.a.height]
                    );
                });
                this.#texturesToCopy = [];
            }
            if (renderPass.hasComputeShader) {
                if (this.#texturesExternal.length || !renderPass.computeBindGroup) {
                    this.#passBindGroup(renderPass, GPUShaderStage.COMPUTE);
                }

                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(renderPass.computePipeline);
                if (this.#uniforms.length) {
                    passEncoder.setBindGroup(0, renderPass.computeBindGroup);
                }
                passEncoder.dispatchWorkgroups(
                    renderPass.workgroupCountX,
                    renderPass.workgroupCountY,
                    renderPass.workgroupCountZ
                );
                passEncoder.end();
            }
        });
        this.#screenResized = false;
        this.#textureUpdated = false;


        // let descriptor0 = null;
        // const group0 = this.#renderPasses.map(renderPass => {
        //     if(renderPass.depthWriteEnabled){
        //         descriptor0 = renderPass.descriptor
        //         return renderPass.bundle
        //     }
        // })
        // if(descriptor0){
        //     const passEncoder0 = commandEncoder.beginRenderPass(descriptor0);
        //     passEncoder0.executeBundles(group0);
        //     passEncoder0.end();
        // }


        // let descriptor1 = null;
        // const group1 = this.#renderPasses.map(renderPass => {
        //     if(!renderPass.depthWriteEnabled){
        //         descriptor1 = renderPass.descriptor
        //         return renderPass.bundle
        //     }
        // })
        // if(descriptor1){
        //     const passEncoder1 = commandEncoder.beginRenderPass(descriptor1);
        //     passEncoder1.executeBundles(group1);
        //     passEncoder1.end();
        // }





        this.#readStorage.forEach(readStorageItem => {
            let storageItem = this.#storage.find(storageItem => storageItem.name === readStorageItem.name);
            commandEncoder.copyBufferToBuffer(
                storageItem.buffer /* source buffer */,
                0 /* source offset */,
                readStorageItem.buffer /* destination buffer */,
                0 /* destination offset */,
                readStorageItem.buffer.size /* size */
            );
        });
        // ---------------------
        this.#commandsFinished.push(commandEncoder.finish());
        this.#device.queue.submit(this.#commandsFinished);
        this.#commandsFinished = [];
        //
        //this.#vertexArray = [];
        // reset mouse values because it doesn't happen by itself
        this.#mouseClick = false;
        this.#mouseWheel = false;
        this.#mouseDelta = [0, 0];
        await this.read();
    }
    async read() {
        for (const [key, event] of this.#events) {
            const { name } = event;
            const eventRead = await this.readStorage(name);
            if (eventRead) {
                const id = eventRead[0];
                if (id != 0) {
                    const dataRead = await this.readStorage(`${name}_data`)
                    event?.callback(dataRead);
                    const storageToUpdate = this.#nameExists(this.#storage, name);
                    const data = storageToUpdate.array;
                    data[0] = 0;
                    this.setStorageMap(name, data);
                }
            }
        }
    }

    /**
     * Reference to the canvas assigned in the constructor
     * @type {HTMLCanvasElement}
     */
    get canvas() {
        return this.#canvas;
    }

    /**
     * @type {GPUDevice}
     */
    get device() {
        return this.#device;
    }
    get context() {
        return this.#context;
    }
    get presentationFormat() {
        return this.#presentationFormat;
    }
    get buffer() {
        return this.#buffer;
    }
    get fullscreen() {
        return this.#fullscreen;
    }

    /**
     * Triggers the app to run in full screen mode
     * @type {Boolean}
     *
     * @example
     * points.fullscreen = true
     */
    set fullscreen(value) {
        if (value) {
            this.#lastFitWindow = this.#fitWindow;
            this.fitWindow = value;
            this.#canvas.requestFullscreen().catch(err => {
                throw `Error attempting to enable fullscreen mode: ${err.message} (${err.name})`;
            });
            this.#fullscreen = true;
        } else {
            document.exitFullscreen();
            this.#fullscreen = false;
            this.#resizeCanvasToDefault();
        }
    }

    /**
     * If the canvas has a fixed size e.g. `800x800`, `fitWindow` will fill
     * the available window space.
     * @param {Boolean} value
     * @throws {String} {@link Points#init} has not been called
     *
     * @example
     *  if (await points.init(renderPasses)) {
     *      points.fitWindow = isFitWindowData.isFitWindow;
     *      update();
     *  }
     */
    set fitWindow(value) {
        if (!this.#context) {
            throw 'fitWindow must be assigned after Points.init() call or you don\'t have a Canvas assigned in the constructor';
        }
        this.#fitWindow = value;
        if (this.#fitWindow) {
            this.#resizeCanvasToFitWindow();
        } else {
            this.#resizeCanvasToDefault();
        }
    }

    get presentationFormat() {
        return this.#presentationFormat;
    }

    /**
     * Set the maximum range the render textures can hold.
     * If you need HDR values use `16` or `32` float formats.
     * This value is used in the texture that is created when a fragment shader
     * returns its data, so if you use a `vec4` that goes beyond the default
     * capped of `0..1` like `vec4(16,0,1,1)`, then use `16` or `32`.
     *
     * By default it has the `navigator.gpu.getPreferredCanvasFormat();` value.
     * @param {PresentationFormat|String|GPUTextureFormat} value
     */
    set presentationFormat(value) {
        this.#presentationFormat = value;
    }

    destroy() {

        this.#uniforms = new UniformsArray();
        this.#meshUniforms = new UniformsArray();
        this.#cameraUniforms = new UniformsArray();

        this.#texturesExternal.forEach(textureExternal => {
            const stream = textureExternal?.video.srcObject;
            stream?.getTracks().forEach(track => track.stop());
        })
    }
}

export default Points;
export { RenderPass, RenderPasses, PrimitiveTopology, CullMode, LoadOp, PresentationFormat };
</code></pre>
</article>





        </main>
        <footer class="footer">
            
            <div class="lines">
                
                <p class="copyright">&copy; SebastiÃ¡n Sanabria</p>
                
                
                <p class="license">MIT</p>
                
                
                <p class="generator">
                    Documentation generated by <a rel="external" href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a><wbr>
                    using <a rel="external" href="https://github.com/amekusa/docolatte">Docolatte</a> theme
                    
                    <wbr>on <time datetime="2025-12-17T19:11:21.083Z">Wed, 17 Dec 2025 19:11:21 GMT</time>
                    
                </p>
                
            </div>
            
            <div class="bottom">
                <a class="to-top" href="#">
                    <div class="label">Top<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-up icon"><polyline points="18 15 12 9 6 15"></polyline></svg></div>
                </a>
            </div>
        </footer>
    </div>

    <input id="docolatte-sidebar-toggle" type="checkbox">
    <label class="overlay" for="docolatte-sidebar-toggle"></label>
    <label class="menu-button" for="docolatte-sidebar-toggle">
        <div class="shape">
            <i class="icon burger">
                <span class="top"></span>
                <span class="middle"></span>
                <span class="bottom"></span>
            </i>
        </div>
    </label>

    <div class="sidebar">
        <div class="wrap" data-ready="0">
            
<div class="search-box">
	<input class="search" type="text" placeholder="type to searchâ€¦"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search icon"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
	<ol class="dropdown"></ol>
	
	<div class="hint hidden not-for-mobile">
		<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-info icon"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg> Type <em>any key</em> to focus.
	</div>
	
</div>

            <div class="toc">
                <nav class="menu"><h3>Modules</h3><ul class="wbr"><li class="has-child"><a href="module-defaultFunctions.html">default<wbr>Functions</a><ul class="variables has-icons wbr"><li><a href="module-defaultFunctions.html#.defaultVertexBody">default<wbr>Vertex<wbr>Body</a></li></ul></li><li><a href="module-defaultStructs.html">default<wbr>Structs</a></li><li class="has-child"><a href="module-points_animation.html">points<wbr>/animation</a><ul class="variables has-icons wbr"><li><a href="module-points_animation.html#.fnusin">fnusin</a></li><li><a href="module-points_animation.html#.fucos">fucos</a></li><li><a href="module-points_animation.html#.fusin">fusin</a></li></ul></li><li class="has-child"><a href="module-points_audio.html">points<wbr>/audio</a><ul class="variables has-icons wbr"><li><a href="module-points_audio.html#.audioAverage">audio<wbr>Average</a></li><li><a href="module-points_audio.html#.audioAverageSegments">audio<wbr>Average<wbr>Segments</a></li></ul></li><li class="has-child"><a href="module-points_cellular2d.html">points<wbr>/cellular<wbr>2d</a><ul class="variables has-icons wbr"><li><a href="module-points_cellular2d.html#.cellular">cellular</a></li></ul></li><li class="has-child"><a href="module-points_classicnoise2d.html">points<wbr>/classicnoise<wbr>2d</a><ul class="variables has-icons wbr"><li><a href="module-points_classicnoise2d.html#.cnoise">cnoise</a></li><li><a href="module-points_classicnoise2d.html#.pnoise">pnoise</a></li></ul></li><li class="has-child"><a href="module-points_classicnoise3d.html">points<wbr>/classicnoise<wbr>3d</a><ul class="variables has-icons wbr"><li><a href="module-points_classicnoise3d.html#.pnoise3">pnoise<wbr>3</a></li></ul></li><li class="has-child"><a href="module-points_color.html">points<wbr>/color</a><ul class="variables has-icons wbr"><li><a href="module-points_color.html#.BLACK">BLACK</a></li><li><a href="module-points_color.html#.BLUE">BLUE</a></li><li><a href="module-points_color.html#.CYAN">CYAN</a></li><li><a href="module-points_color.html#.GREEN">GREEN</a></li><li><a href="module-points_color.html#.MAGENTA">MAGENTA</a></li><li><a href="module-points_color.html#.RED">RED</a></li><li><a href="module-points_color.html#.RGBAFromHSV">RGBAFrom<wbr>HSV</a></li><li><a href="module-points_color.html#.WHITE">WHITE</a></li><li><a href="module-points_color.html#.YELLOW">YELLOW</a></li><li><a href="module-points_color.html#.bloom">bloom</a></li><li><a href="module-points_color.html#.brightness">brightness</a></li><li><a href="module-points_color.html#.brightnessB">brightness<wbr>B</a></li><li><a href="module-points_color.html#.brightnessC">brightness<wbr>C</a></li><li><a href="module-points_color.html#.layer">layer</a></li></ul></li><li class="has-child"><a href="module-points_debug.html">points<wbr>/debug</a><ul class="variables has-icons wbr"><li><a href="module-points_debug.html#.showDebugCross">show<wbr>Debug<wbr>Cross</a></li><li><a href="module-points_debug.html#.showDebugFrame">show<wbr>Debug<wbr>Frame</a></li></ul></li><li class="has-child"><a href="module-points_effects.html">points<wbr>/effects</a><ul class="variables has-icons wbr"><li><a href="module-points_effects.html#.blur9">blur<wbr>9</a></li><li><a href="module-points_effects.html#.clearAlpha">clear<wbr>Alpha</a></li><li><a href="module-points_effects.html#.clearMix">clear<wbr>Mix</a></li><li><a href="module-points_effects.html#.euclideanDistance">euclidean<wbr>Distance</a></li><li><a href="module-points_effects.html#.getClosestColorInPalette">get<wbr>Closest<wbr>Color<wbr>In<wbr>Palette</a></li><li><a href="module-points_effects.html#.getColorsAround4Texture">get<wbr>Colors<wbr>Around<wbr>4Texture</a></li><li><a href="module-points_effects.html#.getColorsAroundTexture">get<wbr>Colors<wbr>Around<wbr>Texture</a></li><li><a href="module-points_effects.html#.orderedDithering">ordered<wbr>Dithering</a></li><li><a href="module-points_effects.html#.orderedDithering_threshold_map">ordered<wbr>Dithering<wbr>_threshold<wbr>_map</a></li><li><a href="module-points_effects.html#.soften4">soften<wbr>4</a></li><li><a href="module-points_effects.html#.soften8">soften<wbr>8</a></li><li><a href="module-points_effects.html#.wireframe">wireframe</a></li></ul></li><li class="has-child"><a href="module-points_image.html">points<wbr>/image</a><ul class="variables has-icons wbr"><li><a href="module-points_image.html#.decodeNumberSprite">decode<wbr>Number<wbr>Sprite</a></li><li><a href="module-points_image.html#.flipTextureUV">flip<wbr>Texture<wbr>UV</a></li><li><a href="module-points_image.html#.pixelateTexture">pixelate<wbr>Texture</a></li><li><a href="module-points_image.html#.pixelateTexturePosition">pixelate<wbr>Texture<wbr>Position</a></li><li><a href="module-points_image.html#.sprite">sprite</a></li><li><a href="module-points_image.html#.texture">texture</a></li><li><a href="module-points_image.html#.textureExternal">texture<wbr>External</a></li><li><a href="module-points_image.html#.textureExternalPosition">texture<wbr>External<wbr>Position</a></li><li><a href="module-points_image.html#.texturePosition">texture<wbr>Position</a></li></ul></li><li class="has-child"><a href="module-points_math.html">points<wbr>/math</a><ul class="variables has-icons wbr"><li><a href="module-points_math.html#.E">E</a></li><li><a href="module-points_math.html#.PHI">PHI</a></li><li><a href="module-points_math.html#.PI">PI</a></li><li><a href="module-points_math.html#.TAU">TAU</a></li><li><a href="module-points_math.html#.angle">angle</a></li><li><a href="module-points_math.html#.polar">polar</a></li><li><a href="module-points_math.html#.rotXAxis">rot<wbr>XAxis</a></li><li><a href="module-points_math.html#.rotYAxis">rot<wbr>YAxis</a></li><li><a href="module-points_math.html#.rotZAxis">rot<wbr>ZAxis</a></li><li><a href="module-points_math.html#.rotateVector">rotate<wbr>Vector</a></li></ul></li><li class="has-child"><a href="module-points_noise2d.html">points<wbr>/noise<wbr>2d</a><ul class="variables has-icons wbr"><li><a href="module-points_noise2d.html#.snoise">snoise</a></li></ul></li><li class="has-child"><a href="module-points_random.html">points<wbr>/random</a><ul class="variables has-icons wbr"><li><a href="module-points_random.html#.rand">rand</a></li><li><a href="module-points_random.html#.rand2">rand<wbr>2</a></li><li><a href="module-points_random.html#.random">random</a></li></ul></li><li class="has-child"><a href="module-points_sdf.html">points<wbr>/sdf</a><ul class="variables has-icons wbr"><li><a href="module-points_sdf.html#.sdfCircle">sdf<wbr>Circle</a></li><li><a href="module-points_sdf.html#.sdfLine">sdf<wbr>Line</a></li><li><a href="module-points_sdf.html#.sdfLine2">sdf<wbr>Line<wbr>2</a></li><li><a href="module-points_sdf.html#.sdfRect">sdf<wbr>Rect</a></li><li><a href="module-points_sdf.html#.sdfSegment">sdf<wbr>Segment</a></li><li><a href="module-points_sdf.html#.sdfSmooth">sdf<wbr>Smooth</a></li><li><a href="module-points_sdf.html#.sdfSquare">sdf<wbr>Square</a></li></ul></li><li class="has-child"><a href="module-points_valuenoise.html">points<wbr>/valuenoise</a><ul class="variables has-icons wbr"><li><a href="module-points_valuenoise.html#.valueNoise">value<wbr>Noise</a></li></ul></li><li class="has-child"><a href="module-points_voronoi.html">points<wbr>/voronoi</a><ul class="variables has-icons wbr"><li><a href="module-points_voronoi.html#.voronoi">voronoi</a></li></ul></li></ul></nav><nav class="menu"><h3>Classes</h3><ul class="wbr"><li class="has-child"><a href="CanvasRecorder.html">Canvas<wbr>Recorder</a><ul class="functions has-icons wbr"><li><a href="CanvasRecorder.html#getPNG">get<wbr>PNG</a></li><li><a href="CanvasRecorder.html#start">start</a></li><li><a href="CanvasRecorder.html#stop">stop</a></li></ul></li><li class="has-child"><a href="CullMode.html">Cull<wbr>Mode</a><ul class="variables has-icons wbr"><li><a href="CullMode.html#BACK">BACK</a></li><li><a href="CullMode.html#FRONT">FRONT</a></li><li><a href="CullMode.html#NONE">NONE</a></li></ul></li><li class="has-child"><a href="FrontFace.html">Front<wbr>Face</a><ul class="variables has-icons wbr"><li><a href="FrontFace.html#CC">CC</a></li><li><a href="FrontFace.html#CCW">CCW</a></li></ul></li><li class="has-child"><a href="LoadOp.html">Load<wbr>Op</a><ul class="variables has-icons wbr"><li><a href="LoadOp.html#CLEAR">CLEAR</a></li><li><a href="LoadOp.html#LOAD">LOAD</a></li></ul></li><li class="has-child"><a href="Points.html">Points</a><ul class="variables has-icons wbr"><li><a href="Points.html#canvas">canvas</a></li><li><a href="Points.html#device">device</a></li><li><a href="Points.html#fitWindow">fit<wbr>Window</a></li><li><a href="Points.html#fullscreen">fullscreen</a></li><li><a href="Points.html#presentationFormat">presentation<wbr>Format</a></li><li><a href="Points.html#renderPasses">render<wbr>Passes</a></li></ul><ul class="functions has-icons wbr"><li><a href="Points.html#addEventListener">add<wbr>Event<wbr>Listener</a></li><li><a href="Points.html#addRenderPass">add<wbr>Render<wbr>Pass</a></li><li><a href="Points.html#init">init</a></li><li><a href="Points.html#setAudio">set<wbr>Audio</a></li><li><a href="Points.html#setBindingTexture">set<wbr>Binding<wbr>Texture</a></li><li><a href="Points.html#setCameraOrthographic">set<wbr>Camera<wbr>Orthographic</a></li><li><a href="Points.html#setCameraPerspective">set<wbr>Camera<wbr>Perspective</a></li><li><a href="Points.html#setConstant">set<wbr>Constant</a></li><li><a href="Points.html#setLayers">set<wbr>Layers</a></li><li><a href="Points.html#setMeshDensity">set<wbr>Mesh<wbr>Density</a></li><li><a href="Points.html#setSampler">set<wbr>Sampler</a></li><li><a href="Points.html#setStorage">set<wbr>Storage</a></li><li><a href="Points.html#setStorageMap">set<wbr>Storage<wbr>Map</a></li><li><a href="Points.html#setTexture2d">set<wbr>Texture<wbr>2d</a></li><li><a href="Points.html#setTextureDepth2d">set<wbr>Texture<wbr>Depth<wbr>2d</a></li><li><a href="Points.html#setTextureImage">set<wbr>Texture<wbr>Image</a></li><li><a href="Points.html#setTextureImageArray">set<wbr>Texture<wbr>Image<wbr>Array</a></li><li><a href="Points.html#setTextureString">set<wbr>Texture<wbr>String</a></li><li><a href="Points.html#setTextureVideo">set<wbr>Texture<wbr>Video</a></li><li><a href="Points.html#setTextureWebcam">set<wbr>Texture<wbr>Webcam</a></li><li><a href="Points.html#setUniform">set<wbr>Uniform</a></li><li><a href="Points.html#update">update</a></li><li><a href="Points.html#updateUniforms">update<wbr>Uniforms</a></li></ul></li><li class="has-child"><a href="PrimitiveTopology.html">Primitive<wbr>Topology</a><ul class="variables has-icons wbr"><li><a href="PrimitiveTopology.html#LINE_LIST">LINE<wbr>_LIST</a></li><li><a href="PrimitiveTopology.html#LINE_STRIP">LINE<wbr>_STRIP</a></li><li><a href="PrimitiveTopology.html#POINT_LIST">POINT<wbr>_LIST</a></li><li><a href="PrimitiveTopology.html#TRIANGLE_LIST">TRIANGLE<wbr>_LIST</a></li><li><a href="PrimitiveTopology.html#TRIANGLE_STRIP">TRIANGLE<wbr>_STRIP</a></li></ul></li><li class="has-child"><a href="RenderPass.html">Render<wbr>Pass</a><ul class="variables has-icons wbr"><li><a href="RenderPass.html#bundle">bundle</a></li><li><a href="RenderPass.html#clearValue">clear<wbr>Value</a></li><li><a href="RenderPass.html#computeShader">compute<wbr>Shader</a></li><li><a href="RenderPass.html#cullMode">cull<wbr>Mode</a></li><li><a href="RenderPass.html#depthWriteEnabled">depth<wbr>Write<wbr>Enabled</a></li><li><a href="RenderPass.html#descriptor">descriptor</a></li><li><a href="RenderPass.html#device">device</a></li><li><a href="RenderPass.html#fragmentShader">fragment<wbr>Shader</a></li><li><a href="RenderPass.html#frontFace">front<wbr>Face</a></li><li><a href="RenderPass.html#index">index</a></li><li><a href="RenderPass.html#instanceCount">instance<wbr>Count</a></li><li><a href="RenderPass.html#loadOp">load<wbr>Op</a></li><li><a href="RenderPass.html#meshes">meshes</a></li><li><a href="RenderPass.html#params">params</a></li><li><a href="RenderPass.html#params">params</a></li><li><a href="RenderPass.html#required">required</a></li><li><a href="RenderPass.html#textureDepth">texture<wbr>Depth</a></li><li><a href="RenderPass.html#topology">topology</a></li><li><a href="RenderPass.html#vertexShader">vertex<wbr>Shader</a></li><li><a href="RenderPass.html#workgroupCountX">workgroup<wbr>Count<wbr>X</a></li><li><a href="RenderPass.html#workgroupCountX">workgroup<wbr>Count<wbr>X</a></li><li><a href="RenderPass.html#workgroupCountY">workgroup<wbr>Count<wbr>Y</a></li><li><a href="RenderPass.html#workgroupCountY">workgroup<wbr>Count<wbr>Y</a></li><li><a href="RenderPass.html#workgroupCountZ">workgroup<wbr>Count<wbr>Z</a></li><li><a href="RenderPass.html#workgroupCountZ">workgroup<wbr>Count<wbr>Z</a></li></ul><ul class="functions has-icons wbr"><li><a href="RenderPass.html#addCube">add<wbr>Cube</a></li><li><a href="RenderPass.html#addCylinder">add<wbr>Cylinder</a></li><li><a href="RenderPass.html#addMesh">add<wbr>Mesh</a></li><li><a href="RenderPass.html#addPlane">add<wbr>Plane</a></li><li><a href="RenderPass.html#addSphere">add<wbr>Sphere</a></li><li><a href="RenderPass.html#addTorus">add<wbr>Torus</a></li><li><a href="RenderPass.html#init">init</a></li></ul></li><li class="has-child"><a href="RenderPasses.html">Render<wbr>Passes</a><ul class="variables has-icons wbr"><li><a href="RenderPasses.html#BLOOM">BLOOM</a></li><li><a href="RenderPasses.html#BLUR">BLUR</a></li><li><a href="RenderPasses.html#CHROMATIC_ABERRATION">CHROMATIC<wbr>_ABERRATION</a></li><li><a href="RenderPasses.html#COLOR">COLOR</a></li><li><a href="RenderPasses.html#CRT">CRT</a></li><li><a href="RenderPasses.html#FILM_GRAIN">FILM<wbr>_GRAIN</a></li><li><a href="RenderPasses.html#GRAYSCALE">GRAYSCALE</a></li><li><a href="RenderPasses.html#LENS_DISTORTION">LENS<wbr>_DISTORTION</a></li><li><a href="RenderPasses.html#PIXELATE">PIXELATE</a></li><li><a href="RenderPasses.html#WAVES">WAVES</a></li></ul></li></ul></nav>
            </div>
        </div>
    </div>
</div>

<script id="docolatte-search-items" type="application/json">[{"$":["module-defaultFunctions.html","defaultFunctions"],"a":"defaultFunctions","b":"module:defaultFunctions","c":"core/defaultFunctions.js","e":"The defaultFunctions are functions already incorporated onto the shaders you create, so you can call them without import.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader. Use the base example as reference: examples/base/vert.js"},{"$":["module-defaultFunctions.html#.defaultVertexBody","module:defaultFunctions.defaultVertexBody"],"a":"defaultVertexBody","b":"module:defaultFunctions.defaultVertexBody","c":"core/defaultFunctions.js","e":"The defaultVertexBody is used as a drop-in replacement of the vertex shader content.   This is not required, but useful if you plan to use the default parameters of the library.   All the examples in the examples directory use this function in their vert.js file.     Default function for the Vertex shader that takes charge of automating the creation of a few variables that are commonly used."},{"$":["module-defaultStructs.html","defaultStructs"],"a":"defaultStructs","b":"module:defaultStructs","c":"core/defaultStructs.js","e":"The defaultStructs are structs already incorporated onto the shaders you create, so you can call them without import.   Fragment, Sound, and Event structs.     Fragment used in Vertex Shaders.  Sound used along with {@link Points#setAudio}  Event used along with {@link Points#addEventListener} "},{"$":["module-points_animation.html","points/animation"],"a":"points/animation","b":"module:points/animation","c":"core/animation.js","e":"Utilities for animation.   Functions that use sine and params.time to increase and decrease a value over time.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_animation.html#.fnusin","module:points/animation.fnusin"],"a":"fnusin","b":"module:points/animation.fnusin","c":"core/animation.js","e":"Animates sin() over params.time and a provided speed. The value is normalized, so in the range 0..1"},{"$":["module-points_animation.html#.fucos","module:points/animation.fucos"],"a":"fucos","b":"module:points/animation.fucos","c":"core/animation.js","e":"Animates cos() over params.time and a provided speed. The value is not normalized, so in the range -1..1"},{"$":["module-points_animation.html#.fusin","module:points/animation.fusin"],"a":"fusin","b":"module:points/animation.fusin","c":"core/animation.js","e":"Animates sin() over params.time and a provided speed. The value is not normalized, so in the range -1..1"},{"$":["module-points_audio.html","points/audio"],"a":"points/audio","b":"module:points/audio","c":"core/audio.js","e":"Utilities for audio work.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_audio.html#.audioAverage","module:points/audio.audioAverage"],"a":"audioAverage","b":"module:points/audio.audioAverage","c":"core/audio.js","e":"Average of all the value in sound.data (Sound struct in {@link module:defaultStructs})"},{"$":["module-points_audio.html#.audioAverageSegments","module:points/audio.audioAverageSegments"],"a":"audioAverageSegments","b":"module:points/audio.audioAverageSegments","c":"core/audio.js","e":"WIP"},{"$":["module-points_cellular2d.html","points/cellular2d"],"a":"points/cellular2d","b":"module:points/cellular2d","c":"core/cellular2d.js","e":"original: Author :  Stefan Gustavson (stefan.gustavson@liu.se)  https://github.com/ashima/webgl-noise/blob/master/src/cellular2D.glsl    These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_cellular2d.html#.cellular","module:points/cellular2d.cellular"],"a":"cellular","b":"module:points/cellular2d.cellular","c":"core/cellular2d.js","e":"Cellular noise"},{"$":["module-points_classicnoise2d.html","points/classicnoise2d"],"a":"points/classicnoise2d","b":"module:points/classicnoise2d","c":"core/classicnoise2d.js","e":"original: Author :  Stefan Gustavson (stefan.gustavson@liu.se)  https://github.com/ashima/webgl-noise/blob/master/src/classicnoise2D.glsl    These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_classicnoise2d.html#.cnoise","module:points/classicnoise2d.cnoise"],"a":"cnoise","b":"module:points/classicnoise2d.cnoise","c":"core/classicnoise2d.js","e":"Classic Perlin Noise"},{"$":["module-points_classicnoise2d.html#.pnoise","module:points/classicnoise2d.pnoise"],"a":"pnoise","b":"module:points/classicnoise2d.pnoise","c":"core/classicnoise2d.js","e":"Classic Perlin Noise, periodic variant"},{"$":["module-points_classicnoise3d.html","points/classicnoise3d"],"a":"points/classicnoise3d","b":"module:points/classicnoise3d","c":"core/classicnoise3d.js","e":"original: Author :  Stefan Gustavson (stefan.gustavson@liu.se)  https://github.com/ashima/webgl-noise/blob/master/src/classicnoise3D.glsl    These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_classicnoise3d.html#.pnoise3","module:points/classicnoise3d.pnoise3"],"a":"pnoise3","b":"module:points/classicnoise3d.pnoise3","c":"core/classicnoise3d.js","e":"Classic Perlin noise, periodic variant"},{"$":["module-points_color.html","points/color"],"a":"points/color","b":"module:points/color","c":"core/color.js","e":"A few color constants and wgsl methods to work with colors.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_color.html#.BLACK","module:points/color.BLACK"],"a":"BLACK","b":"module:points/color.BLACK","c":"core/color.js","e":"BLACK color;"},{"$":["module-points_color.html#.BLUE","module:points/color.BLUE"],"a":"BLUE","b":"module:points/color.BLUE","c":"core/color.js","e":"BLUE color;"},{"$":["module-points_color.html#.CYAN","module:points/color.CYAN"],"a":"CYAN","b":"module:points/color.CYAN","c":"core/color.js","e":"CYAN color;"},{"$":["module-points_color.html#.GREEN","module:points/color.GREEN"],"a":"GREEN","b":"module:points/color.GREEN","c":"core/color.js","e":"GREEN color;"},{"$":["module-points_color.html#.MAGENTA","module:points/color.MAGENTA"],"a":"MAGENTA","b":"module:points/color.MAGENTA","c":"core/color.js","e":"MAGENTA color;"},{"$":["module-points_color.html#.RED","module:points/color.RED"],"a":"RED","b":"module:points/color.RED","c":"core/color.js","e":"RED color;"},{"$":["module-points_color.html#.RGBAFromHSV","module:points/color.RGBAFromHSV"],"a":"RGBAFromHSV","b":"module:points/color.RGBAFromHSV","c":"core/color.js","e":"Creates a rgba vec4f from an hsv color value"},{"$":["module-points_color.html#.WHITE","module:points/color.WHITE"],"a":"WHITE","b":"module:points/color.WHITE","c":"core/color.js","e":"WHITE color;"},{"$":["module-points_color.html#.YELLOW","module:points/color.YELLOW"],"a":"YELLOW","b":"module:points/color.YELLOW","c":"core/color.js","e":"YELLOW color;"},{"$":["module-points_color.html#.bloom","module:points/color.bloom"],"a":"bloom","b":"module:points/color.bloom","c":"core/color.js","e":"Compute the FFT (Fast Fourier Transform)"},{"$":["module-points_color.html#.brightness","module:points/color.brightness"],"a":"brightness","b":"module:points/color.brightness","c":"core/color.js","e":"Returns the perceived brightness of a color by the eye.  // Standard  LuminanceA = (0.2126*R) + (0.7152*G) + (0.0722*B)"},{"$":["module-points_color.html#.brightnessB","module:points/color.brightnessB"],"a":"brightnessB","b":"module:points/color.brightnessB","c":"core/color.js","e":"Returns the perceived brightness of a color by the eye.  // Percieved A  LuminanceB = (0.299*R + 0.587*G + 0.114*B)"},{"$":["module-points_color.html#.brightnessC","module:points/color.brightnessC"],"a":"brightnessC","b":"module:points/color.brightnessC","c":"core/color.js","e":"Returns the perceived brightness of a color by the eye.  // Percieved B  slower to calculate  LuminanceC = sqrt(0.299*(R**2) + 0.587*(G**2) + 0.114*(B**2))"},{"$":["module-points_color.html#.layer","module:points/color.layer"],"a":"layer","b":"module:points/color.layer","c":"core/color.js","e":"Layers two colors by cropping the color in the back, based on the alpha value."},{"$":["module-points_debug.html","points/debug"],"a":"points/debug","b":"module:points/debug","c":"core/debug.js","e":"Visual debugging methods like drawing a cross on screen and drawing a square around the screen.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_debug.html#.showDebugCross","module:points/debug.showDebugCross"],"a":"showDebugCross","b":"module:points/debug.showDebugCross","c":"core/debug.js","e":"Draws an infinite cross. Useful to draw it where the mouse is."},{"$":["module-points_debug.html#.showDebugFrame","module:points/debug.showDebugFrame"],"a":"showDebugFrame","b":"module:points/debug.showDebugFrame","c":"core/debug.js","e":"Border around the screen"},{"$":["module-points_effects.html","points/effects"],"a":"points/effects","b":"module:points/effects","c":"core/effects.js","e":"These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_effects.html#.blur9","module:points/effects.blur9"],"a":"blur9","b":"module:points/effects.blur9","c":"core/effects.js","e":"Applies a blur to an image   based on https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl"},{"$":["module-points_effects.html#.clearAlpha","module:points/effects.clearAlpha"],"a":"clearAlpha","b":"module:points/effects.clearAlpha","c":"core/effects.js","e":"Takes a color and reduces its value but applied to the alpha channel."},{"$":["module-points_effects.html#.clearMix","module:points/effects.clearMix"],"a":"clearMix","b":"module:points/effects.clearMix","c":"core/effects.js","e":"Takes a color and reduces its values by a level"},{"$":["module-points_effects.html#.euclideanDistance","module:points/effects.euclideanDistance"],"a":"euclideanDistance","b":"module:points/effects.euclideanDistance","c":"core/effects.js","e":"Calculates the <a href=\"https://en.wikipedia.org/wiki/Euclidean_distance\">Euclidean Distance between colors."},{"$":["module-points_effects.html#.getClosestColorInPalette","module:points/effects.getClosestColorInPalette"],"a":"getClosestColorInPalette","b":"module:points/effects.getClosestColorInPalette","c":"core/effects.js","e":"This assumes you have declared a palette in a variable or constant called getClosestColorInPalette_palette   Gets the closest color based on the distance parameter."},{"$":["module-points_effects.html#.getColorsAround4Texture","module:points/effects.getColorsAround4Texture"],"a":"getColorsAround4Texture","b":"module:points/effects.getColorsAround4Texture","c":"core/effects.js","e":"From a given texture and its position, get top, botto, left and right color values"},{"$":["module-points_effects.html#.getColorsAroundTexture","module:points/effects.getColorsAroundTexture"],"a":"getColorsAroundTexture","b":"module:points/effects.getColorsAroundTexture","c":"core/effects.js","e":"From a given texture and its position, get the 9 color values around."},{"$":["module-points_effects.html#.orderedDithering","module:points/effects.orderedDithering"],"a":"orderedDithering","b":"module:points/effects.orderedDithering","c":"core/effects.js","e":"Applies <a href=\"https://en.wikipedia.org/wiki/Ordered_dithering\">Ordered Dithering to a color. Best with the colors of an image texture.   This requires orderedDithering_threshold_map to be imported or create your own version of it."},{"$":["module-points_effects.html#.orderedDithering_threshold_map","module:points/effects.orderedDithering_threshold_map"],"a":"orderedDithering_threshold_map","b":"module:points/effects.orderedDithering_threshold_map","c":"core/effects.js","e":"To be used with orderedDithering.  You can use this or create yours."},{"$":["module-points_effects.html#.soften4","module:points/effects.soften4"],"a":"soften4","b":"module:points/effects.soften4","c":"core/effects.js","e":"Softens a color based on list of colors around it or any list of 4 colors."},{"$":["module-points_effects.html#.soften8","module:points/effects.soften8"],"a":"soften8","b":"module:points/effects.soften8","c":"core/effects.js","e":"Softens a color based on list of colors around it or any list of 8 colors."},{"$":["module-points_effects.html#.wireframe","module:points/effects.wireframe"],"a":"wireframe","b":"module:points/effects.wireframe","c":"core/effects.js","e":"This function displays the wireframe of a mesh. You need the barycentrics data provided by the vertex shader, this is already provided in the FragmentIn struct in the fragment shader (in variable)."},{"$":["module-points_image.html","points/image"],"a":"points/image","b":"module:points/image","c":"core/image.js","e":"These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_image.html#.decodeNumberSprite","module:points/image.decodeNumberSprite"],"a":"decodeNumberSprite","b":"module:points/image.decodeNumberSprite","c":"core/image.js","e":"From a provided number, get the sprite in an atlas that matches the value."},{"$":["module-points_image.html#.flipTextureUV","module:points/image.flipTextureUV"],"a":"flipTextureUV","b":"module:points/image.flipTextureUV","c":"core/image.js","e":"Flips texture in Y. This because it comes flipped, so this corrects it."},{"$":["module-points_image.html#.pixelateTexture","module:points/image.pixelateTexture"],"a":"pixelateTexture","b":"module:points/image.pixelateTexture","c":"core/image.js","e":"Increase the aparent pixel size of the texture image using textureSample. This reduces the quality of the image."},{"$":["module-points_image.html#.pixelateTexturePosition","module:points/image.pixelateTexturePosition"],"a":"pixelateTexturePosition","b":"module:points/image.pixelateTexturePosition","c":"core/image.js","e":"Increase the aparent pixel size of the texture image using texturePosition. This reduces the quality of the image."},{"$":["module-points_image.html#.sprite","module:points/image.sprite"],"a":"sprite","b":"module:points/image.sprite","c":"core/image.js","e":"Sprite or Atlas. Extract a piece of the sprite with an index."},{"$":["module-points_image.html#.texture","module:points/image.texture"],"a":"texture","b":"module:points/image.texture","c":"core/image.js","e":"Places a texture. The texture being an image loaded from the JS side."},{"$":["module-points_image.html#.textureExternal","module:points/image.textureExternal"],"a":"textureExternal","b":"module:points/image.textureExternal","c":"core/image.js","e":"places texture_external in a position"},{"$":["module-points_image.html#.textureExternalPosition","module:points/image.textureExternalPosition"],"a":"textureExternalPosition","b":"module:points/image.textureExternalPosition","c":"core/image.js","e":"Places texture_external in a position. Texture external being in this case a video loaded as texture in the JS side."},{"$":["module-points_image.html#.texturePosition","module:points/image.texturePosition"],"a":"texturePosition","b":"module:points/image.texturePosition","c":"core/image.js","e":"Places texture in a position"},{"$":["module-points_math.html","points/math"],"a":"points/math","b":"module:points/math","c":"core/math.js","e":"Math utils These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_math.html#.E","module:points/math.E"],"a":"E","b":"module:points/math.E","c":"core/math.js","e":"E is a mathematical constant approximately equal to 2.71828 that is the base of the natural logarithm and exponential function. It is sometimes called Euler's number, after the Swiss mathematician Leonhard Euler."},{"$":["module-points_math.html#.PHI","module:points/math.PHI"],"a":"PHI","b":"module:points/math.PHI","c":"core/math.js","e":"PHI is the Golden Ratio"},{"$":["module-points_math.html#.PI","module:points/math.PI"],"a":"PI","b":"module:points/math.PI","c":"core/math.js","e":"PI is the ratio of a circle's circumference to its diameter."},{"$":["module-points_math.html#.TAU","module:points/math.TAU"],"a":"TAU","b":"module:points/math.TAU","c":"core/math.js","e":"TAU  is the ratio of a circle's circumference to its radius."},{"$":["module-points_math.html#.angle","module:points/math.angle"],"a":"angle","b":"module:points/math.angle","c":"core/math.js","e":"Angle between two points."},{"$":["module-points_math.html#.polar","module:points/math.polar"],"a":"polar","b":"module:points/math.polar","c":"core/math.js","e":"Using polar coordinates, calculates the final point as vec2f"},{"$":["module-points_math.html#.rotXAxis","module:points/math.rotXAxis"],"a":"rotXAxis","b":"module:points/math.rotXAxis","c":"core/math.js","e":"Creates a Matrix rotated in the X axis by an angle in radians."},{"$":["module-points_math.html#.rotYAxis","module:points/math.rotYAxis"],"a":"rotYAxis","b":"module:points/math.rotYAxis","c":"core/math.js","e":"Creates a Matrix rotated in the Y axis by an angle in radians."},{"$":["module-points_math.html#.rotZAxis","module:points/math.rotZAxis"],"a":"rotZAxis","b":"module:points/math.rotZAxis","c":"core/math.js","e":"Creates a Matrix rotated in the Z axis by an angle in radians."},{"$":["module-points_math.html#.rotateVector","module:points/math.rotateVector"],"a":"rotateVector","b":"module:points/math.rotateVector","c":"core/math.js","e":"Rotates a vector an amount of radians"},{"$":["module-points_noise2d.html","points/noise2d"],"a":"points/noise2d","b":"module:points/noise2d","c":"core/noise2d.js","e":"original: Author : Ian McEwan, Ashima Arts. https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_noise2d.html#.snoise","module:points/noise2d.snoise"],"a":"snoise","b":"module:points/noise2d.snoise","c":"core/noise2d.js","e":"Sinplex Noise function"},{"$":["module-points_random.html","points/random"],"a":"points/random","b":"module:points/random","c":"core/random.js","e":"Various random functions. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_random.html#.rand","module:points/random.rand"],"a":"rand","b":"module:points/random.rand","c":"core/random.js","e":"Random number that returns a vec2f.  You have to set the rand_seed before calling rand()."},{"$":["module-points_random.html#.rand2","module:points/random.rand2"],"a":"rand2","b":"module:points/random.rand2","c":"core/random.js","e":"Random number from vec2f param"},{"$":["module-points_random.html#.random","module:points/random.random"],"a":"random","b":"module:points/random.random","c":"core/random.js","e":"Single random number. Use seed to change seed."},{"$":["module-points_sdf.html","points/sdf"],"a":"points/sdf","b":"module:points/sdf","c":"core/sdf.js","e":"A few signed distance functions.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_sdf.html#.sdfCircle","module:points/sdf.sdfCircle"],"a":"sdfCircle","b":"module:points/sdf.sdfCircle","c":"core/sdf.js","e":"Creates a circle"},{"$":["module-points_sdf.html#.sdfLine","module:points/sdf.sdfLine"],"a":"sdfLine","b":"module:points/sdf.sdfLine","c":"core/sdf.js","e":"Creates a line with a pixel stroke."},{"$":["module-points_sdf.html#.sdfLine2","module:points/sdf.sdfLine2"],"a":"sdfLine2","b":"module:points/sdf.sdfLine2","c":"core/sdf.js","e":"Better than sdfLine to create lines"},{"$":["module-points_sdf.html#.sdfRect","module:points/sdf.sdfRect"],"a":"sdfRect","b":"module:points/sdf.sdfRect","c":"core/sdf.js","e":"Create a rectangle with two coordinates."},{"$":["module-points_sdf.html#.sdfSegment","module:points/sdf.sdfSegment"],"a":"sdfSegment","b":"module:points/sdf.sdfSegment","c":"core/sdf.js","e":"Function used to create lines. It's a dependency of them."},{"$":["module-points_sdf.html#.sdfSmooth","module:points/sdf.sdfSmooth"],"a":"sdfSmooth","b":"module:points/sdf.sdfSmooth","c":"core/sdf.js","e":"Special for letters and create an sdf version of a texture"},{"$":["module-points_sdf.html#.sdfSquare","module:points/sdf.sdfSquare"],"a":"sdfSquare","b":"module:points/sdf.sdfSquare","c":"core/sdf.js","e":"Creates a square"},{"$":["module-points_valuenoise.html","points/valuenoise"],"a":"points/valuenoise","b":"module:points/valuenoise","c":"core/valuenoise.js","e":"Value noise methods. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_valuenoise.html#.valueNoise","module:points/valuenoise.valueNoise"],"a":"valueNoise","b":"module:points/valuenoise.valueNoise","c":"core/valuenoise.js","e":"Implementation of a value noise function.  <a href=\"https://en.wikipedia.org/wiki/Value_noise\">value noise"},{"$":["module-points_voronoi.html","points/voronoi"],"a":"points/voronoi","b":"module:points/voronoi","c":"core/voronoi.js","e":"Voronoi functions. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader."},{"$":["module-points_voronoi.html#.voronoi","module:points/voronoi.voronoi"],"a":"voronoi","b":"module:points/voronoi.voronoi","c":"core/voronoi.js","e":"Voronoi noise. Generated randomly."},{"$":["CanvasRecorder.html","CanvasRecorder"],"a":"CanvasRecorder","b":"CanvasRecorder","c":"CanvasRecorder.js","e":"Records video from a Canvas to a file."},{"$":["CanvasRecorder.html#getPNG","CanvasRecorder#getPNG"],"a":"getPNG","b":"CanvasRecorder#getPNG","c":"CanvasRecorder.js","e":"Retrieves the current frame as a PNG and downloads the image."},{"$":["CanvasRecorder.html#start","CanvasRecorder#start"],"a":"start","b":"CanvasRecorder#start","c":"CanvasRecorder.js","e":"Starts the video recording."},{"$":["CanvasRecorder.html#stop","CanvasRecorder#stop"],"a":"stop","b":"CanvasRecorder#stop","c":"CanvasRecorder.js","e":"Stops the video recording and downloads the video."},{"$":["CullMode.html","CullMode"],"a":"CullMode","b":"CullMode","c":"RenderPass.js","d":"To tell the {@link RenderPass} what polygons should be discarded Default BACK"},{"$":["CullMode.html#BACK","CullMode#BACK"],"a":"BACK","b":"CullMode#BACK","c":"RenderPass.js"},{"$":["CullMode.html#FRONT","CullMode#FRONT"],"a":"FRONT","b":"CullMode#FRONT","c":"RenderPass.js"},{"$":["CullMode.html#NONE","CullMode#NONE"],"a":"NONE","b":"CullMode#NONE","c":"RenderPass.js"},{"$":["FrontFace.html","FrontFace"],"a":"FrontFace","b":"FrontFace","c":"RenderPass.js","d":"To tell the {@link RenderPass} what polygons are Front Facing Default CCW"},{"$":["FrontFace.html#CC","FrontFace#CC"],"a":"CC","b":"FrontFace#CC","c":"RenderPass.js"},{"$":["FrontFace.html#CCW","FrontFace#CCW"],"a":"CCW","b":"FrontFace#CCW","c":"RenderPass.js"},{"$":["LoadOp.html","LoadOp"],"a":"LoadOp","b":"LoadOp","c":"RenderPass.js","d":"To tell the {@link RenderPass} how the data from the previous RenderPass is preserved on screen or cleared. Default CLEAR"},{"$":["LoadOp.html#CLEAR","LoadOp#CLEAR"],"a":"CLEAR","b":"LoadOp#CLEAR","c":"RenderPass.js"},{"$":["LoadOp.html#LOAD","LoadOp#LOAD"],"a":"LOAD","b":"LoadOp#LOAD","c":"RenderPass.js"},{"$":["Points.html","Points"],"a":"Points","b":"Points","c":"points.js","d":"Main class Points, this is the entry point of an application with this library."},{"$":["Points.html#canvas","Points#canvas"],"a":"canvas","b":"Points#canvas","c":"points.js","e":"Reference to the canvas assigned in the constructor"},{"$":["Points.html#device","Points#device"],"a":"device","b":"Points#device","c":"points.js"},{"$":["Points.html#fitWindow","Points#fitWindow"],"a":"fitWindow","b":"Points#fitWindow","c":"points.js","e":"If the canvas has a fixed size e.g. 800x800, fitWindow will fill the available window space."},{"$":["Points.html#fullscreen","Points#fullscreen"],"a":"fullscreen","b":"Points#fullscreen","c":"points.js","e":"Triggers the app to run in full screen mode"},{"$":["Points.html#presentationFormat","Points#presentationFormat"],"a":"presentationFormat","b":"Points#presentationFormat","c":"points.js","e":"Set the maximum range the render textures can hold. If you need HDR values use 16 or 32 float formats. This value is used in the texture that is created when a fragment shader returns its data, so if you use a vec4 that goes beyond the default capped of 0..1 like vec4(16,0,1,1), then use 16 or 32. By default it has the navigator.gpu.getPreferredCanvasFormat(); value."},{"$":["Points.html#renderPasses","Points#renderPasses"],"a":"renderPasses","b":"Points#renderPasses","c":"points.js","e":"Get the active list of {@link RenderPass}"},{"$":["Points.html#addEventListener","Points#addEventListener"],"a":"addEventListener","b":"Points#addEventListener","c":"points.js","e":"Listens for an event dispatched from WGSL code"},{"$":["Points.html#addRenderPass","Points#addRenderPass"],"a":"addRenderPass","b":"Points#addRenderPass","c":"points.js","e":"Injects a render pass after all the render passes added by the user."},{"$":["Points.html#init","Points#init"],"a":"init","b":"Points#init","c":"points.js","e":"One time function call to initialize the shaders."},{"$":["Points.html#setAudio","Points#setAudio"],"a":"setAudio","b":"Points#setAudio","c":"points.js","e":"Assigns an audio FrequencyData to a StorageMap.  Calling setAudio creates a Storage with name in the wgsl shaders.  From this storage you can read the audio data sent to the shader as numeric values.  Values in audio.data are composed of integers on a scale from 0..255"},{"$":["Points.html#setBindingTexture","Points#setBindingTexture"],"a":"setBindingTexture","b":"Points#setBindingTexture","c":"points.js","e":"Special texture where data can be written to it in the Compute Shader and read from in the Fragment Shader OR from a {@link RenderPass} to another. If you use writeIndex and readIndex it will share data between RenderPasses Is a one way communication method. Ideal to store data to it in the Compute Shader and later visualize it in the Fragment Shader."},{"$":["Points.html#setCameraOrthographic","Points#setCameraOrthographic"],"a":"setCameraOrthographic","b":"Points#setCameraOrthographic","c":"points.js","e":"Creates an Orthographic camera with a given name to be used in the shaders. The name is used as identifier in the shaders for the Projection matrix. The name will be inside the camera uniform and composed with the projection identifier: e.g.: name: mycamera uniform buffer: camera.mycamera_projection;"},{"$":["Points.html#setCameraPerspective","Points#setCameraPerspective"],"a":"setCameraPerspective","b":"Points#setCameraPerspective","c":"points.js","e":"Creates a Perspective camera with a given name to be used in the shaders. The name is used as identifier in the shaders for the Projection and View matrices. The name will be inside the camera uniform and composed with the projection and view identifiers: e.g.: name: mycamera uniform buffers: camera.mycamera_projection; camera.mycamera_view The camera must be called on the update method so the aspect is updated by default with the canvas width and height."},{"$":["Points.html#setConstant","Points#setConstant"],"a":"setConstant","b":"Points#setConstant","c":"points.js","e":"Create a WGSL const initialized from JS. Useful to set a value you can't initialize in WGSL because you don't have the value yet. The constant will be ready to use on the WGSL shder string."},{"$":["Points.html#setLayers","Points#setLayers"],"a":"setLayers","b":"Points#setLayers","c":"points.js","e":"Layers of data made of vec4f. This creates a storage array named layers of the size of the screen in pixels;"},{"$":["Points.html#setMeshDensity","Points#setMeshDensity"],"a":"setMeshDensity","b":"Points#setMeshDensity","c":"points.js","e":"Establishes the density of the base mesh, by default 1x1, meaning two triangles. The final number of triangles is numColumns * numRows * 2 ( 2 being the triangles )"},{"$":["Points.html#setSampler","Points#setSampler"],"a":"setSampler","b":"Points#setSampler","c":"points.js","e":"Creates a sampler to be sent to the shaders. Internally it will be a {@link GPUSampler}"},{"$":["Points.html#setStorage","Points#setStorage"],"a":"setStorage","b":"Points#setStorage","c":"points.js","e":"Creates a persistent memory buffer across every frame call. See <a href=\"https://www.w3.org/TR/webgpu/#gpubuffer\">GPUBuffer   Meaning it can be updated in the shaders across the execution of every frame.   It can have almost any type, like f32 or vec2f or even array."},{"$":["Points.html#setStorageMap","Points#setStorageMap"],"a":"setStorageMap","b":"Points#setStorageMap","c":"points.js","e":"Creates a persistent memory buffer across every frame call that can be updated. See <a href=\"https://www.w3.org/TR/webgpu/#gpubuffer\">GPUBuffer   Meaning it can be updated in the shaders across the execution of every frame.   It can have almost any type, like f32 or vec2f or even array.   The difference with {@link Points#setStorage|setStorage} is that this can be initialized with data."},{"$":["Points.html#setTexture2d","Points#setTexture2d"],"a":"setTexture2d","b":"Points#setTexture2d","c":"points.js","e":"Creates a texture_2d in the shaders.  Used to write data and then print to screen.  It can also be used for write the current render pass (what you see on the screen) to this texture, to be used in the next cycle of this render pass; meaning you effectively have the previous frame data before printing the next one."},{"$":["Points.html#setTextureDepth2d","Points#setTextureDepth2d"],"a":"setTextureDepth2d","b":"Points#setTextureDepth2d","c":"points.js","e":"Creates a depth map from the selected renderPassIndex"},{"$":["Points.html#setTextureImage","Points#setTextureImage"],"a":"setTextureImage","b":"Points#setTextureImage","c":"points.js","e":"Loads an image as texture_2d and then it will be available to read data from in the shaders.  Supports web formats like JPG, PNG."},{"$":["Points.html#setTextureImageArray","Points#setTextureImageArray"],"a":"setTextureImageArray","b":"Points#setTextureImageArray","c":"points.js","e":"Load images as texture_2d_array"},{"$":["Points.html#setTextureString","Points#setTextureString"],"a":"setTextureString","b":"Points#setTextureString","c":"points.js","e":"Loads a text string as a texture.  Using an Atlas or a Spritesheet with UTF-16 chars (path) it will create a new texture that contains only the text characters.  Characters in the atlas path must be in order of the UTF-16 chars.  It can have missing characters at the end or at the start, so the offset is added to take account for those chars.  For example, A is 65, but if one character is removed before the letter A, then offset is -1"},{"$":["Points.html#setTextureVideo","Points#setTextureVideo"],"a":"setTextureVideo","b":"Points#setTextureVideo","c":"points.js","e":"Loads a video as texture_externaland then it will be available to read data from in the shaders. Supports web formats like mp4 and webm."},{"$":["Points.html#setTextureWebcam","Points#setTextureWebcam"],"a":"setTextureWebcam","b":"Points#setTextureWebcam","c":"points.js","e":"Loads webcam as texture_externaland then it will be available to read data from in the shaders."},{"$":["Points.html#setUniform","Points#setUniform"],"a":"setUniform","b":"Points#setUniform","c":"points.js","e":"Sets a param (predefined struct already in all shaders) as uniform to send to all shaders. A Uniform is a value that can only be changed from the outside (js side, not the wgsl side), and unless changed it remains consistent."},{"$":["Points.html#update","Points#update"],"a":"update","b":"Points#update","c":"points.js","e":"Method executed on each {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame | requestAnimationFrame}. Here's where all the calls to update data will be executed."},{"$":["Points.html#updateUniforms","Points#updateUniforms"],"a":"updateUniforms","b":"Points#updateUniforms","c":"points.js","e":"Updates a list of uniforms"},{"$":["PrimitiveTopology.html","PrimitiveTopology"],"a":"PrimitiveTopology","b":"PrimitiveTopology","c":"RenderPass.js","d":"To tell the {@link RenderPass} how to display the triangles. Default TRIANGLE_LIST"},{"$":["PrimitiveTopology.html#LINE_LIST","PrimitiveTopology#LINE_LIST"],"a":"LINE_LIST","b":"PrimitiveTopology#LINE_LIST","c":"RenderPass.js"},{"$":["PrimitiveTopology.html#LINE_STRIP","PrimitiveTopology#LINE_STRIP"],"a":"LINE_STRIP","b":"PrimitiveTopology#LINE_STRIP","c":"RenderPass.js"},{"$":["PrimitiveTopology.html#POINT_LIST","PrimitiveTopology#POINT_LIST"],"a":"POINT_LIST","b":"PrimitiveTopology#POINT_LIST","c":"RenderPass.js"},{"$":["PrimitiveTopology.html#TRIANGLE_LIST","PrimitiveTopology#TRIANGLE_LIST"],"a":"TRIANGLE_LIST","b":"PrimitiveTopology#TRIANGLE_LIST","c":"RenderPass.js"},{"$":["PrimitiveTopology.html#TRIANGLE_STRIP","PrimitiveTopology#TRIANGLE_STRIP"],"a":"TRIANGLE_STRIP","b":"PrimitiveTopology#TRIANGLE_STRIP","c":"RenderPass.js"},{"$":["RenderPass.html","RenderPass"],"a":"RenderPass","b":"RenderPass","c":"RenderPass.js","d":"A RenderPass is a way to have a block of shaders to pass to your application pipeline and these render passes will be executed in the order you pass them in the {@link Points#init} method.","e":"A collection of Vertex, Compute and Fragment shaders that represent a RenderPass. This is useful for PostProcessing."},{"$":["RenderPass.html#bundle","RenderPass#bundle"],"a":"bundle","b":"RenderPass#bundle","c":"RenderPass.js","e":"Render Bundle for performance"},{"$":["RenderPass.html#clearValue","RenderPass#clearValue"],"a":"clearValue","b":"RenderPass#clearValue","c":"RenderPass.js","e":"Sets the color used to clear the RenderPass before drawing. (only if {@link RenderPass#loadOp | loadOp} is set to clear) default: black"},{"$":["RenderPass.html#computeShader","RenderPass#computeShader"],"a":"computeShader","b":"RenderPass#computeShader","c":"RenderPass.js","e":"get the compute shader content"},{"$":["RenderPass.html#cullMode","RenderPass#cullMode"],"a":"cullMode","b":"RenderPass#cullMode","c":"RenderPass.js","e":"Triangles to discard. Default BACK. Use class {@link CullMode}"},{"$":["RenderPass.html#depthWriteEnabled","RenderPass#depthWriteEnabled"],"a":"depthWriteEnabled","b":"RenderPass#depthWriteEnabled","c":"RenderPass.js","e":"Controls whether your fragment shader can write to the depth buffer. By default true. To allow transparency and a custom type of sort, set this as false;"},{"$":["RenderPass.html#descriptor","RenderPass#descriptor"],"a":"descriptor","b":"RenderPass#descriptor","c":"RenderPass.js"},{"$":["RenderPass.html#device","RenderPass#device"],"a":"device","b":"RenderPass#device","c":"RenderPass.js","e":"Device reference to check if RenderBundle needs to be rebuilt"},{"$":["RenderPass.html#fragmentShader","RenderPass#fragmentShader"],"a":"fragmentShader","b":"RenderPass#fragmentShader","c":"RenderPass.js","e":"get the fragment shader content"},{"$":["RenderPass.html#frontFace","RenderPass#frontFace"],"a":"frontFace","b":"RenderPass#frontFace","c":"RenderPass.js","e":"Direction of the triangles. Counter Clockwise (CCW) or Clockwise (CW) Default CCW. Use class {@link frontFace}"},{"$":["RenderPass.html#index","RenderPass#index"],"a":"index","b":"RenderPass#index","c":"RenderPass.js","e":"Get the current RenderPass index order in the pipeline. When you add a RenderPass to the constructor or via {@link Points#addRenderPass}, this is the order it receives."},{"$":["RenderPass.html#instanceCount","RenderPass#instanceCount"],"a":"instanceCount","b":"RenderPass#instanceCount","c":"RenderPass.js","e":"Number of instances that will be created of the current mesh (Vertex Buffer) in this RenderPass. This means if you have a quad, it will create instanceCount number of independent quads on the screen. Useful for instanced particles driven by a Storage buffer."},{"$":["RenderPass.html#loadOp","RenderPass#loadOp"],"a":"loadOp","b":"RenderPass#loadOp","c":"RenderPass.js","e":"Controls if the last RenderPass data is preserved on screen or cleared. Default {@link LoadOp#CLEAR}"},{"$":["RenderPass.html#meshes","RenderPass#meshes"],"a":"meshes","b":"RenderPass#meshes","c":"RenderPass.js","e":"For internal purposes ids and names of the meshes"},{"$":["RenderPass.html#params","RenderPass#params"],"a":"params","b":"RenderPass#params","c":"RenderPass.js","e":"Parameters specifically for Post RenderPass"},{"$":["RenderPass.html#params","RenderPass#params"],"a":"params","b":"RenderPass#params","c":"RenderPass.js"},{"$":["RenderPass.html#required","RenderPass#required"],"a":"required","b":"RenderPass#required","c":"RenderPass.js","e":"List of buffer names that are required for this RenderPass so if it shows them in the console."},{"$":["RenderPass.html#textureDepth","RenderPass#textureDepth"],"a":"textureDepth","b":"RenderPass#textureDepth","c":"RenderPass.js","e":"Holder for the depth map for this RenderPass only"},{"$":["RenderPass.html#topology","RenderPass#topology"],"a":"topology","b":"RenderPass#topology","c":"RenderPass.js","e":"To render as Triangles, lines or points. Use class {@link PrimitiveTopology}"},{"$":["RenderPass.html#vertexShader","RenderPass#vertexShader"],"a":"vertexShader","b":"RenderPass#vertexShader","c":"RenderPass.js","e":"get the vertex shader content"},{"$":["RenderPass.html#workgroupCountX","RenderPass#workgroupCountX"],"a":"workgroupCountX","b":"RenderPass#workgroupCountX","c":"RenderPass.js","e":"How many workgroups are in the X dimension."},{"$":["RenderPass.html#workgroupCountX","RenderPass#workgroupCountX"],"a":"workgroupCountX","b":"RenderPass#workgroupCountX","c":"RenderPass.js"},{"$":["RenderPass.html#workgroupCountY","RenderPass#workgroupCountY"],"a":"workgroupCountY","b":"RenderPass#workgroupCountY","c":"RenderPass.js","e":"How many workgroups are in the Y dimension."},{"$":["RenderPass.html#workgroupCountY","RenderPass#workgroupCountY"],"a":"workgroupCountY","b":"RenderPass#workgroupCountY","c":"RenderPass.js"},{"$":["RenderPass.html#workgroupCountZ","RenderPass#workgroupCountZ"],"a":"workgroupCountZ","b":"RenderPass#workgroupCountZ","c":"RenderPass.js","e":"How many workgroups are in the Z dimension."},{"$":["RenderPass.html#workgroupCountZ","RenderPass#workgroupCountZ"],"a":"workgroupCountZ","b":"RenderPass#workgroupCountZ","c":"RenderPass.js"},{"$":["RenderPass.html#addCube","RenderPass#addCube"],"a":"addCube","b":"RenderPass#addCube","c":"RenderPass.js","e":"Adds a mesh cube"},{"$":["RenderPass.html#addCylinder","RenderPass#addCylinder"],"a":"addCylinder","b":"RenderPass#addCylinder","c":"RenderPass.js","e":"Adds a Cylinder mesh"},{"$":["RenderPass.html#addMesh","RenderPass#addMesh"],"a":"addMesh","b":"RenderPass#addMesh","c":"RenderPass.js","e":"Add a external mesh with the provided required data."},{"$":["RenderPass.html#addPlane","RenderPass#addPlane"],"a":"addPlane","b":"RenderPass#addPlane","c":"RenderPass.js","e":"Adds a mesh quad"},{"$":["RenderPass.html#addSphere","RenderPass#addSphere"],"a":"addSphere","b":"RenderPass#addSphere","c":"RenderPass.js","e":"Adds a mesh sphere"},{"$":["RenderPass.html#addTorus","RenderPass#addTorus"],"a":"addTorus","b":"RenderPass#addTorus","c":"RenderPass.js","e":"Adds a Torus mesh"},{"$":["RenderPass.html#init","RenderPass#init"],"a":"init","b":"RenderPass#init","c":"RenderPass.js","e":"Function where the init parameter (set in the constructor) is executed and this call will pass the parameters that the RenderPass requires to run."},{"$":["RenderPasses.html","RenderPasses"],"a":"RenderPasses","b":"RenderPasses","c":"RenderPasses.js","d":"List of predefined Render Passes for Post Processing. Parameters required are shown as a warning in the JS console."},{"$":["RenderPasses.html#BLOOM","RenderPasses#BLOOM"],"a":"BLOOM","b":"RenderPasses#BLOOM","c":"RenderPasses.js","e":"Apply a bloom {@link RenderPass}"},{"$":["RenderPasses.html#BLUR","RenderPasses#BLUR"],"a":"BLUR","b":"RenderPasses#BLUR","c":"RenderPasses.js","e":"Apply a blur {@link RenderPass}"},{"$":["RenderPasses.html#CHROMATIC_ABERRATION","RenderPasses#CHROMATIC_ABERRATION"],"a":"CHROMATIC_ABERRATION","b":"RenderPasses#CHROMATIC_ABERRATION","c":"RenderPasses.js","e":"Apply a chromatic aberration {@link RenderPass}"},{"$":["RenderPasses.html#COLOR","RenderPasses#COLOR"],"a":"COLOR","b":"RenderPasses#COLOR","c":"RenderPasses.js","e":"Apply a color {@link RenderPass}"},{"$":["RenderPasses.html#CRT","RenderPasses#CRT"],"a":"CRT","b":"RenderPasses#CRT","c":"RenderPasses.js","e":"Apply a CRT tv pixels effect {@link RenderPass}"},{"$":["RenderPasses.html#FILM_GRAIN","RenderPasses#FILM_GRAIN"],"a":"FILM_GRAIN","b":"RenderPasses#FILM_GRAIN","c":"RenderPasses.js","e":"Apply a film grain {@link RenderPass}"},{"$":["RenderPasses.html#GRAYSCALE","RenderPasses#GRAYSCALE"],"a":"GRAYSCALE","b":"RenderPasses#GRAYSCALE","c":"RenderPasses.js","e":"Apply a grayscale {@link RenderPass}"},{"$":["RenderPasses.html#LENS_DISTORTION","RenderPasses#LENS_DISTORTION"],"a":"LENS_DISTORTION","b":"RenderPasses#LENS_DISTORTION","c":"RenderPasses.js","e":"Apply a lens distortion {@link RenderPass}"},{"$":["RenderPasses.html#PIXELATE","RenderPasses#PIXELATE"],"a":"PIXELATE","b":"RenderPasses#PIXELATE","c":"RenderPasses.js","e":"Apply a pixelation {@link RenderPass}"},{"$":["RenderPasses.html#WAVES","RenderPasses#WAVES"],"a":"WAVES","b":"RenderPasses#WAVES","c":"RenderPasses.js","e":"Apply a waives noise {@link RenderPass}"}]</script><script id="docolatte-search-index" type="application/json">{"keys":[{"path":["a"],"id":"a","weight":10,"src":"a"},{"path":["b"],"id":"b","weight":9,"src":"b"},{"path":["c"],"id":"c","weight":6,"src":"c"},{"path":["d"],"id":"d","weight":2,"src":"d"},{"path":["e"],"id":"e","weight":2,"src":"e"}],"records":[{"i":0,"$":{"0":{"v":"defaultFunctions","n":1},"1":{"v":"module:defaultFunctions","n":1},"2":{"v":"core/defaultFunctions.js","n":1},"4":{"v":"The defaultFunctions are functions already incorporated onto the shaders you create, so you can call them without import.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader. Use the base example as reference: examples/base/vert.js","n":0.136}}},{"i":1,"$":{"0":{"v":"defaultVertexBody","n":1},"1":{"v":"module:defaultFunctions.defaultVertexBody","n":1},"2":{"v":"core/defaultFunctions.js","n":1},"4":{"v":"The defaultVertexBody is used as a drop-in replacement of the vertex shader content.   This is not required, but useful if you plan to use the default parameters of the library.   All the examples in the examples directory use this function in their vert.js file.     Default function for the Vertex shader that takes charge of automating the creation of a few variables that are commonly used.","n":0.124}}},{"i":2,"$":{"0":{"v":"defaultStructs","n":1},"1":{"v":"module:defaultStructs","n":1},"2":{"v":"core/defaultStructs.js","n":1},"4":{"v":"The defaultStructs are structs already incorporated onto the shaders you create, so you can call them without import.   Fragment, Sound, and Event structs.     Fragment used in Vertex Shaders.  Sound used along with {@link Points#setAudio}  Event used along with {@link Points#addEventListener} ","n":0.158}}},{"i":3,"$":{"0":{"v":"points/animation","n":1},"1":{"v":"module:points/animation","n":1},"2":{"v":"core/animation.js","n":1},"4":{"v":"Utilities for animation.   Functions that use sine and params.time to increase and decrease a value over time.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.147}}},{"i":4,"$":{"0":{"v":"fnusin","n":1},"1":{"v":"module:points/animation.fnusin","n":1},"2":{"v":"core/animation.js","n":1},"4":{"v":"Animates sin() over params.time and a provided speed. The value is normalized, so in the range 0..1","n":0.243}}},{"i":5,"$":{"0":{"v":"fucos","n":1},"1":{"v":"module:points/animation.fucos","n":1},"2":{"v":"core/animation.js","n":1},"4":{"v":"Animates cos() over params.time and a provided speed. The value is not normalized, so in the range -1..1","n":0.236}}},{"i":6,"$":{"0":{"v":"fusin","n":1},"1":{"v":"module:points/animation.fusin","n":1},"2":{"v":"core/animation.js","n":1},"4":{"v":"Animates sin() over params.time and a provided speed. The value is not normalized, so in the range -1..1","n":0.236}}},{"i":7,"$":{"0":{"v":"points/audio","n":1},"1":{"v":"module:points/audio","n":1},"2":{"v":"core/audio.js","n":1},"4":{"v":"Utilities for audio work.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.174}}},{"i":8,"$":{"0":{"v":"audioAverage","n":1},"1":{"v":"module:points/audio.audioAverage","n":1},"2":{"v":"core/audio.js","n":1},"4":{"v":"Average of all the value in sound.data (Sound struct in {@link module:defaultStructs})","n":0.289}}},{"i":9,"$":{"0":{"v":"audioAverageSegments","n":1},"1":{"v":"module:points/audio.audioAverageSegments","n":1},"2":{"v":"core/audio.js","n":1},"4":{"v":"WIP","n":1}}},{"i":10,"$":{"0":{"v":"points/cellular2d","n":1},"1":{"v":"module:points/cellular2d","n":1},"2":{"v":"core/cellular2d.js","n":1},"4":{"v":"original: Author :  Stefan Gustavson (stefan.gustavson@liu.se)  https://github.com/ashima/webgl-noise/blob/master/src/cellular2D.glsl    These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.167}}},{"i":11,"$":{"0":{"v":"cellular","n":1},"1":{"v":"module:points/cellular2d.cellular","n":1},"2":{"v":"core/cellular2d.js","n":1},"4":{"v":"Cellular noise","n":0.707}}},{"i":12,"$":{"0":{"v":"points/classicnoise2d","n":1},"1":{"v":"module:points/classicnoise2d","n":1},"2":{"v":"core/classicnoise2d.js","n":1},"4":{"v":"original: Author :  Stefan Gustavson (stefan.gustavson@liu.se)  https://github.com/ashima/webgl-noise/blob/master/src/classicnoise2D.glsl    These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.167}}},{"i":13,"$":{"0":{"v":"cnoise","n":1},"1":{"v":"module:points/classicnoise2d.cnoise","n":1},"2":{"v":"core/classicnoise2d.js","n":1},"4":{"v":"Classic Perlin Noise","n":0.577}}},{"i":14,"$":{"0":{"v":"pnoise","n":1},"1":{"v":"module:points/classicnoise2d.pnoise","n":1},"2":{"v":"core/classicnoise2d.js","n":1},"4":{"v":"Classic Perlin Noise, periodic variant","n":0.447}}},{"i":15,"$":{"0":{"v":"points/classicnoise3d","n":1},"1":{"v":"module:points/classicnoise3d","n":1},"2":{"v":"core/classicnoise3d.js","n":1},"4":{"v":"original: Author :  Stefan Gustavson (stefan.gustavson@liu.se)  https://github.com/ashima/webgl-noise/blob/master/src/classicnoise3D.glsl    These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.167}}},{"i":16,"$":{"0":{"v":"pnoise3","n":1},"1":{"v":"module:points/classicnoise3d.pnoise3","n":1},"2":{"v":"core/classicnoise3d.js","n":1},"4":{"v":"Classic Perlin noise, periodic variant","n":0.447}}},{"i":17,"$":{"0":{"v":"points/color","n":1},"1":{"v":"module:points/color","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"A few color constants and wgsl methods to work with colors.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.158}}},{"i":18,"$":{"0":{"v":"BLACK","n":1},"1":{"v":"module:points/color.BLACK","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"BLACK color;","n":0.707}}},{"i":19,"$":{"0":{"v":"BLUE","n":1},"1":{"v":"module:points/color.BLUE","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"BLUE color;","n":0.707}}},{"i":20,"$":{"0":{"v":"CYAN","n":1},"1":{"v":"module:points/color.CYAN","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"CYAN color;","n":0.707}}},{"i":21,"$":{"0":{"v":"GREEN","n":1},"1":{"v":"module:points/color.GREEN","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"GREEN color;","n":0.707}}},{"i":22,"$":{"0":{"v":"MAGENTA","n":1},"1":{"v":"module:points/color.MAGENTA","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"MAGENTA color;","n":0.707}}},{"i":23,"$":{"0":{"v":"RED","n":1},"1":{"v":"module:points/color.RED","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"RED color;","n":0.707}}},{"i":24,"$":{"0":{"v":"RGBAFromHSV","n":1},"1":{"v":"module:points/color.RGBAFromHSV","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Creates a rgba vec4f from an hsv color value","n":0.333}}},{"i":25,"$":{"0":{"v":"WHITE","n":1},"1":{"v":"module:points/color.WHITE","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"WHITE color;","n":0.707}}},{"i":26,"$":{"0":{"v":"YELLOW","n":1},"1":{"v":"module:points/color.YELLOW","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"YELLOW color;","n":0.707}}},{"i":27,"$":{"0":{"v":"bloom","n":1},"1":{"v":"module:points/color.bloom","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Compute the FFT (Fast Fourier Transform)","n":0.408}}},{"i":28,"$":{"0":{"v":"brightness","n":1},"1":{"v":"module:points/color.brightness","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Returns the perceived brightness of a color by the eye.  // Standard  LuminanceA = (0.2126*R) + (0.7152*G) + (0.0722*B)","n":0.229}}},{"i":29,"$":{"0":{"v":"brightnessB","n":1},"1":{"v":"module:points/color.brightnessB","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Returns the perceived brightness of a color by the eye.  // Percieved A  LuminanceB = (0.299*R + 0.587*G + 0.114*B)","n":0.224}}},{"i":30,"$":{"0":{"v":"brightnessC","n":1},"1":{"v":"module:points/color.brightnessC","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Returns the perceived brightness of a color by the eye.  // Percieved B  slower to calculate  LuminanceC = sqrt(0.299*(R**2) + 0.587*(G**2) + 0.114*(B**2))","n":0.209}}},{"i":31,"$":{"0":{"v":"layer","n":1},"1":{"v":"module:points/color.layer","n":1},"2":{"v":"core/color.js","n":1},"4":{"v":"Layers two colors by cropping the color in the back, based on the alpha value.","n":0.258}}},{"i":32,"$":{"0":{"v":"points/debug","n":1},"1":{"v":"module:points/debug","n":1},"2":{"v":"core/debug.js","n":1},"4":{"v":"Visual debugging methods like drawing a cross on screen and drawing a square around the screen.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.149}}},{"i":33,"$":{"0":{"v":"showDebugCross","n":1},"1":{"v":"module:points/debug.showDebugCross","n":1},"2":{"v":"core/debug.js","n":1},"4":{"v":"Draws an infinite cross. Useful to draw it where the mouse is.","n":0.289}}},{"i":34,"$":{"0":{"v":"showDebugFrame","n":1},"1":{"v":"module:points/debug.showDebugFrame","n":1},"2":{"v":"core/debug.js","n":1},"4":{"v":"Border around the screen","n":0.5}}},{"i":35,"$":{"0":{"v":"points/effects","n":1},"1":{"v":"module:points/effects","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.186}}},{"i":36,"$":{"0":{"v":"blur9","n":1},"1":{"v":"module:points/effects.blur9","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Applies a blur to an image   based on https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl","n":0.333}}},{"i":37,"$":{"0":{"v":"clearAlpha","n":1},"1":{"v":"module:points/effects.clearAlpha","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Takes a color and reduces its value but applied to the alpha channel.","n":0.277}}},{"i":38,"$":{"0":{"v":"clearMix","n":1},"1":{"v":"module:points/effects.clearMix","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Takes a color and reduces its values by a level","n":0.316}}},{"i":39,"$":{"0":{"v":"euclideanDistance","n":1},"1":{"v":"module:points/effects.euclideanDistance","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Calculates the <a href=\"https://en.wikipedia.org/wiki/Euclidean_distance\">Euclidean Distance between colors.","n":0.378}}},{"i":40,"$":{"0":{"v":"getClosestColorInPalette","n":1},"1":{"v":"module:points/effects.getClosestColorInPalette","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"This assumes you have declared a palette in a variable or constant called getClosestColorInPalette_palette   Gets the closest color based on the distance parameter.","n":0.209}}},{"i":41,"$":{"0":{"v":"getColorsAround4Texture","n":1},"1":{"v":"module:points/effects.getColorsAround4Texture","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"From a given texture and its position, get top, botto, left and right color values","n":0.258}}},{"i":42,"$":{"0":{"v":"getColorsAroundTexture","n":1},"1":{"v":"module:points/effects.getColorsAroundTexture","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"From a given texture and its position, get the 9 color values around.","n":0.277}}},{"i":43,"$":{"0":{"v":"orderedDithering","n":1},"1":{"v":"module:points/effects.orderedDithering","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Applies <a href=\"https://en.wikipedia.org/wiki/Ordered_dithering\">Ordered Dithering to a color. Best with the colors of an image texture.   This requires orderedDithering_threshold_map to be imported or create your own version of it.","n":0.189}}},{"i":44,"$":{"0":{"v":"orderedDithering_threshold_map","n":1},"1":{"v":"module:points/effects.orderedDithering_threshold_map","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"To be used with orderedDithering.  You can use this or create yours.","n":0.289}}},{"i":45,"$":{"0":{"v":"soften4","n":1},"1":{"v":"module:points/effects.soften4","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Softens a color based on list of colors around it or any list of 4 colors.","n":0.25}}},{"i":46,"$":{"0":{"v":"soften8","n":1},"1":{"v":"module:points/effects.soften8","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"Softens a color based on list of colors around it or any list of 8 colors.","n":0.25}}},{"i":47,"$":{"0":{"v":"wireframe","n":1},"1":{"v":"module:points/effects.wireframe","n":1},"2":{"v":"core/effects.js","n":1},"4":{"v":"This function displays the wireframe of a mesh. You need the barycentrics data provided by the vertex shader, this is already provided in the FragmentIn struct in the fragment shader (in variable).","n":0.177}}},{"i":48,"$":{"0":{"v":"points/image","n":1},"1":{"v":"module:points/image","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.186}}},{"i":49,"$":{"0":{"v":"decodeNumberSprite","n":1},"1":{"v":"module:points/image.decodeNumberSprite","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"From a provided number, get the sprite in an atlas that matches the value.","n":0.267}}},{"i":50,"$":{"0":{"v":"flipTextureUV","n":1},"1":{"v":"module:points/image.flipTextureUV","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Flips texture in Y. This because it comes flipped, so this corrects it.","n":0.277}}},{"i":51,"$":{"0":{"v":"pixelateTexture","n":1},"1":{"v":"module:points/image.pixelateTexture","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Increase the aparent pixel size of the texture image using textureSample. This reduces the quality of the image.","n":0.236}}},{"i":52,"$":{"0":{"v":"pixelateTexturePosition","n":1},"1":{"v":"module:points/image.pixelateTexturePosition","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Increase the aparent pixel size of the texture image using texturePosition. This reduces the quality of the image.","n":0.236}}},{"i":53,"$":{"0":{"v":"sprite","n":1},"1":{"v":"module:points/image.sprite","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Sprite or Atlas. Extract a piece of the sprite with an index.","n":0.289}}},{"i":54,"$":{"0":{"v":"texture","n":1},"1":{"v":"module:points/image.texture","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Places a texture. The texture being an image loaded from the JS side.","n":0.277}}},{"i":55,"$":{"0":{"v":"textureExternal","n":1},"1":{"v":"module:points/image.textureExternal","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"places texture_external in a position","n":0.447}}},{"i":56,"$":{"0":{"v":"textureExternalPosition","n":1},"1":{"v":"module:points/image.textureExternalPosition","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Places texture_external in a position. Texture external being in this case a video loaded as texture in the JS side.","n":0.224}}},{"i":57,"$":{"0":{"v":"texturePosition","n":1},"1":{"v":"module:points/image.texturePosition","n":1},"2":{"v":"core/image.js","n":1},"4":{"v":"Places texture in a position","n":0.447}}},{"i":58,"$":{"0":{"v":"points/math","n":1},"1":{"v":"module:points/math","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"Math utils These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.18}}},{"i":59,"$":{"0":{"v":"E","n":1},"1":{"v":"module:points/math.E","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"E is a mathematical constant approximately equal to 2.71828 that is the base of the natural logarithm and exponential function. It is sometimes called Euler's number, after the Swiss mathematician Leonhard Euler.","n":0.177}}},{"i":60,"$":{"0":{"v":"PHI","n":1},"1":{"v":"module:points/math.PHI","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"PHI is the Golden Ratio","n":0.447}}},{"i":61,"$":{"0":{"v":"PI","n":1},"1":{"v":"module:points/math.PI","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"PI is the ratio of a circle's circumference to its diameter.","n":0.302}}},{"i":62,"$":{"0":{"v":"TAU","n":1},"1":{"v":"module:points/math.TAU","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"TAU  is the ratio of a circle's circumference to its radius.","n":0.302}}},{"i":63,"$":{"0":{"v":"angle","n":1},"1":{"v":"module:points/math.angle","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"Angle between two points.","n":0.5}}},{"i":64,"$":{"0":{"v":"polar","n":1},"1":{"v":"module:points/math.polar","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"Using polar coordinates, calculates the final point as vec2f","n":0.333}}},{"i":65,"$":{"0":{"v":"rotXAxis","n":1},"1":{"v":"module:points/math.rotXAxis","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"Creates a Matrix rotated in the X axis by an angle in radians.","n":0.277}}},{"i":66,"$":{"0":{"v":"rotYAxis","n":1},"1":{"v":"module:points/math.rotYAxis","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"Creates a Matrix rotated in the Y axis by an angle in radians.","n":0.277}}},{"i":67,"$":{"0":{"v":"rotZAxis","n":1},"1":{"v":"module:points/math.rotZAxis","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"Creates a Matrix rotated in the Z axis by an angle in radians.","n":0.277}}},{"i":68,"$":{"0":{"v":"rotateVector","n":1},"1":{"v":"module:points/math.rotateVector","n":1},"2":{"v":"core/math.js","n":1},"4":{"v":"Rotates a vector an amount of radians","n":0.378}}},{"i":69,"$":{"0":{"v":"points/noise2d","n":1},"1":{"v":"module:points/noise2d","n":1},"2":{"v":"core/noise2d.js","n":1},"4":{"v":"original: Author : Ian McEwan, Ashima Arts. https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.164}}},{"i":70,"$":{"0":{"v":"snoise","n":1},"1":{"v":"module:points/noise2d.snoise","n":1},"2":{"v":"core/noise2d.js","n":1},"4":{"v":"Sinplex Noise function","n":0.577}}},{"i":71,"$":{"0":{"v":"points/random","n":1},"1":{"v":"module:points/random","n":1},"2":{"v":"core/random.js","n":1},"4":{"v":"Various random functions. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.177}}},{"i":72,"$":{"0":{"v":"rand","n":1},"1":{"v":"module:points/random.rand","n":1},"2":{"v":"core/random.js","n":1},"4":{"v":"Random number that returns a vec2f.  You have to set the rand_seed before calling rand().","n":0.258}}},{"i":73,"$":{"0":{"v":"rand2","n":1},"1":{"v":"module:points/random.rand2","n":1},"2":{"v":"core/random.js","n":1},"4":{"v":"Random number from vec2f param","n":0.447}}},{"i":74,"$":{"0":{"v":"random","n":1},"1":{"v":"module:points/random.random","n":1},"2":{"v":"core/random.js","n":1},"4":{"v":"Single random number. Use seed to change seed.","n":0.354}}},{"i":75,"$":{"0":{"v":"points/sdf","n":1},"1":{"v":"module:points/sdf","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"A few signed distance functions.     These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.171}}},{"i":76,"$":{"0":{"v":"sdfCircle","n":1},"1":{"v":"module:points/sdf.sdfCircle","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Creates a circle","n":0.577}}},{"i":77,"$":{"0":{"v":"sdfLine","n":1},"1":{"v":"module:points/sdf.sdfLine","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Creates a line with a pixel stroke.","n":0.378}}},{"i":78,"$":{"0":{"v":"sdfLine2","n":1},"1":{"v":"module:points/sdf.sdfLine2","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Better than sdfLine to create lines","n":0.408}}},{"i":79,"$":{"0":{"v":"sdfRect","n":1},"1":{"v":"module:points/sdf.sdfRect","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Create a rectangle with two coordinates.","n":0.408}}},{"i":80,"$":{"0":{"v":"sdfSegment","n":1},"1":{"v":"module:points/sdf.sdfSegment","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Function used to create lines. It's a dependency of them.","n":0.316}}},{"i":81,"$":{"0":{"v":"sdfSmooth","n":1},"1":{"v":"module:points/sdf.sdfSmooth","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Special for letters and create an sdf version of a texture","n":0.302}}},{"i":82,"$":{"0":{"v":"sdfSquare","n":1},"1":{"v":"module:points/sdf.sdfSquare","n":1},"2":{"v":"core/sdf.js","n":1},"4":{"v":"Creates a square","n":0.577}}},{"i":83,"$":{"0":{"v":"points/valuenoise","n":1},"1":{"v":"module:points/valuenoise","n":1},"2":{"v":"core/valuenoise.js","n":1},"4":{"v":"Value noise methods. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.177}}},{"i":84,"$":{"0":{"v":"valueNoise","n":1},"1":{"v":"module:points/valuenoise.valueNoise","n":1},"2":{"v":"core/valuenoise.js","n":1},"4":{"v":"Implementation of a value noise function.  <a href=\"https://en.wikipedia.org/wiki/Value_noise\">value noise","n":0.333}}},{"i":85,"$":{"0":{"v":"points/voronoi","n":1},"1":{"v":"module:points/voronoi","n":1},"2":{"v":"core/voronoi.js","n":1},"4":{"v":"Voronoi functions. These are wgsl functions, not js functions. The function is enclosed in a js string constant, to be appended into the code to reference it in the string shader.","n":0.18}}},{"i":86,"$":{"0":{"v":"voronoi","n":1},"1":{"v":"module:points/voronoi.voronoi","n":1},"2":{"v":"core/voronoi.js","n":1},"4":{"v":"Voronoi noise. Generated randomly.","n":0.5}}},{"i":87,"$":{"0":{"v":"CanvasRecorder","n":1},"1":{"v":"CanvasRecorder","n":1},"2":{"v":"CanvasRecorder.js","n":1},"4":{"v":"Records video from a Canvas to a file.","n":0.354}}},{"i":88,"$":{"0":{"v":"getPNG","n":1},"1":{"v":"CanvasRecorder#getPNG","n":1},"2":{"v":"CanvasRecorder.js","n":1},"4":{"v":"Retrieves the current frame as a PNG and downloads the image.","n":0.302}}},{"i":89,"$":{"0":{"v":"start","n":1},"1":{"v":"CanvasRecorder#start","n":1},"2":{"v":"CanvasRecorder.js","n":1},"4":{"v":"Starts the video recording.","n":0.5}}},{"i":90,"$":{"0":{"v":"stop","n":1},"1":{"v":"CanvasRecorder#stop","n":1},"2":{"v":"CanvasRecorder.js","n":1},"4":{"v":"Stops the video recording and downloads the video.","n":0.354}}},{"i":91,"$":{"0":{"v":"CullMode","n":1},"1":{"v":"CullMode","n":1},"2":{"v":"RenderPass.js","n":1},"3":{"v":"To tell the {@link RenderPass} what polygons should be discarded Default BACK","n":0.289}}},{"i":92,"$":{"0":{"v":"BACK","n":1},"1":{"v":"CullMode#BACK","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":93,"$":{"0":{"v":"FRONT","n":1},"1":{"v":"CullMode#FRONT","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":94,"$":{"0":{"v":"NONE","n":1},"1":{"v":"CullMode#NONE","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":95,"$":{"0":{"v":"FrontFace","n":1},"1":{"v":"FrontFace","n":1},"2":{"v":"RenderPass.js","n":1},"3":{"v":"To tell the {@link RenderPass} what polygons are Front Facing Default CCW","n":0.289}}},{"i":96,"$":{"0":{"v":"CC","n":1},"1":{"v":"FrontFace#CC","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":97,"$":{"0":{"v":"CCW","n":1},"1":{"v":"FrontFace#CCW","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":98,"$":{"0":{"v":"LoadOp","n":1},"1":{"v":"LoadOp","n":1},"2":{"v":"RenderPass.js","n":1},"3":{"v":"To tell the {@link RenderPass} how the data from the previous RenderPass is preserved on screen or cleared. Default CLEAR","n":0.224}}},{"i":99,"$":{"0":{"v":"CLEAR","n":1},"1":{"v":"LoadOp#CLEAR","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":100,"$":{"0":{"v":"LOAD","n":1},"1":{"v":"LoadOp#LOAD","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":101,"$":{"0":{"v":"Points","n":1},"1":{"v":"Points","n":1},"2":{"v":"points.js","n":1},"3":{"v":"Main class Points, this is the entry point of an application with this library.","n":0.267}}},{"i":102,"$":{"0":{"v":"canvas","n":1},"1":{"v":"Points#canvas","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Reference to the canvas assigned in the constructor","n":0.354}}},{"i":103,"$":{"0":{"v":"device","n":1},"1":{"v":"Points#device","n":1},"2":{"v":"points.js","n":1}}},{"i":104,"$":{"0":{"v":"fitWindow","n":1},"1":{"v":"Points#fitWindow","n":1},"2":{"v":"points.js","n":1},"4":{"v":"If the canvas has a fixed size e.g. 800x800, fitWindow will fill the available window space.","n":0.25}}},{"i":105,"$":{"0":{"v":"fullscreen","n":1},"1":{"v":"Points#fullscreen","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Triggers the app to run in full screen mode","n":0.333}}},{"i":106,"$":{"0":{"v":"presentationFormat","n":1},"1":{"v":"Points#presentationFormat","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Set the maximum range the render textures can hold. If you need HDR values use 16 or 32 float formats. This value is used in the texture that is created when a fragment shader returns its data, so if you use a vec4 that goes beyond the default capped of 0..1 like vec4(16,0,1,1), then use 16 or 32. By default it has the navigator.gpu.getPreferredCanvasFormat(); value.","n":0.124}}},{"i":107,"$":{"0":{"v":"renderPasses","n":1},"1":{"v":"Points#renderPasses","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Get the active list of {@link RenderPass}","n":0.378}}},{"i":108,"$":{"0":{"v":"addEventListener","n":1},"1":{"v":"Points#addEventListener","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Listens for an event dispatched from WGSL code","n":0.354}}},{"i":109,"$":{"0":{"v":"addRenderPass","n":1},"1":{"v":"Points#addRenderPass","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Injects a render pass after all the render passes added by the user.","n":0.277}}},{"i":110,"$":{"0":{"v":"init","n":1},"1":{"v":"Points#init","n":1},"2":{"v":"points.js","n":1},"4":{"v":"One time function call to initialize the shaders.","n":0.354}}},{"i":111,"$":{"0":{"v":"setAudio","n":1},"1":{"v":"Points#setAudio","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Assigns an audio FrequencyData to a StorageMap.  Calling setAudio creates a Storage with name in the wgsl shaders.  From this storage you can read the audio data sent to the shader as numeric values.  Values in audio.data are composed of integers on a scale from 0..255","n":0.147}}},{"i":112,"$":{"0":{"v":"setBindingTexture","n":1},"1":{"v":"Points#setBindingTexture","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Special texture where data can be written to it in the Compute Shader and read from in the Fragment Shader OR from a {@link RenderPass} to another. If you use writeIndex and readIndex it will share data between RenderPasses Is a one way communication method. Ideal to store data to it in the Compute Shader and later visualize it in the Fragment Shader.","n":0.126}}},{"i":113,"$":{"0":{"v":"setCameraOrthographic","n":1},"1":{"v":"Points#setCameraOrthographic","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates an Orthographic camera with a given name to be used in the shaders. The name is used as identifier in the shaders for the Projection matrix. The name will be inside the camera uniform and composed with the projection identifier: e.g.: name: mycamera uniform buffer: camera.mycamera_projection;","n":0.146}}},{"i":114,"$":{"0":{"v":"setCameraPerspective","n":1},"1":{"v":"Points#setCameraPerspective","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates a Perspective camera with a given name to be used in the shaders. The name is used as identifier in the shaders for the Projection and View matrices. The name will be inside the camera uniform and composed with the projection and view identifiers: e.g.: name: mycamera uniform buffers: camera.mycamera_projection; camera.mycamera_view The camera must be called on the update method so the aspect is updated by default with the canvas width and height.","n":0.116}}},{"i":115,"$":{"0":{"v":"setConstant","n":1},"1":{"v":"Points#setConstant","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Create a WGSL const initialized from JS. Useful to set a value you can't initialize in WGSL because you don't have the value yet. The constant will be ready to use on the WGSL shder string.","n":0.167}}},{"i":116,"$":{"0":{"v":"setLayers","n":1},"1":{"v":"Points#setLayers","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Layers of data made of vec4f. This creates a storage array named layers of the size of the screen in pixels;","n":0.218}}},{"i":117,"$":{"0":{"v":"setMeshDensity","n":1},"1":{"v":"Points#setMeshDensity","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Establishes the density of the base mesh, by default 1x1, meaning two triangles. The final number of triangles is numColumns * numRows * 2 ( 2 being the triangles )","n":0.183}}},{"i":118,"$":{"0":{"v":"setSampler","n":1},"1":{"v":"Points#setSampler","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates a sampler to be sent to the shaders. Internally it will be a {@link GPUSampler}","n":0.25}}},{"i":119,"$":{"0":{"v":"setStorage","n":1},"1":{"v":"Points#setStorage","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates a persistent memory buffer across every frame call. See <a href=\"https://www.w3.org/TR/webgpu/#gpubuffer\">GPUBuffer   Meaning it can be updated in the shaders across the execution of every frame.   It can have almost any type, like f32 or vec2f or even array.","n":0.16}}},{"i":120,"$":{"0":{"v":"setStorageMap","n":1},"1":{"v":"Points#setStorageMap","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates a persistent memory buffer across every frame call that can be updated. See <a href=\"https://www.w3.org/TR/webgpu/#gpubuffer\">GPUBuffer   Meaning it can be updated in the shaders across the execution of every frame.   It can have almost any type, like f32 or vec2f or even array.   The difference with {@link Points#setStorage|setStorage} is that this can be initialized with data.","n":0.134}}},{"i":121,"$":{"0":{"v":"setTexture2d","n":1},"1":{"v":"Points#setTexture2d","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates a texture_2d in the shaders.  Used to write data and then print to screen.  It can also be used for write the current render pass (what you see on the screen) to this texture, to be used in the next cycle of this render pass; meaning you effectively have the previous frame data before printing the next one.","n":0.13}}},{"i":122,"$":{"0":{"v":"setTextureDepth2d","n":1},"1":{"v":"Points#setTextureDepth2d","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Creates a depth map from the selected renderPassIndex","n":0.354}}},{"i":123,"$":{"0":{"v":"setTextureImage","n":1},"1":{"v":"Points#setTextureImage","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Loads an image as texture_2d and then it will be available to read data from in the shaders.  Supports web formats like JPG, PNG.","n":0.204}}},{"i":124,"$":{"0":{"v":"setTextureImageArray","n":1},"1":{"v":"Points#setTextureImageArray","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Load images as texture_2d_array","n":0.5}}},{"i":125,"$":{"0":{"v":"setTextureString","n":1},"1":{"v":"Points#setTextureString","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Loads a text string as a texture.  Using an Atlas or a Spritesheet with UTF-16 chars (path) it will create a new texture that contains only the text characters.  Characters in the atlas path must be in order of the UTF-16 chars.  It can have missing characters at the end or at the start, so the offset is added to take account for those chars.  For example, A is 65, but if one character is removed before the letter A, then offset is -1","n":0.109}}},{"i":126,"$":{"0":{"v":"setTextureVideo","n":1},"1":{"v":"Points#setTextureVideo","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Loads a video as texture_externaland then it will be available to read data from in the shaders. Supports web formats like mp4 and webm.","n":0.204}}},{"i":127,"$":{"0":{"v":"setTextureWebcam","n":1},"1":{"v":"Points#setTextureWebcam","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Loads webcam as texture_externaland then it will be available to read data from in the shaders.","n":0.25}}},{"i":128,"$":{"0":{"v":"setUniform","n":1},"1":{"v":"Points#setUniform","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Sets a param (predefined struct already in all shaders) as uniform to send to all shaders. A Uniform is a value that can only be changed from the outside (js side, not the wgsl side), and unless changed it remains consistent.","n":0.156}}},{"i":129,"$":{"0":{"v":"update","n":1},"1":{"v":"Points#update","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Method executed on each {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame | requestAnimationFrame}. Here's where all the calls to update data will be executed.","n":0.229}}},{"i":130,"$":{"0":{"v":"updateUniforms","n":1},"1":{"v":"Points#updateUniforms","n":1},"2":{"v":"points.js","n":1},"4":{"v":"Updates a list of uniforms","n":0.447}}},{"i":131,"$":{"0":{"v":"PrimitiveTopology","n":1},"1":{"v":"PrimitiveTopology","n":1},"2":{"v":"RenderPass.js","n":1},"3":{"v":"To tell the {@link RenderPass} how to display the triangles. Default TRIANGLE_LIST","n":0.289}}},{"i":132,"$":{"0":{"v":"LINE_LIST","n":1},"1":{"v":"PrimitiveTopology#LINE_LIST","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":133,"$":{"0":{"v":"LINE_STRIP","n":1},"1":{"v":"PrimitiveTopology#LINE_STRIP","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":134,"$":{"0":{"v":"POINT_LIST","n":1},"1":{"v":"PrimitiveTopology#POINT_LIST","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":135,"$":{"0":{"v":"TRIANGLE_LIST","n":1},"1":{"v":"PrimitiveTopology#TRIANGLE_LIST","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":136,"$":{"0":{"v":"TRIANGLE_STRIP","n":1},"1":{"v":"PrimitiveTopology#TRIANGLE_STRIP","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":137,"$":{"0":{"v":"RenderPass","n":1},"1":{"v":"RenderPass","n":1},"2":{"v":"RenderPass.js","n":1},"3":{"v":"A RenderPass is a way to have a block of shaders to pass to your application pipeline and these render passes will be executed in the order you pass them in the {@link Points#init} method.","n":0.169},"4":{"v":"A collection of Vertex, Compute and Fragment shaders that represent a RenderPass. This is useful for PostProcessing.","n":0.243}}},{"i":138,"$":{"0":{"v":"bundle","n":1},"1":{"v":"RenderPass#bundle","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Render Bundle for performance","n":0.5}}},{"i":139,"$":{"0":{"v":"clearValue","n":1},"1":{"v":"RenderPass#clearValue","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Sets the color used to clear the RenderPass before drawing. (only if {@link RenderPass#loadOp | loadOp} is set to clear) default: black","n":0.213}}},{"i":140,"$":{"0":{"v":"computeShader","n":1},"1":{"v":"RenderPass#computeShader","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"get the compute shader content","n":0.447}}},{"i":141,"$":{"0":{"v":"cullMode","n":1},"1":{"v":"RenderPass#cullMode","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Triangles to discard. Default BACK. Use class {@link CullMode}","n":0.333}}},{"i":142,"$":{"0":{"v":"depthWriteEnabled","n":1},"1":{"v":"RenderPass#depthWriteEnabled","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Controls whether your fragment shader can write to the depth buffer. By default true. To allow transparency and a custom type of sort, set this as false;","n":0.192}}},{"i":143,"$":{"0":{"v":"descriptor","n":1},"1":{"v":"RenderPass#descriptor","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":144,"$":{"0":{"v":"device","n":1},"1":{"v":"RenderPass#device","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Device reference to check if RenderBundle needs to be rebuilt","n":0.316}}},{"i":145,"$":{"0":{"v":"fragmentShader","n":1},"1":{"v":"RenderPass#fragmentShader","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"get the fragment shader content","n":0.447}}},{"i":146,"$":{"0":{"v":"frontFace","n":1},"1":{"v":"RenderPass#frontFace","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Direction of the triangles. Counter Clockwise (CCW) or Clockwise (CW) Default CCW. Use class {@link frontFace}","n":0.25}}},{"i":147,"$":{"0":{"v":"index","n":1},"1":{"v":"RenderPass#index","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Get the current RenderPass index order in the pipeline. When you add a RenderPass to the constructor or via {@link Points#addRenderPass}, this is the order it receives.","n":0.192}}},{"i":148,"$":{"0":{"v":"instanceCount","n":1},"1":{"v":"RenderPass#instanceCount","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Number of instances that will be created of the current mesh (Vertex Buffer) in this RenderPass. This means if you have a quad, it will create instanceCount number of independent quads on the screen. Useful for instanced particles driven by a Storage buffer.","n":0.152}}},{"i":149,"$":{"0":{"v":"loadOp","n":1},"1":{"v":"RenderPass#loadOp","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Controls if the last RenderPass data is preserved on screen or cleared. Default {@link LoadOp#CLEAR}","n":0.258}}},{"i":150,"$":{"0":{"v":"meshes","n":1},"1":{"v":"RenderPass#meshes","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"For internal purposes ids and names of the meshes","n":0.333}}},{"i":151,"$":{"0":{"v":"params","n":1},"1":{"v":"RenderPass#params","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Parameters specifically for Post RenderPass","n":0.447}}},{"i":152,"$":{"0":{"v":"params","n":1},"1":{"v":"RenderPass#params","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":153,"$":{"0":{"v":"required","n":1},"1":{"v":"RenderPass#required","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"List of buffer names that are required for this RenderPass so if it shows them in the console.","n":0.236}}},{"i":154,"$":{"0":{"v":"textureDepth","n":1},"1":{"v":"RenderPass#textureDepth","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Holder for the depth map for this RenderPass only","n":0.333}}},{"i":155,"$":{"0":{"v":"topology","n":1},"1":{"v":"RenderPass#topology","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"To render as Triangles, lines or points. Use class {@link PrimitiveTopology}","n":0.302}}},{"i":156,"$":{"0":{"v":"vertexShader","n":1},"1":{"v":"RenderPass#vertexShader","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"get the vertex shader content","n":0.447}}},{"i":157,"$":{"0":{"v":"workgroupCountX","n":1},"1":{"v":"RenderPass#workgroupCountX","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"How many workgroups are in the X dimension.","n":0.354}}},{"i":158,"$":{"0":{"v":"workgroupCountX","n":1},"1":{"v":"RenderPass#workgroupCountX","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":159,"$":{"0":{"v":"workgroupCountY","n":1},"1":{"v":"RenderPass#workgroupCountY","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"How many workgroups are in the Y dimension.","n":0.354}}},{"i":160,"$":{"0":{"v":"workgroupCountY","n":1},"1":{"v":"RenderPass#workgroupCountY","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":161,"$":{"0":{"v":"workgroupCountZ","n":1},"1":{"v":"RenderPass#workgroupCountZ","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"How many workgroups are in the Z dimension.","n":0.354}}},{"i":162,"$":{"0":{"v":"workgroupCountZ","n":1},"1":{"v":"RenderPass#workgroupCountZ","n":1},"2":{"v":"RenderPass.js","n":1}}},{"i":163,"$":{"0":{"v":"addCube","n":1},"1":{"v":"RenderPass#addCube","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Adds a mesh cube","n":0.5}}},{"i":164,"$":{"0":{"v":"addCylinder","n":1},"1":{"v":"RenderPass#addCylinder","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Adds a Cylinder mesh","n":0.5}}},{"i":165,"$":{"0":{"v":"addMesh","n":1},"1":{"v":"RenderPass#addMesh","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Add a external mesh with the provided required data.","n":0.333}}},{"i":166,"$":{"0":{"v":"addPlane","n":1},"1":{"v":"RenderPass#addPlane","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Adds a mesh quad","n":0.5}}},{"i":167,"$":{"0":{"v":"addSphere","n":1},"1":{"v":"RenderPass#addSphere","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Adds a mesh sphere","n":0.5}}},{"i":168,"$":{"0":{"v":"addTorus","n":1},"1":{"v":"RenderPass#addTorus","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Adds a Torus mesh","n":0.5}}},{"i":169,"$":{"0":{"v":"init","n":1},"1":{"v":"RenderPass#init","n":1},"2":{"v":"RenderPass.js","n":1},"4":{"v":"Function where the init parameter (set in the constructor) is executed and this call will pass the parameters that the RenderPass requires to run.","n":0.204}}},{"i":170,"$":{"0":{"v":"RenderPasses","n":1},"1":{"v":"RenderPasses","n":1},"2":{"v":"RenderPasses.js","n":1},"3":{"v":"List of predefined Render Passes for Post Processing. Parameters required are shown as a warning in the JS console.","n":0.229}}},{"i":171,"$":{"0":{"v":"BLOOM","n":1},"1":{"v":"RenderPasses#BLOOM","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Apply a bloom {@link RenderPass}","n":0.447}}},{"i":172,"$":{"0":{"v":"BLUR","n":1},"1":{"v":"RenderPasses#BLUR","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Apply a blur {@link RenderPass}","n":0.447}}},{"i":173,"$":{"0":{"v":"CHROMATIC_ABERRATION","n":1},"1":{"v":"RenderPasses#CHROMATIC_ABERRATION","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Apply a chromatic aberration {@link RenderPass}","n":0.408}}},{"i":174,"$":{"0":{"v":"COLOR","n":1},"1":{"v":"RenderPasses#COLOR","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Apply a color {@link RenderPass}","n":0.447}}},{"i":175,"$":{"0":{"v":"CRT","n":1},"1":{"v":"RenderPasses#CRT","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Apply a CRT tv pixels effect {@link RenderPass}","n":0.354}}},{"i":176,"$":{"0":{"v":"FILM_GRAIN","n":1},"1":{"v":"RenderPasses#FILM_GRAIN","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Apply a film grain {@link RenderPass}","n":0.408}}},{"i":177,"$":{"0":{"v":"GRAYSCALE","n":1},"1":{"v":"RenderPasses#GRAYSCALE","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Apply a grayscale {@link RenderPass}","n":0.447}}},{"i":178,"$":{"0":{"v":"LENS_DISTORTION","n":1},"1":{"v":"RenderPasses#LENS_DISTORTION","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Apply a lens distortion {@link RenderPass}","n":0.408}}},{"i":179,"$":{"0":{"v":"PIXELATE","n":1},"1":{"v":"RenderPasses#PIXELATE","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Apply a pixelation {@link RenderPass}","n":0.447}}},{"i":180,"$":{"0":{"v":"WAVES","n":1},"1":{"v":"RenderPasses#WAVES","n":1},"2":{"v":"RenderPasses.js","n":1},"4":{"v":"Apply a waives noise {@link RenderPass}","n":0.408}}}]}</script><script id="docolatte-search-options" type="application/json">{"keys":[{"name":"a","weight":10},{"name":"b","weight":9},{"name":"c","weight":6},{"name":"d","weight":2},{"name":"e","weight":2}]}</script>

</body>
</html>
