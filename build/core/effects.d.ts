export const blur8: "\nfn blur8(color:vec4<f32>, colorsAround:array<vec4<f32>, 8>, amount:f32) -> {\n\n}\n";
export const blur9: "\n// based on https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\nfn blur9(image: texture_2d<f32>, imageSampler:sampler, position:vec2<f32>, uv:vec2<f32>, resolution: vec2<f32>, direction: vec2<f32>) -> vec4<f32> {\n    var color = vec4(0.0);\n    let off1 = vec2(1.3846153846) * direction;\n    let off2 = vec2(3.2307692308) * direction;\n    color += texturePosition(image, imageSampler, position, uv, true) * 0.2270270270;\n    color += texturePosition(image, imageSampler, position, uv + (off1 / resolution), true) * 0.3162162162;\n    color += texturePosition(image, imageSampler, position, uv - (off1 / resolution), true) * 0.3162162162;\n    color += texturePosition(image, imageSampler, position, uv + (off2 / resolution), true) * 0.0702702703;\n    color += texturePosition(image, imageSampler, position, uv - (off2 / resolution), true) * 0.0702702703;\n    return color;\n}\n";
export const clearAlpha: "\n// level 2.\nfn clearAlpha(currentColor:vec4<f32>, level:f32) -> vec4<f32>{\n    var ar = currentColor.a / level;\n    if(ar <= .09){\n        ar = 0.;\n    }\n    return vec4<f32>(currentColor.rgb, ar);\n}\n";
export const clearMix: "\n//const clearMixlevel = 1.81;//1.01\nfn clearMix(color:vec4<f32>, level:f32) -> vec4<f32> {\n    let rr = color.r / level;\n    let gr = color.g / level;\n    let br = color.b / level;\n    var ar = color.a / level;\n    if(ar <= .09){\n        ar = 0.;\n    }\n    return vec4<f32>(rr, gr, br, ar);\n}\n";
/**
 * These are wgsl functions, not js functions.
 * The function is enclosed in a js string constant,
 * to be appended into the code to reference it in the string shader.
 * @module points/effects
 */
export const euclideanDistance: "\nfn euclideanDistance(color:vec4<f32>, distanceColor:vec4<f32>) -> f32{\n    return sqrt(\n        pow(color.r - distanceColor.r, 2.) +\n        pow(color.g - distanceColor.g, 2.) +\n        pow(color.b - distanceColor.b, 2.)\n    );\n}\n";
/**
 * From a palette declared in `getClosestColorInPalette_palette`
 * gets the closest color based on `distance`
 * @type {String}
 * @param {vec4<f32>} color `vec4<f32>` color to replace with
 * @param {u32} numPaletteItems `u32` length of getClosestColorInPalette_palette
 * @param {f32} distance `f32` from 0..1 that indicates how close it should be from the color
 * @returns `vec4<f32>`
 */
export const getClosestColorInPalette: string;
export const getColorsAround4Texture: "\nfn getColorsAround4Texture(texture:texture_2d<f32>, position: vec2<i32>, distance: i32) -> array<  vec4<f32>, 4  > {\n    return array< vec4<f32>, 4 >(\n        //textureLoad(texture, vec2<i32>( position.x-distance, position.y-distance  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x, position.y-distance  ),  0).rgba,\n        //textureLoad(texture, vec2<i32>( position.x+distance, position.y-distance  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x-distance, position.y  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x+distance, position.y  ),  0).rgba,\n        //textureLoad(texture, vec2<i32>( position.x-distance, position.y+distance  ),  0).rgba,\n        //textureLoad(texture, vec2<i32>( position.x, position.y+distance  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x+distance, position.y+distance  ),  0).rgba,\n    );\n}\n";
export const getColorsAroundTexture: "\nfn getColorsAroundTexture(texture:texture_2d<f32>, position: vec2<i32>, distance: i32) -> array<  vec4<f32>, 8  > {\n    return array< vec4<f32>,8 >(\n        textureLoad(texture, vec2<i32>( position.x-distance, position.y-distance  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x, position.y-distance  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x+distance, position.y-distance  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x-distance, position.y  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x+distance, position.y  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x-distance, position.y+distance  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x, position.y+distance  ),  0).rgba,\n        textureLoad(texture, vec2<i32>( position.x+distance, position.y+distance  ),  0).rgba,\n    );\n}\n";
export const orderedDithering: "\nfn orderedDithering(color:vec4<f32>, depth:f32, dims:vec2<u32>, uv:vec2<f32>) -> vec4<f32> {\n    // const orderedDithering_threshold_map = array<f32,16>(\n    //     1, 9, 3, 11,\n    //     13, 5, 15, 7,\n    //     4, 12, 2, 10,\n    //     16, 8, 14, 6\n    // );\n\n    let t = orderedDithering_threshold_map[ i32(  (uv.x % 4.) + (uv.y % 4. * f32(dims.x))) ];\n\n    var r = (color.r + t / depth);\n    if(r < 1){r = 0;}\n    var g =  (color.g + t / depth);\n    if(g < 1){g = 0;}\n    var b =  (color.b + t / depth);\n    if(b < 1){b = 0;}\n    let ditheredImage = vec4(\n        r * depth,\n        g * depth,\n        b * depth,\n        1,\n    );\n    return ditheredImage;\n}\n";
export const orderedDithering_threshold_map: "\nconst orderedDithering_threshold_map = array<f32,16>(\n    1, 9, 3, 11,\n    13, 5, 15, 7,\n    4, 12, 2, 10,\n    16, 8, 14, 6\n);\n";
export const soften4: "\nfn soften4(color:vec4<f32>, colorsAround:array<vec4<f32>, 4>, colorPower:f32) -> vec4<f32> {\n    var newColor:vec4<f32> = color;\n    for (var indexColors = 0u; indexColors < 4u; indexColors++) {\n        var colorAround = colorsAround[indexColors];\n        colorAround = (color + colorAround * colorPower) / (colorPower + 1.);\n        newColor += colorAround;\n    }\n    return newColor * .2;\n}\n";
export const soften8: "\nfn soften8(color:vec4<f32>, colorsAround:array<vec4<f32>, 8>, colorPower:f32) -> vec4<f32> {\n    var newColor:vec4<f32> = color;\n    for (var indexColors = 0u; indexColors < 8u; indexColors++) {\n        var colorAround = colorsAround[indexColors];\n        // colorAround.r = (color.r + colorAround.r * colorPower) / (colorPower + 1.);\n        // colorAround.g = (color.g + colorAround.g * colorPower) / (colorPower + 1.);\n        // colorAround.b = (color.b + colorAround.b * colorPower) / (colorPower + 1.);\n        // colorAround.a = (color.a + colorAround.a * colorPower) / (colorPower + 1.);\n\n        colorAround = (color + colorAround * colorPower) / (colorPower + 1.);\n\n\n\n        newColor += colorAround;\n    }\n    return newColor * .2;\n}\n";
