/* @ts-self-types="./points.module.d.ts" */
class UniformKeys{static TIME="time";static DELTA="delta";static EPOCH="epoch";static SCREEN="screen";static MOUSE="mouse";static MOUSE_CLICK="mouseClick";static MOUSE_DOWN="mouseDown";static MOUSE_WHEEL="mouseWheel";static MOUSE_DELTA="mouseDelta"}class VertexBufferInfo{#vertexSize;#vertexOffset;#colorOffset;#uvOffset;#vertexCount;constructor(vertexArray,triangleDataLength=10,vertexOffset=0,colorOffset=4,uvOffset=8){this.#vertexSize=vertexArray.BYTES_PER_ELEMENT*triangleDataLength;this.#vertexOffset=vertexArray.BYTES_PER_ELEMENT*vertexOffset;this.#colorOffset=vertexArray.BYTES_PER_ELEMENT*colorOffset;this.#uvOffset=vertexArray.BYTES_PER_ELEMENT*uvOffset;this.#vertexCount=vertexArray.byteLength/this.#vertexSize}get vertexSize(){return this.#vertexSize}get vertexOffset(){return this.#vertexOffset}get colorOffset(){return this.#colorOffset}get uvOffset(){return this.#uvOffset}get vertexCount(){return this.#vertexCount}}class ShaderType{static VERTEX=1;static COMPUTE=2;static FRAGMENT=3}class Coordinate{#x;#y;#z;#value;constructor(x=0,y=0,z=0){this.#x=x;this.#y=y;this.#z=z;this.#value=[x,y,z]}set x(value){this.#x=value;this.#value[0]=value}set y(value){this.#y=value;this.#value[1]=value}set z(value){this.#z=value;this.#value[2]=value}get x(){return this.#x}get y(){return this.#y}get z(){return this.#z}get value(){return this.#value}set(x,y,z){this.#x=x;this.#y=y;this.#z=z;this.#value[0]=x;this.#value[1]=y;this.#value[2]=z}}class RGBAColor{#value;constructor(r=0,g=0,b=0,a=1){if(r>1&&g>1&&b>1){r/=255;g/=255;b/=255;if(a>1){a/=255}}this.#value=[r,g,b,a]}set r(value){this.#value[0]=value}set g(value){this.#value[1]=value}set b(value){this.#value[2]=value}set a(value){this.#value[3]=value}get r(){return this.#value[0]}get g(){return this.#value[1]}get b(){return this.#value[2]}get a(){return this.#value[3]}get value(){return this.#value}get brightness(){let[r,g,b,a]=this.#value;return .2126*r+.7152*g+.0722*b}set brightness(value){this.#value=[value,value,value,1]}set(r,g,b,a){this.#value=[r,g,b,a]}setColor(color){this.#value=[color.r,color.g,color.b,color.a]}add(color){let[r,g,b,a]=this.#value;this.#value=[r+color.r,g+color.g,b+color.b,a+color.a]}blend(color){let[r0,g0,b0,a0]=this.#value;let[r1,b1,g1,a1]=color.value;let a01=(1-a0)*a1+a0;let r01=((1-a0)*a1*r1+a0*r0)/a01;let g01=((1-a0)*a1*g1+a0*g0)/a01;let b01=((1-a0)*a1*b1+a0*b0)/a01;this.#value=[r01,g01,b01,a01]}additive(color){let base=this.#value;let added=color.value;let mix=[];mix[3]=1-(1-added[3])*(1-base[3]);mix[0]=Math.round(added[0]*added[3]/mix[3]+base[0]*base[3]*(1-added[3])/mix[3]);mix[1]=Math.round(added[1]*added[3]/mix[3]+base[1]*base[3]*(1-added[3])/mix[3]);mix[2]=Math.round(added[2]*added[3]/mix[3]+base[2]*base[3]*(1-added[3])/mix[3]);this.#value=mix}equal(color){return this.#value[0]==color.r&&this.#value[1]==color.g&&this.#value[2]==color.b&&this.#value[3]==color.a}static average(colors){let r=0,g=0,b=0;for(let index=0;index<colors.length;index++){const color=colors[index];r+=color.r*color.r;g+=color.g*color.g;b+=color.b*color.b}return new RGBAColor(Math.sqrt(r/colors.length),Math.sqrt(g/colors.length),Math.sqrt(b/colors.length))}static difference(c1,c2){let r=0;let g=0;let b=0;if(c1&&!c1.isNull()&&c2&&!c2.isNull()){const{r:r1,g:g1,b:b1}=c1;const{r:r2,g:g2,b:b2}=c2;r=r1-r2;g=g1-g2;b=b1-b2}return new RGBAColor(r,g,b)}isNull(){const[r,g,b,a]=this.#value;return!(isNaN(r)&&isNaN(g)&&isNaN(b)&&isNaN(a))}static colorRGBEuclideanDistance(c1,c2){return Math.sqrt(Math.pow(c1.r-c2.r,2)+Math.pow(c1.g-c2.g,2)+Math.pow(c1.b-c2.b,2))}euclideanDistance(color){const[r,g,b]=this.#value;return Math.sqrt(Math.pow(r-color.r,2)+Math.pow(g-color.g,2)+Math.pow(b-color.b,2))}static getClosestColorInPalette(color,palette){if(!palette){throw"Palette should be an array of `RGBA`s"}let distance=100;let selectedColor=null;palette.forEach(paletteColor=>{let currentDistance=color.euclideanDistance(paletteColor);if(currentDistance<distance){selectedColor=paletteColor;distance=currentDistance}});return selectedColor}}class Clock{#time=0;#oldTime=0;#delta=0;constructor(){}get time(){return this.#time}get delta(){return this.#delta}#now(){return(typeof performance==="undefined"?Date:performance).now()}getDelta(){this.#delta=0;const newTime=this.#now();this.#delta=(newTime-this.#oldTime)/1e3;this.#oldTime=newTime;this.#time+=this.#delta;return this.#delta}}const defaultStructs=`

struct Fragment {
    @builtin(position) position: vec4<f32>,
    @location(0) color: vec4<f32>,
    @location(1) uv: vec2<f32>,
    @location(2) ratio: vec2<f32>,
    @location(3) uvr: vec2<f32>,
    @location(4) mouse: vec2<f32>
}

struct Sound {
    data: array<f32, 2048>,
    //play
    //dataLength
    //duration
    //currentPosition
}

struct Event {
    updated: u32,
    data: array<f32>
}
`;const defaultVertexBody=`
fn defaultVertexBody(position: vec4<f32>, color: vec4<f32>, uv: vec2<f32>) -> Fragment {
    var result: Fragment;

    let ratioX = params.screen.x / params.screen.y;
    let ratioY = 1. / ratioX / (params.screen.y / params.screen.x);
    result.ratio = vec2(ratioX, ratioY);
    result.position = vec4<f32>(position);
    result.color = vec4<f32>(color);
    result.uv = uv;
    result.uvr = vec2(uv.x * result.ratio.x, uv.y);
    result.mouse = vec2(params.mouse.x / params.screen.x, params.mouse.y / params.screen.y);
    result.mouse = result.mouse * vec2(1.,-1.) - vec2(0., -1.); // flip and move up

    return result;
}
`;const size_4_align_4={size:4,align:4};const size_8_align_8={size:8,align:8};const size_12_align_16={size:12,align:16};const size_16_align_16={size:16,align:16};const size_16_align_8={size:16,align:8};const size_32_align_8={size:32,align:8};const size_24_align_16={size:24,align:16};const size_48_align_16={size:48,align:16};const size_32_align_16={size:32,align:16};const size_64_align_16={size:64,align:16};const typeSizes={"bool":size_4_align_4,"f32":size_4_align_4,"i32":size_4_align_4,"u32":size_4_align_4,"vec2<bool>":size_8_align_8,"vec2<f32>":size_8_align_8,"vec2<i32>":size_8_align_8,"vec2<u32>":size_8_align_8,"vec2f":size_8_align_8,"vec2i":size_8_align_8,"vec2u":size_8_align_8,"vec3<bool>":size_12_align_16,"vec3<f32>":size_12_align_16,"vec3<i32>":size_12_align_16,"vec3<u32>":size_12_align_16,"vec3f":size_12_align_16,"vec3i":size_12_align_16,"vec3u":size_12_align_16,"vec4<bool>":size_16_align_16,"vec4<f32>":size_16_align_16,"vec4<i32>":size_16_align_16,"vec4<u32>":size_16_align_16,"mat2x2<f32>":size_16_align_8,"mat2x3<f32>":size_32_align_8,"mat2x4<f32>":size_32_align_8,"mat3x2<f32>":size_24_align_16,"mat3x3<f32>":size_48_align_16,"mat3x4<f32>":size_48_align_16,"mat4x2<f32>":size_32_align_16,"mat4x3<f32>":size_64_align_16,"mat4x4<f32>":size_64_align_16,"vec4f":size_16_align_16,"vec4i":size_16_align_16,"vec4u":size_16_align_16,"mat2x2f":size_16_align_8,"mat2x3f":size_32_align_8,"mat2x4f":size_32_align_8,"mat3x2f":size_24_align_16,"mat3x3f":size_48_align_16,"mat3x4f":size_48_align_16,"mat4x2f":size_32_align_16,"mat4x3f":size_64_align_16,"mat4x4f":size_64_align_16};const removeCommentsRE=/^(?:(?!\/\/|\/*.*\/).|\n)+/gim;const getStructNameRE=/struct\s+?(\w+)\s*{[^}]+}\n?/g;const insideStructRE=/struct\s+?\w+\s*{([^}]+)}\n?/g;const arrayTypeAndAmountRE=/\s*<\s*([^,]+)\s*,?\s*(\d+)?\s*>/g;const arrayIntegrityRE=/\s*(array\s*<\s*\w+\s*(?:,\s*\d+)?\s*>)\s*,?/g;function removeComments(value){const matches=value.matchAll(removeCommentsRE);let result="";for(const match of matches){const captured=match[0];result+=captured}return result}function getInsideStruct(value){const matches=value.matchAll(insideStructRE);let lines=null;for(const match of matches){lines=match[1].split("\n");lines=lines.map(element=>element.trim()).filter(e=>e!=="")}return lines}function getStructDataByName(value){const matches=value.matchAll(getStructNameRE);let result=new Map;for(const match of matches){const captured=match[0];const name=match[1];const lines=getInsideStruct(captured);const types=lines.map(l=>{const right=l.split(":")[1];let type="";if(isArray(right)){const arrayMatch=right.matchAll(arrayIntegrityRE);type=arrayMatch.next().value[1]}else{type=right.split(",")[0].trim()}return type});const names=lines.map(l=>{const left=l.split(":")[0];let name="";name=left.split(",")[0].trim();return name});result.set(name,{captured,lines,types,unique_types:[...new Set(types)],names})}return result}function getArrayTypeAndAmount(value){const matches=value.matchAll(arrayTypeAndAmountRE);let result=[];for(const match of matches){const type=match[1];const amount=match[2];result.push({type,amount:Number(amount)})}return result}function getPadding(bytes,aligment,nextTypeDataSize){const nextMultiple=bytes+aligment-1&~(aligment-1);const needsPadding=bytes+nextTypeDataSize>nextMultiple;let padAmount=0;if(needsPadding){padAmount=nextMultiple-bytes}return padAmount}function isArray(value){return value.indexOf("array")!=-1}function getArrayAlign(structName,structData){const[d]=getArrayTypeAndAmount(structName);const t=typeSizes[d.type]||structData.get(d.type);if(!t){throw new Error(`${d.type} type has not been declared previously`)}return t.align||t.maxAlign}function getArrayTypeData(currentType,structData){const[d]=getArrayTypeAndAmount(currentType);if(!d){throw`${currentType} seems to have an error, maybe a wrong amount?`}if(d.amount==0){throw new Error(`${currentType} has an amount of 0`)}let currentTypeData={size:16,align:16};if(!!d.amount){const t=typeSizes[d.type];if(t){currentTypeData={size:t.align*d.amount,align:t.align}}else{const sd=structData.get(d.type);if(sd){currentTypeData={size:sd.bytes*d.amount,align:sd.maxAlign}}}}else{const t=typeSizes[d.type]||structData.get(d.type);currentTypeData={size:t.size||t.bytes,align:t.maxAlign}}return currentTypeData}const dataSize=value=>{const noCommentsValue=removeComments(value);const structData=getStructDataByName(noCommentsValue);for(const[structDatumKey,structDatum]of structData){structDatum.unique_types.forEach(ut=>{let maxAlign=structDatum.maxAlign||0;let align=0;if(!typeSizes[ut]){if(isArray(ut)){align=getArrayAlign(ut,structData)}else{const sd=structData.get(ut);align=sd.maxAlign}}else{align=typeSizes[ut].align}maxAlign=align>maxAlign?align:maxAlign;structDatum.maxAlign=maxAlign});let byteCounter=0;structDatum.types.forEach((t,i)=>{const name=structDatum.names[i];const currentType=t;const nextType=structDatum.types[i+1];let currentTypeData=typeSizes[currentType];let nextTypeData=typeSizes[nextType];structDatum.paddings=structDatum.paddings||{};if(!currentTypeData){if(currentType){if(isArray(currentType)){currentTypeData=getArrayTypeData(currentType,structData)}else{const sd=structData.get(currentType);if(sd){currentTypeData={size:sd.bytes,align:sd.maxAlign}}}}}if(!nextTypeData){if(nextType){if(isArray(nextType)){nextTypeData=getArrayTypeData(nextType,structData)}else{const sd=structData.get(nextType);if(sd){nextTypeData={size:sd.bytes,align:sd.maxAlign}}}}}if(!!currentTypeData){byteCounter+=currentTypeData.size;if(currentTypeData.size===structDatum.maxAlign||!nextType){return}}if(!!nextTypeData){const padAmount=getPadding(byteCounter,structDatum.maxAlign,nextTypeData.size);if(padAmount){structDatum.paddings[name]=padAmount/4;byteCounter+=padAmount}}});const padAmount=getPadding(byteCounter,structDatum.maxAlign,16);if(padAmount){structDatum.paddings[""]=padAmount/4;byteCounter+=padAmount}structDatum.bytes=byteCounter}return structData};async function loadImage(src){return new Promise((resolve,reject)=>{const img=new Image;img.src=src;img.onload=()=>resolve(img);img.onerror=err=>reject(err)})}function strToCodes(s){return Array.from(s).map(c=>c.charCodeAt(0))}function sprite(atlas,ctx,index,size,finalIndex){const{width}=atlas;const numColumns=width/size.x;const x=index%numColumns;const y=Math.floor(index/numColumns);ctx.drawImage(atlas,x*size.x,y*size.y,size.x,size.y,size.x*finalIndex,0,size.x,size.y)}function strToImage(str,atlasImg,size,offset=0){const chars=strToCodes(str);const canvas=document.createElement("canvas");canvas.width=chars.length*size.x;canvas.height=size.y;const ctx=canvas.getContext("2d");chars.forEach((c,i)=>sprite(atlasImg,ctx,c+offset,size,i));return canvas.toDataURL("image/png")}class UniformsArray extends Array{#buffer=null;constructor(...elements){super(...elements)}get buffer(){return this.#buffer}set buffer(v){this.#buffer=v}}class LayersArray extends Array{#buffer=null;#shaderType=null;constructor(...elements){super(...elements)}get buffer(){return this.#buffer}set buffer(v){this.#buffer=v}get shaderType(){return this.#shaderType}set shaderType(v){this.#shaderType=v}}class Points{#canvasId=null;#canvas=null;#device=null;#context=null;#presentationFormat=null;#renderPasses=null;#postRenderPasses=[];#vertexBufferInfo=null;#buffer=null;#internal=false;#presentationSize=null;#depthTexture=null;#vertexArray=[];#numColumns=1;#numRows=1;#commandsFinished=[];#renderPassDescriptor=null;#uniforms=new UniformsArray;#storage=[];#readStorage=[];#samplers=[];#textures2d=[];#texturesToCopy=[];#textures2dArray=[];#texturesExternal=[];#texturesStorage2d=[];#bindingTextures=[];#layers=new LayersArray;#originalCanvasWidth=null;#originalCanvasHeigth=null;#clock=new Clock;#time=0;#delta=0;#epoch=0;#mouseX=0;#mouseY=0;#mouseDown=false;#mouseClick=false;#mouseWheel=false;#mouseDelta=[0,0];#fullscreen=false;#fitWindow=false;#lastFitWindow=false;#sounds=[];#events=new Map;#events_ids=0;#dataSize=null;constructor(canvasId){this.#canvasId=canvasId;this.#canvas=document.getElementById(this.#canvasId);if(this.#canvasId){this.#canvas.addEventListener("click",e=>{this.#mouseClick=true});this.#canvas.addEventListener("mousemove",this.#onMouseMove,{passive:true});this.#canvas.addEventListener("mousedown",e=>{this.#mouseDown=true});this.#canvas.addEventListener("mouseup",e=>{this.#mouseDown=false});this.#canvas.addEventListener("wheel",e=>{this.#mouseWheel=true;this.#mouseDelta=[e.deltaX,e.deltaY]},{passive:true});this.#originalCanvasWidth=this.#canvas.clientWidth;this.#originalCanvasHeigth=this.#canvas.clientHeight;window.addEventListener("resize",this.#resizeCanvasToFitWindow,false);document.addEventListener("fullscreenchange",e=>{this.#fullscreen=!!document.fullscreenElement;if(!this.#fullscreen&&!this.#fitWindow){this.#resizeCanvasToDefault()}if(!this.#fullscreen){this.fitWindow=this.#lastFitWindow}})}}#resizeCanvasToFitWindow=()=>{if(this.#fitWindow){const{offsetWidth,offsetHeight}=this.#canvas.parentNode;this.#canvas.width=offsetWidth;this.#canvas.height=offsetHeight;this.#setScreenSize()}};#resizeCanvasToDefault=()=>{this.#canvas.width=this.#originalCanvasWidth;this.#canvas.height=this.#originalCanvasHeigth;this.#setScreenSize()};#setScreenSize=()=>{this.#presentationSize=[this.#canvas.clientWidth,this.#canvas.clientHeight];this.#context.configure({device:this.#device,format:this.#presentationFormat,width:this.#canvas.clientWidth,height:this.#canvas.clientHeight,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});this.#depthTexture=this.#device.createTexture({size:this.#presentationSize,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});this.#textures2d.forEach(texture2d=>{if(!texture2d.imageTexture&&texture2d.texture){this.#createTextureBindingToCopy(texture2d)}})};#onMouseMove=e=>{const rect=this.#canvas.getBoundingClientRect();this.#mouseX=e.clientX-rect.left;this.#mouseY=e.clientY-rect.top};addUniform(name,value,structName){if(structName&&isArray(structName)){throw`${structName} is an array, which is currently not supported for Uniforms.`}if(this.#nameExists(this.#uniforms,name)){return}this.#uniforms.push({name:name,value:value,type:structName,size:null,internal:this.#internal})}updateUniform(name,value){const variable=this.#uniforms.find(v=>v.name===name);if(!variable){throw"`updateUniform()` can't be called without first `addUniform()`."}variable.value=value}setUniform(name,value,structName=null){let uniformToUpdate=this.#nameExists(this.#uniforms,name);if(uniformToUpdate&&structName){throw"`setUniform()` can't set the structName of an already defined uniform."}if(uniformToUpdate){uniformToUpdate.value=value;return}if(structName&&isArray(structName)){throw`${structName} is an array, which is currently not supported for Uniforms.`}const uniform={name:name,value:value,type:structName,size:null,internal:this.#internal};this.#uniforms.push(uniform);return uniform}updateUniforms(arr){arr.forEach(uniform=>{const variable=this.#uniforms.find(v=>v.name===uniform.name);if(!variable){throw"`updateUniform()` can't be called without first `addUniform()`."}variable.value=uniform.value})}addStorage(name,structName,read,shaderType,arrayData){if(this.#nameExists(this.#storage,name)){return}this.#storage.push({mapped:!!arrayData,name:name,structName:structName,shaderType:shaderType,read:read,buffer:null,internal:this.#internal})}setStorage(name,structName,read,shaderType,arrayData){if(this.#nameExists(this.#storage,name)){throw`\`setStorage()\` You have already defined \`${name}\``}const storage={mapped:!!arrayData,name:name,structName:structName,shaderType:shaderType,read:read,buffer:null,internal:this.#internal};this.#storage.push(storage);return storage}addStorageMap(name,arrayData,structName,read,shaderType){if(this.#nameExists(this.#storage,name)){return}this.#storage.push({mapped:true,name:name,structName:structName,shaderType:shaderType,array:arrayData,buffer:null,read:read,internal:this.#internal})}updateStorageMap(name,arrayData){const variable=this.#storage.find(v=>v.name===name);if(!variable){throw"`updateStorageMap()` can't be called without first `addStorageMap()`."}variable.array=arrayData}setStorageMap(name,arrayData,structName,read=false,shaderType=null){const storageToUpdate=this.#nameExists(this.#storage,name);if(storageToUpdate){storageToUpdate.array=arrayData;return storageToUpdate}const storage={mapped:true,name:name,structName:structName,shaderType:shaderType,array:arrayData,buffer:null,read:read,internal:this.#internal};this.#storage.push(storage);return storage}async readStorage(name){let storageItem=this.#readStorage.find(storageItem=>storageItem.name===name);let arrayBuffer=null;let arrayBufferCopy=null;if(storageItem){await storageItem.buffer.mapAsync(GPUMapMode.READ);arrayBuffer=storageItem.buffer.getMappedRange();arrayBufferCopy=new Float32Array(arrayBuffer.slice(0));storageItem.buffer.unmap()}return arrayBufferCopy}addLayers(numLayers,shaderType){for(let layerIndex=0;layerIndex<numLayers;layerIndex++){this.#layers.shaderType=shaderType;this.#layers.push({name:`layer${layerIndex}`,size:this.#canvas.width*this.#canvas.height,structName:"vec4<f32>",structSize:16,array:null,buffer:null,internal:this.#internal})}}setLayers(numLayers,shaderType){for(let layerIndex=0;layerIndex<numLayers;layerIndex++){this.#layers.shaderType=shaderType;this.#layers.push({name:`layer${layerIndex}`,size:this.#canvas.width*this.#canvas.height,structName:"vec4<f32>",structSize:16,array:null,buffer:null,internal:this.#internal})}}#nameExists(arrayOfObjects,name){return arrayOfObjects.find(obj=>obj.name==name)}addSampler(name,descriptor,shaderType){if("sampler"==name){throw"`name` can not be sampler since is a WebGPU keyword"}if(this.#nameExists(this.#samplers,name)){return}descriptor=descriptor||{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"};this.#samplers.push({name:name,descriptor:descriptor,shaderType:shaderType,resource:null,internal:this.#internal})}setSampler(name,descriptor,shaderType){if("sampler"==name){throw"setSampler: `name` can not be sampler since is a WebGPU keyword."}if(this.#nameExists(this.#samplers,name)){throw`setSampler: \`${name}\` already exists.`}descriptor=descriptor||{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"};const sampler={name:name,descriptor:descriptor,shaderType:shaderType,resource:null,internal:this.#internal};this.#samplers.push(sampler);return sampler}addTexture2d(name,copyCurrentTexture,shaderType,renderPassIndex){if(this.#nameExists(this.#textures2d,name)){return}this.#textures2d.push({name:name,copyCurrentTexture:copyCurrentTexture,shaderType:shaderType,texture:null,renderPassIndex:renderPassIndex,internal:this.#internal})}setTexture2d(name,copyCurrentTexture,shaderType,renderPassIndex){if(this.#nameExists(this.#textures2d,name)){throw`setTexture2d: \`${name}\` already exists.`}const texture2d={name:name,copyCurrentTexture:copyCurrentTexture,shaderType:shaderType,texture:null,renderPassIndex:renderPassIndex,internal:this.#internal};this.#textures2d.push(texture2d);return texture2d}copyTexture(nameTextureA,nameTextureB){const texture2d_A=this.#nameExists(this.#textures2d,nameTextureA);const texture2d_B=this.#nameExists(this.#textures2d,nameTextureB);if(!(texture2d_A&&texture2d_B)){console.error("One of the textures does not exist.")}const a=texture2d_A.texture;const cubeTexture=this.#device.createTexture({size:[a.width,a.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});texture2d_B.texture=cubeTexture;this.#texturesToCopy.push({a,b:texture2d_B.texture})}async addTextureImage(name,path,shaderType){if(this.#nameExists(this.#textures2d,name)){return}const response=await fetch(path);const blob=await response.blob();const imageBitmap=await createImageBitmap(blob);this.#textures2d.push({name:name,copyCurrentTexture:false,shaderType:shaderType,texture:null,imageTexture:{bitmap:imageBitmap},internal:this.#internal})}async updateTextureImage(name,path,shaderType){if(!this.#nameExists(this.#textures2d,name)){console.warn("image can not be updated");return}const response=await fetch(path);const blob=await response.blob();const imageBitmap=await createImageBitmap(blob);const texture2d=this.#textures2d.filter(obj=>obj.name==name)[0];texture2d.imageTexture.bitmap=imageBitmap;const cubeTexture=this.#device.createTexture({size:[imageBitmap.width,imageBitmap.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});this.#device.queue.copyExternalImageToTexture({source:imageBitmap},{texture:cubeTexture},[imageBitmap.width,imageBitmap.height]);texture2d.texture=cubeTexture}async setTextureImage(name,path,shaderType=null){const texture2dToUpdate=this.#nameExists(this.#textures2d,name);const response=await fetch(path);const blob=await response.blob();const imageBitmap=await createImageBitmap(blob);if(texture2dToUpdate){if(shaderType){throw"`setTextureImage()` the param `shaderType` should not be updated after its creation."}texture2dToUpdate.imageTexture.bitmap=imageBitmap;const cubeTexture=this.#device.createTexture({size:[imageBitmap.width,imageBitmap.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});this.#device.queue.copyExternalImageToTexture({source:imageBitmap},{texture:cubeTexture},[imageBitmap.width,imageBitmap.height]);texture2dToUpdate.texture=cubeTexture;return texture2dToUpdate}const texture2d={name:name,copyCurrentTexture:false,shaderType:shaderType,texture:null,imageTexture:{bitmap:imageBitmap},internal:this.#internal};this.#textures2d.push(texture2d);return texture2d}async setTextureString(name,text,path,size,offset=0,shaderType=null){const atlas=await loadImage(path);const textImg=strToImage(text,atlas,size,offset);return this.setTextureImage(name,textImg,shaderType)}async setTextureImageArray(name,paths,shaderType){if(this.#nameExists(this.#textures2dArray,name)){return}const imageBitmaps=[];for await(const path of paths){console.log(path);const response=await fetch(path);const blob=await response.blob();imageBitmaps.push(await createImageBitmap(blob))}this.#textures2dArray.push({name:name,copyCurrentTexture:false,shaderType:shaderType,texture:null,imageTextures:{bitmaps:imageBitmaps},internal:this.#internal})}async addTextureVideo(name,path,shaderType){if(this.#nameExists(this.#texturesExternal,name)){return}const video=document.createElement("video");video.loop=true;video.autoplay=true;video.muted=true;video.src=new URL(path,import.meta.url).toString();await video.play();this.#texturesExternal.push({name:name,shaderType:shaderType,video:video,internal:this.#internal})}async setTextureVideo(name,path,shaderType){if(this.#nameExists(this.#texturesExternal,name)){throw`setTextureVideo: ${name} already exists.`}const video=document.createElement("video");video.loop=true;video.autoplay=true;video.muted=true;video.src=new URL(path,import.meta.url).toString();await video.play();const textureExternal={name:name,shaderType:shaderType,video:video,internal:this.#internal};this.#texturesExternal.push(textureExternal);return textureExternal}async addTextureWebcam(name,shaderType){if(this.#nameExists(this.#texturesExternal,name)){return}const video=document.createElement("video");video.muted=true;if(navigator.mediaDevices.getUserMedia){await navigator.mediaDevices.getUserMedia({video:true}).then(async function(stream){video.srcObject=stream;await video.play()}).catch(function(err){console.log(err)})}this.#texturesExternal.push({name:name,shaderType:shaderType,video:video,internal:this.#internal})}async setTextureWebcam(name,shaderType){if(this.#nameExists(this.#texturesExternal,name)){throw`setTextureWebcam: ${name} already exists.`}const video=document.createElement("video");video.muted=true;if(navigator.mediaDevices.getUserMedia){await navigator.mediaDevices.getUserMedia({video:true}).then(async function(stream){video.srcObject=stream;await video.play()}).catch(function(err){console.log(err)})}const textureExternal={name:name,shaderType:shaderType,video:video,internal:this.#internal};this.#texturesExternal.push(textureExternal);return textureExternal}addAudio(name,path,volume,loop,autoplay){const audio=new Audio(path);audio.volume=volume;audio.autoplay=autoplay;audio.loop=loop;const sound={name:name,path:path,audio:audio,analyser:null,data:null};const audioContext=new AudioContext;let resume=_=>{audioContext.resume()};if(audioContext.state==="suspended"){document.body.addEventListener("touchend",resume,false);document.body.addEventListener("click",resume,false)}const source=audioContext.createMediaElementSource(audio);const analyser=audioContext.createAnalyser();analyser.fftSize=2048;source.connect(analyser);analyser.connect(audioContext.destination);const bufferLength=analyser.fftSize;const data=new Uint8Array(bufferLength);analyser.getByteFrequencyData(data);this.setStorageMap(name,data,"Sound");this.setUniform(`${name}Length`,analyser.frequencyBinCount);sound.analyser=analyser;sound.data=data;this.#sounds.push(sound);return audio}setAudio(name,path,volume,loop,autoplay){const audio=new Audio(path);audio.volume=volume;audio.autoplay=autoplay;audio.loop=loop;const sound={name:name,path:path,audio:audio,analyser:null,data:null};const audioContext=new AudioContext;let resume=_=>{audioContext.resume()};if(audioContext.state==="suspended"){document.body.addEventListener("touchend",resume,false);document.body.addEventListener("click",resume,false)}const source=audioContext.createMediaElementSource(audio);const analyser=audioContext.createAnalyser();analyser.fftSize=2048;source.connect(analyser);analyser.connect(audioContext.destination);const bufferLength=analyser.fftSize;const data=new Uint8Array(bufferLength);analyser.getByteFrequencyData(data);this.setStorageMap(name,data,"Sound");this.setUniform(`${name}Length`,analyser.frequencyBinCount);sound.analyser=analyser;sound.data=data;this.#sounds.push(sound);return audio}setTextureStorage2d(name,shaderType){if(this.#nameExists(this.#texturesStorage2d,name)){throw`setTextureStorage2d: ${name} already exists.`}const texturesStorage2d={name:name,shaderType:shaderType,texture:null,internal:this.#internal};this.#texturesStorage2d.push(texturesStorage2d);return texturesStorage2d}addBindingTexture(computeName,fragmentName,size){this.#bindingTextures.push({compute:{name:computeName,shaderType:ShaderType.COMPUTE},fragment:{name:fragmentName,shaderType:ShaderType.FRAGMENT},texture:null,size:size,internal:this.#internal})}setBindingTexture(computeName,fragmentName,size){const bindingTexture={compute:{name:computeName,shaderType:ShaderType.COMPUTE},fragment:{name:fragmentName,shaderType:ShaderType.FRAGMENT},texture:null,size:size,internal:this.#internal};this.#bindingTextures.push(bindingTexture);return bindingTexture}addEventListener(name,callback,structSize){let data=new Uint8Array(Array(structSize+4).fill(0));this.setStorageMap(name,data,"Event",true);this.#events.set(this.#events_ids,{id:this.#events_ids,name:name,callback:callback});++this.#events_ids}_setInternal(value){this.#internal=value}#createDynamicGroupBindings(shaderType,internal){internal=internal||false;if(!shaderType){throw"`ShaderType` is required"}const groupId=0;let dynamicGroupBindings="";let bindingIndex=0;if(this.#uniforms.length){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var <uniform> params: Params;
`;bindingIndex+=1}this.#storage.forEach(storageItem=>{let internalCheck=internal==storageItem.internal;if(!storageItem.shaderType&&internalCheck||storageItem.shaderType==shaderType&&internalCheck){let T=storageItem.structName;dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var <storage, read_write> ${storageItem.name}: ${T};
`;bindingIndex+=1}});if(this.#layers.length){if(!this.#layers.shaderType||this.#layers.shaderType==shaderType){let totalSize=0;this.#layers.forEach(layerItem=>totalSize+=layerItem.size);dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var <storage, read_write> layers: array<array<vec4<f32>, ${totalSize}>>;
`;bindingIndex+=1}}this.#samplers.forEach((sampler,index)=>{let internalCheck=internal==sampler.internal;if(!sampler.shaderType&&internalCheck||sampler.shaderType==shaderType&&internalCheck){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${sampler.name}: sampler;
`;bindingIndex+=1}});this.#texturesStorage2d.forEach((texture,index)=>{let internalCheck=internal&&texture.internal;if(!texture.shaderType&&internalCheck||texture.shaderType==shaderType&&internalCheck){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_storage_2d<rgba8unorm, write>;
`;bindingIndex+=1}});this.#textures2d.forEach((texture,index)=>{let internalCheck=internal==texture.internal;if(!texture.shaderType&&internalCheck||texture.shaderType==shaderType&&internalCheck){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_2d<f32>;
`;bindingIndex+=1}});this.#textures2dArray.forEach((texture,index)=>{let internalCheck=internal==texture.internal;if(!texture.shaderType&&internalCheck||texture.shaderType==shaderType&&internalCheck){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_2d_array<f32>;
`;bindingIndex+=1}});this.#texturesExternal.forEach(externalTexture=>{let internalCheck=internal==externalTexture.internal;if(!externalTexture.shaderType&&internalCheck||externalTexture.shaderType==shaderType&&internalCheck){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${externalTexture.name}: texture_external;
`;bindingIndex+=1}});this.#bindingTextures.forEach(bindingTexture=>{let internalCheck=internal==bindingTexture.internal;if(bindingTexture.compute.shaderType==shaderType&&internalCheck){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.compute.name}: texture_storage_2d<rgba8unorm, write>;
`;bindingIndex+=1}if(bindingTexture.fragment.shaderType==shaderType&&internalCheck){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.fragment.name}: texture_2d<f32>;
`;bindingIndex+=1}});return dynamicGroupBindings}setMeshDensity(numColumns,numRows){if(numColumns==0||numRows==0){throw"Parameters should be greater than 0"}this.#numColumns=numColumns;this.#numRows=numRows}#compileRenderPass=(renderPass,index)=>{let vertexShader=renderPass.vertexShader;let computeShader=renderPass.computeShader;let fragmentShader=renderPass.fragmentShader;let colorsVertWGSL=vertexShader;let colorsComputeWGSL=computeShader;let colorsFragWGSL=fragmentShader;let dynamicGroupBindingsVertex="";let dynamicGroupBindingsCompute="";let dynamicGroupBindingsFragment="";let dynamicStructParams="";this.#uniforms.forEach(u=>{u.type=u.type||"f32";dynamicStructParams+=`${u.name}:${u.type}, 
	`});if(this.#uniforms.length){dynamicStructParams=`struct Params {
	${dynamicStructParams}
}
`}renderPass.hasVertexShader&&(dynamicGroupBindingsVertex+=dynamicStructParams);renderPass.hasComputeShader&&(dynamicGroupBindingsCompute+=dynamicStructParams);renderPass.hasFragmentShader&&(dynamicGroupBindingsFragment+=dynamicStructParams);renderPass.hasVertexShader&&(dynamicGroupBindingsVertex+=this.#createDynamicGroupBindings(ShaderType.VERTEX,renderPass.internal));renderPass.hasComputeShader&&(dynamicGroupBindingsCompute+=this.#createDynamicGroupBindings(ShaderType.COMPUTE,renderPass.internal));dynamicGroupBindingsFragment+=this.#createDynamicGroupBindings(ShaderType.FRAGMENT,renderPass.internal);renderPass.hasVertexShader&&(colorsVertWGSL=dynamicGroupBindingsVertex+defaultStructs+defaultVertexBody+colorsVertWGSL);renderPass.hasComputeShader&&(colorsComputeWGSL=dynamicGroupBindingsCompute+defaultStructs+colorsComputeWGSL);renderPass.hasFragmentShader&&(colorsFragWGSL=dynamicGroupBindingsFragment+defaultStructs+colorsFragWGSL);console.groupCollapsed(`Render Pass ${index}`);console.groupCollapsed("VERTEX");console.log(colorsVertWGSL);console.groupEnd();if(renderPass.hasComputeShader){console.groupCollapsed("COMPUTE");console.log(colorsComputeWGSL);console.groupEnd()}console.groupCollapsed("FRAGMENT");console.log(colorsFragWGSL);console.groupEnd();console.groupEnd();renderPass.hasVertexShader&&(renderPass.compiledShaders.vertex=colorsVertWGSL);renderPass.hasComputeShader&&(renderPass.compiledShaders.compute=colorsComputeWGSL);renderPass.hasFragmentShader&&(renderPass.compiledShaders.fragment=colorsFragWGSL)};#generateDataSize=()=>{const allShaders=this.#renderPasses.map(renderPass=>{const{vertex,compute,fragment}=renderPass.compiledShaders;return vertex+compute+fragment}).join("\n");this.#dataSize=dataSize(allShaders);this.#storage.forEach(s=>{if(!s.mapped){if(isArray(s.structName)){const typeData=getArrayTypeData(s.structName,this.#dataSize);s.structSize=typeData.size}else{const d=this.#dataSize.get(s.structName)||typeSizes[s.structName];if(!d){throw`${s.structName} has not been defined.`}s.structSize=d.bytes||d.size}}})};async init(renderPasses){this.#renderPasses=renderPasses.concat(this.#postRenderPasses);this.setUniform(UniformKeys.TIME,this.#time);this.setUniform(UniformKeys.DELTA,this.#delta);this.setUniform(UniformKeys.EPOCH,this.#epoch);this.setUniform(UniformKeys.SCREEN,[0,0],"vec2f");this.setUniform(UniformKeys.MOUSE,[0,0],"vec2f");this.setUniform(UniformKeys.MOUSE_CLICK,this.#mouseClick);this.setUniform(UniformKeys.MOUSE_DOWN,this.#mouseDown);this.setUniform(UniformKeys.MOUSE_WHEEL,this.#mouseWheel);this.setUniform(UniformKeys.MOUSE_DELTA,this.#mouseDelta,"vec2f");let hasComputeShaders=this.#renderPasses.some(renderPass=>renderPass.hasComputeShader);if(!hasComputeShaders&&this.#bindingTextures.length){throw" `addBindingTexture` requires at least one Compute Shader in a `RenderPass`"}this.#renderPasses.forEach(this.#compileRenderPass);this.#generateDataSize();let adapter=null;try{adapter=await navigator.gpu.requestAdapter()}catch(err){console.log(err)}if(!adapter){return false}this.#device=await adapter.requestDevice();this.#device.lost.then(info=>{console.log(info)});if(this.#canvas!==null)this.#context=this.#canvas.getContext("webgpu");this.#presentationFormat=navigator.gpu.getPreferredCanvasFormat();if(this.#canvasId){if(this.#fitWindow){this.#resizeCanvasToFitWindow()}else{this.#resizeCanvasToDefault()}}this.#renderPassDescriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}};await this.createScreen();return true}addRenderPass(renderPass){this.#postRenderPasses.push(renderPass)}get renderPasses(){return this.#renderPasses}async createScreen(){let hasVertexAndFragmentShader=this.#renderPasses.some(renderPass=>renderPass.hasVertexAndFragmentShader);if(hasVertexAndFragmentShader){let colors=[new RGBAColor(1,0,0),new RGBAColor(0,1,0),new RGBAColor(0,0,1),new RGBAColor(1,1,0)];for(let xIndex=0;xIndex<this.#numRows;xIndex++){for(let yIndex=0;yIndex<this.#numColumns;yIndex++){const coordinate=new Coordinate(xIndex*this.#canvas.clientWidth/this.#numColumns,yIndex*this.#canvas.clientHeight/this.#numRows,.3);this.addPoint(coordinate,this.#canvas.clientWidth/this.#numColumns,this.#canvas.clientHeight/this.#numRows,colors)}}this.#createVertexBuffer(new Float32Array(this.#vertexArray))}this.#createComputeBuffers();await this.#createPipeline()}#createVertexBuffer(vertexArray){this.#vertexBufferInfo=new VertexBufferInfo(vertexArray);this.#buffer=this.#createAndMapBuffer(vertexArray,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST)}#createAndMapBuffer(data,usage,mappedAtCreation=true,size=null){const buffer=this.#device.createBuffer({mappedAtCreation:mappedAtCreation,size:size||data.byteLength,usage:usage});new Float32Array(buffer.getMappedRange()).set(data);buffer.unmap();return buffer}#createBuffer(size,usage){const buffer=this.#device.createBuffer({size:size,usage:usage});return buffer}#createParametersUniforms(){const paramsDataSize=this.#dataSize.get("Params");const paddings=paramsDataSize.paddings;const uniformsClone=JSON.parse(JSON.stringify(this.#uniforms));let arrayValues=uniformsClone.map(v=>{const padding=paddings[v.name];if(padding){if(v.value.constructor!==Array){v.value=[v.value]}for(let i=0;i<padding;i++){v.value.push(0)}}return v.value}).flat(1);const finalPadding=paddings[""];if(finalPadding){for(let i=0;i<finalPadding;i++){arrayValues.push(0)}}const values=new Float32Array(arrayValues);this.#uniforms.buffer=this.#createAndMapBuffer(values,GPUBufferUsage.UNIFORM,true,paramsDataSize.bytes)}#createComputeBuffers(){this.#createParametersUniforms();this.#storage.forEach(storageItem=>{let usage=GPUBufferUsage.STORAGE;if(storageItem.read){let readStorageItem={name:storageItem.name,size:storageItem.structSize};if(storageItem.mapped){readStorageItem={name:storageItem.name,size:storageItem.array.length}}this.#readStorage.push(readStorageItem);usage=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}storageItem.usage=usage;if(storageItem.mapped){const values=new Float32Array(storageItem.array);storageItem.buffer=this.#createAndMapBuffer(values,usage)}else{storageItem.buffer=this.#createBuffer(storageItem.structSize,usage)}});this.#readStorage.forEach(readStorageItem=>{readStorageItem.buffer=this.#device.createBuffer({size:readStorageItem.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})});if(this.#layers.length){let layersSize=0;this.#layers.forEach(layerItem=>{layersSize+=layerItem.size*layerItem.structSize});this.#layers.buffer=this.#createBuffer(layersSize,GPUBufferUsage.STORAGE)}this.#samplers.forEach(sampler=>sampler.resource=this.#device.createSampler(sampler.descriptor));this.#texturesStorage2d.forEach(textureStorage2d=>{textureStorage2d.texture=this.#device.createTexture({size:this.#presentationSize,format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST})});this.#textures2d.forEach(texture2d=>{if(texture2d.imageTexture){let cubeTexture;const imageBitmap=texture2d.imageTexture.bitmap;cubeTexture=this.#device.createTexture({label:texture2d.name,size:[imageBitmap.width,imageBitmap.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});this.#device.queue.copyExternalImageToTexture({source:imageBitmap},{texture:cubeTexture},[imageBitmap.width,imageBitmap.height]);texture2d.texture=cubeTexture}else{this.#createTextureBindingToCopy(texture2d)}});this.#textures2dArray.forEach(texture2dArray=>{if(texture2dArray.imageTextures){let cubeTexture;const imageBitmaps=texture2dArray.imageTextures.bitmaps;cubeTexture=this.#device.createTexture({size:[imageBitmaps[0].width,imageBitmaps[0].height,imageBitmaps.length],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});imageBitmaps.forEach((imageBitmap,i)=>{this.#device.queue.copyExternalImageToTexture({source:imageBitmap},{texture:cubeTexture,origin:{x:0,y:0,z:i}},[imageBitmap.width,imageBitmap.height,1])});texture2dArray.texture=cubeTexture}else{this.#createTextureBindingToCopy(texture2dArray)}});this.#texturesExternal.forEach(externalTexture=>{externalTexture.texture=this.#device.importExternalTexture({source:externalTexture.video})});this.#bindingTextures.forEach(bindingTexture=>{bindingTexture.texture=this.#device.createTexture({size:bindingTexture.size||this.#presentationSize,format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST})})}#createTextureBindingToCopy(texture2d){texture2d.texture=this.#device.createTexture({label:texture2d.name,size:this.#presentationSize,format:this.#presentationFormat,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST})}#createTextureToSize(texture2d,width,height){texture2d.texture=this.#device.createTexture({label:texture2d.name,size:[width,height],format:this.#presentationFormat,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST})}#createComputeBindGroup(){this.#renderPasses.forEach((renderPass,index)=>{if(renderPass.hasComputeShader){const entries=this.#createEntries(ShaderType.COMPUTE);if(entries.length){let bglEntries=[];entries.forEach((entry,index)=>{let bglEntry={binding:index,visibility:GPUShaderStage.COMPUTE};bglEntry[entry.type.name]={"type":entry.type.type};if(entry.type.format){bglEntry[entry.type.name].format=entry.type.format}if(entry.type.viewDimension){bglEntry[entry.type.name].viewDimension=entry.type.viewDimension}bglEntries.push(bglEntry)});renderPass.bindGroupLayout=this.#device.createBindGroupLayout({entries:bglEntries});renderPass.computeBindGroup=this.#device.createBindGroup({label:`_createComputeBindGroup 0 - ${index}`,layout:renderPass.bindGroupLayout,entries:entries})}}})}async #createPipeline(){this.#createComputeBindGroup();this.#renderPasses.forEach((renderPass,index)=>{if(renderPass.hasComputeShader){renderPass.computePipeline=this.#device.createComputePipeline({layout:this.#device.createPipelineLayout({bindGroupLayouts:[renderPass.bindGroupLayout]}),label:`_createPipeline() - ${index}`,compute:{module:this.#device.createShaderModule({code:renderPass.compiledShaders.compute}),entryPoint:"main"}})}});this.#createParams();this.#renderPasses.forEach(renderPass=>{if(renderPass.hasVertexAndFragmentShader){renderPass.renderPipeline=this.#device.createRenderPipeline({layout:this.#device.createPipelineLayout({bindGroupLayouts:[renderPass.bindGroupLayout]}),primitive:{topology:"triangle-list"},depthStencil:{depthWriteEnabled:true,depthCompare:"less",format:"depth24plus"},vertex:{module:this.#device.createShaderModule({code:renderPass.compiledShaders.vertex}),entryPoint:"main",buffers:[{arrayStride:this.#vertexBufferInfo.vertexSize,attributes:[{shaderLocation:0,offset:this.#vertexBufferInfo.vertexOffset,format:"float32x4"},{shaderLocation:1,offset:this.#vertexBufferInfo.colorOffset,format:"float32x4"},{shaderLocation:2,offset:this.#vertexBufferInfo.uvOffset,format:"float32x2"}]}]},fragment:{module:this.#device.createShaderModule({code:renderPass.compiledShaders.fragment}),entryPoint:"main",targets:[{format:this.#presentationFormat,blend:{alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},writeMask:GPUColorWrite.ALL}]}})}})}#createEntries(shaderType,internal){internal=internal||false;let entries=[];let bindingIndex=0;if(this.#uniforms.length){entries.push({binding:bindingIndex++,resource:{label:"uniform",buffer:this.#uniforms.buffer},type:{name:"buffer",type:"uniform"}})}if(this.#storage.length){this.#storage.forEach(storageItem=>{let internalCheck=internal==storageItem.internal;if(!storageItem.shaderType&&internalCheck||storageItem.shaderType==shaderType&&internalCheck){entries.push({binding:bindingIndex++,resource:{label:"storage",buffer:storageItem.buffer},type:{name:"buffer",type:"storage"}})}})}if(this.#layers.length){if(!this.#layers.shaderType||this.#layers.shaderType==shaderType){entries.push({binding:bindingIndex++,resource:{label:"layer",buffer:this.#layers.buffer},type:{name:"buffer",type:"storage"}})}}if(this.#samplers.length){this.#samplers.forEach((sampler,index)=>{let internalCheck=internal==sampler.internal;if(!sampler.shaderType&&internalCheck||sampler.shaderType==shaderType&&internalCheck){entries.push({binding:bindingIndex++,resource:sampler.resource,type:{name:"sampler",type:"filtering"}})}})}if(this.#texturesStorage2d.length){this.#texturesStorage2d.forEach((textureStorage2d,index)=>{let internalCheck=internal==textureStorage2d.internal;if(!textureStorage2d.shaderType&&internalCheck||textureStorage2d.shaderType==shaderType&&internalCheck){entries.push({label:"texture storage 2d",binding:bindingIndex++,resource:textureStorage2d.texture.createView(),type:{name:"storageTexture",type:"write-only"}})}})}if(this.#textures2d.length){this.#textures2d.forEach((texture2d,index)=>{let internalCheck=internal==texture2d.internal;if(!texture2d.shaderType&&internalCheck||texture2d.shaderType==shaderType&&internalCheck){entries.push({label:"texture 2d",binding:bindingIndex++,resource:texture2d.texture.createView(),type:{name:"texture",type:"float"}})}})}if(this.#textures2dArray.length){this.#textures2dArray.forEach((texture2dArray,index)=>{let internalCheck=internal==texture2dArray.internal;if(!texture2dArray.shaderType&&internalCheck||texture2dArray.shaderType==shaderType&&internalCheck){entries.push({label:"texture 2d array",binding:bindingIndex++,resource:texture2dArray.texture.createView({dimension:"2d-array",baseArrayLayer:0,arrayLayerCount:texture2dArray.imageTextures.bitmaps.length}),type:{name:"texture",type:"float",viewDimension:"2d-array"}})}})}if(this.#texturesExternal.length){this.#texturesExternal.forEach(externalTexture=>{let internalCheck=internal==externalTexture.internal;if(!externalTexture.shaderType&&internalCheck||externalTexture.shaderType==shaderType&&internalCheck){entries.push({label:"external texture",binding:bindingIndex++,resource:externalTexture.texture,type:{name:"externalTexture"}})}})}if(this.#bindingTextures.length){this.#bindingTextures.forEach(bindingTexture=>{let internalCheck=internal==bindingTexture.internal;if(bindingTexture.compute.shaderType==shaderType&&internalCheck){entries.push({label:"binding texture",binding:bindingIndex++,resource:bindingTexture.texture.createView(),type:{name:"storageTexture",type:"write-only",format:"rgba8unorm"}})}});this.#bindingTextures.forEach(bindingTexture=>{let internalCheck=internal==bindingTexture.internal;if(bindingTexture.fragment.shaderType==shaderType&&internalCheck){entries.push({label:"binding texture 2",binding:bindingIndex++,resource:bindingTexture.texture.createView(),type:{name:"texture",type:"float"}})}})}return entries}#createParams(){this.#renderPasses.forEach(renderPass=>{const entries=this.#createEntries(ShaderType.FRAGMENT,renderPass.internal);if(entries.length){let bglEntries=[];entries.forEach((entry,index)=>{let bglEntry={binding:index,visibility:GPUShaderStage.FRAGMENT};bglEntry[entry.type.name]={"type":entry.type.type};if(entry.type.viewDimension){bglEntry[entry.type.name].viewDimension=entry.type.viewDimension}if(entry.type.type=="uniform"){bglEntry.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}bglEntries.push(bglEntry)});renderPass.bindGroupLayout=this.#device.createBindGroupLayout({entries:bglEntries});renderPass.uniformBindGroup=this.#device.createBindGroup({label:"_createParams() 0",layout:renderPass.bindGroupLayout,entries:entries})}})}async update(){if(!this.#canvas||!this.#device)return;this.#delta=this.#clock.getDelta();this.#time=this.#clock.time;this.#epoch=+new Date/1e3;this.setUniform(UniformKeys.TIME,this.#time);this.setUniform(UniformKeys.DELTA,this.#delta);this.setUniform(UniformKeys.EPOCH,this.#epoch);this.setUniform(UniformKeys.SCREEN,[this.#canvas.width,this.#canvas.height]);this.setUniform(UniformKeys.MOUSE,[this.#mouseX,this.#mouseY]);this.setUniform(UniformKeys.MOUSE_CLICK,this.#mouseClick);this.setUniform(UniformKeys.MOUSE_DOWN,this.#mouseDown);this.setUniform(UniformKeys.MOUSE_WHEEL,this.#mouseWheel);this.setUniform(UniformKeys.MOUSE_DELTA,this.#mouseDelta);this.#createParametersUniforms();this.#storage.forEach(storageItem=>{if(storageItem.mapped){const values=new Float32Array(storageItem.array);storageItem.buffer=this.#createAndMapBuffer(values,storageItem.usage)}});this.#sounds.forEach(sound=>{sound.analyser?.getByteFrequencyData(sound.data)});this.#texturesExternal.forEach(externalTexture=>{externalTexture.texture=this.#device.importExternalTexture({source:externalTexture.video});if("requestVideoFrameCallback"in externalTexture.video){externalTexture.video.requestVideoFrameCallback(()=>{})}});this.#createComputeBindGroup();let commandEncoder=this.#device.createCommandEncoder();this.#renderPasses.forEach(renderPass=>{if(renderPass.hasComputeShader){const passEncoder=commandEncoder.beginComputePass();passEncoder.setPipeline(renderPass.computePipeline);if(this.#uniforms.length){passEncoder.setBindGroup(0,renderPass.computeBindGroup)}passEncoder.dispatchWorkgroups(renderPass.workgroupCountX,renderPass.workgroupCountY,renderPass.workgroupCountZ);passEncoder.end()}});this.#renderPassDescriptor.colorAttachments[0].view=this.#context.getCurrentTexture().createView();this.#renderPassDescriptor.depthStencilAttachment.view=this.#depthTexture.createView();const swapChainTexture=this.#context.getCurrentTexture();this.#renderPasses.forEach((renderPass,renderPassIndex)=>{if(renderPass.hasVertexAndFragmentShader){const passEncoder=commandEncoder.beginRenderPass(this.#renderPassDescriptor);passEncoder.setPipeline(renderPass.renderPipeline);this.#createParams();if(this.#uniforms.length){passEncoder.setBindGroup(0,renderPass.uniformBindGroup)}passEncoder.setVertexBuffer(0,this.#buffer);passEncoder.draw(this.#vertexBufferInfo.vertexCount);passEncoder.end();this.#textures2d.forEach(texture2d=>{if(texture2d.renderPassIndex==renderPassIndex||texture2d.renderPassIndex==null){if(texture2d.copyCurrentTexture){commandEncoder.copyTextureToTexture({texture:swapChainTexture},{texture:texture2d.texture},this.#presentationSize)}}});this.#texturesToCopy.forEach(texturePair=>{commandEncoder.copyTextureToTexture({texture:texturePair.a},{texture:texturePair.b},[texturePair.a.width,texturePair.a.height])});this.#texturesToCopy=[]}});if(this.#readStorage.length){this.#readStorage.forEach(readStorageItem=>{let storageItem=this.#storage.find(storageItem=>storageItem.name===readStorageItem.name);commandEncoder.copyBufferToBuffer(storageItem.buffer,0,readStorageItem.buffer,0,readStorageItem.buffer.size)})}this.#commandsFinished.push(commandEncoder.finish());this.#device.queue.submit(this.#commandsFinished);this.#commandsFinished=[];this.#mouseClick=false;this.#mouseWheel=false;this.#mouseDelta=[0,0];await this.read()}async read(){for(const[key,event]of this.#events){let eventRead=await this.readStorage(event.name);if(eventRead){let id=eventRead[0];if(id!=0){event.callback&&event.callback(eventRead.slice(1,-1))}}}}#getWGSLCoordinate(value,side,invert=false){const direction=invert?-1:1;const p=value/side;return(p*2-1)*direction}addPoint(coordinate,width,height,colors,useTexture=false){const{x,y,z}=coordinate;const nx=this.#getWGSLCoordinate(x,this.#canvas.width);const ny=this.#getWGSLCoordinate(y,this.#canvas.height,true);const nz=z;const nw=this.#getWGSLCoordinate(x+width,this.#canvas.width);const nh=this.#getWGSLCoordinate(y+height,this.#canvas.height);const{r:r0,g:g0,b:b0,a:a0}=colors[0];const{r:r1,g:g1,b:b1,a:a1}=colors[1];const{r:r2,g:g2,b:b2,a:a2}=colors[2];const{r:r3,g:g3,b:b3,a:a3}=colors[3];this.#vertexArray.push(+nx,+ny,nz,1,r0,g0,b0,a0,(+nx+1)*.5,(+ny+1)*.5,+nw,+ny,nz,1,r1,g1,b1,a1,(+nw+1)*.5,(+ny+1)*.5,+nw,-nh,nz,1,r3,g3,b3,a3,(+nw+1)*.5,(-nh+1)*.5,+nx,+ny,nz,1,r0,g0,b0,a0,(+nx+1)*.5,(+ny+1)*.5,+nx,-nh,nz,1,r2,g2,b2,a2,(+nx+1)*.5,(-nh+1)*.5,+nw,-nh,nz,1,r3,g3,b3,a3,(+nw+1)*.5,(-nh+1)*.5)}get canvas(){return this.#canvas}get device(){return this.#device}get context(){return this.#context}get presentationFormat(){return this.#presentationFormat}get buffer(){return this.#buffer}get fullscreen(){return this.#fullscreen}set fullscreen(value){if(value){this.#lastFitWindow=this.#fitWindow;this.fitWindow=value;this.#canvas.requestFullscreen().catch(err=>{throw`Error attempting to enable fullscreen mode: ${err.message} (${err.name})`});this.#fullscreen=true}else{document.exitFullscreen();this.#fullscreen=false;this.#resizeCanvasToDefault()}}get fitWindow(){return this.#fitWindow}set fitWindow(value){if(!this.#context){throw"fitWindow must be assigned after Points.init() call or you don't have a Canvas assigned in the constructor"}this.#fitWindow=value;if(this.#fitWindow){this.#resizeCanvasToFitWindow()}else{this.#resizeCanvasToDefault()}}}export{Points as default};
