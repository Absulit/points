/* @ts-self-types="./points.module.d.ts" */
/* @ts-self-types="./points.module.d.ts" */ function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _async_iterator(iterable) {
    var method, async, sync, retry = 2;
    for("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;){
        if (async && null != (method = iterable[async])) return method.call(iterable);
        if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
        async = "@@asyncIterator", sync = "@@iterator";
    }
    throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
    function AsyncFromSyncIteratorContinuation(r) {
        if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
        var done = r.done;
        return Promise.resolve(r.value).then(function(value) {
            return {
                value: value,
                done: done
            };
        });
    }
    return AsyncFromSyncIterator = function(s) {
        this.s = s, this.n = s.next;
    }, AsyncFromSyncIterator.prototype = {
        s: null,
        n: null,
        next: function() {
            return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
        },
        return: function(value) {
            var ret = this.s.return;
            return void 0 === ret ? Promise.resolve({
                value: value,
                done: !0
            }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
        },
        throw: function(value) {
            var thr = this.s.return;
            return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
        }
    }, new AsyncFromSyncIterator(s);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_apply_descriptor_update(receiver, descriptor) {
    if (descriptor.set) {
        if (!descriptor.get) {
            throw new TypeError("attempted to read set only private field");
        }
        if (!("__destrWrapper" in descriptor)) {
            descriptor.__destrWrapper = {
                set value (v){
                    descriptor.set.call(receiver, v);
                },
                get value () {
                    return descriptor.get.call(receiver);
                }
            };
        }
        return descriptor.__destrWrapper;
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        return descriptor;
    }
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _class_private_field_update(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "update");
    return _class_apply_descriptor_update(receiver, descriptor);
}
function _class_private_method_get(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init(obj, privateSet) {
    _check_private_redeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v1) {
            return step([
                n,
                v1
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var UniformKeys = function UniformKeys() {
    "use strict";
    _class_call_check(this, UniformKeys);
};
_define_property(UniformKeys, "TIME", 'time');
_define_property(UniformKeys, "DELTA", 'delta');
_define_property(UniformKeys, "EPOCH", 'epoch');
_define_property(UniformKeys, "SCREEN", 'screen');
_define_property(UniformKeys, "MOUSE", 'mouse');
_define_property(UniformKeys, "MOUSE_CLICK", 'mouseClick');
_define_property(UniformKeys, "MOUSE_DOWN", 'mouseDown');
_define_property(UniformKeys, "MOUSE_WHEEL", 'mouseWheel');
_define_property(UniformKeys, "MOUSE_DELTA", 'mouseDelta');
var _vertexSize = /*#__PURE__*/ new WeakMap(), _vertexOffset = /*#__PURE__*/ new WeakMap(), _colorOffset = /*#__PURE__*/ new WeakMap(), _uvOffset = /*#__PURE__*/ new WeakMap(), _vertexCount = /*#__PURE__*/ new WeakMap();
var VertexBufferInfo = /*#__PURE__*/ function() {
    "use strict";
    function VertexBufferInfo(vertexArray) {
        var triangleDataLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, vertexOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, colorOffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 4, uvOffset = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 8;
        _class_call_check(this, VertexBufferInfo);
        _class_private_field_init(this, _vertexSize, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _vertexOffset, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _colorOffset, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _uvOffset, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _vertexCount, {
            writable: true,
            value: void 0
        });
        _class_private_field_set(this, _vertexSize, vertexArray.BYTES_PER_ELEMENT * triangleDataLength); // Byte size of ONE triangle data (vertex, color, uv). (one row)
        _class_private_field_set(this, _vertexOffset, vertexArray.BYTES_PER_ELEMENT * vertexOffset);
        _class_private_field_set(this, _colorOffset, vertexArray.BYTES_PER_ELEMENT * colorOffset); // Byte offset of triangle vertex color attribute.
        _class_private_field_set(this, _uvOffset, vertexArray.BYTES_PER_ELEMENT * uvOffset);
        _class_private_field_set(this, _vertexCount, vertexArray.byteLength / _class_private_field_get(this, _vertexSize));
    }
    _create_class(VertexBufferInfo, [
        {
            key: "vertexSize",
            get: function get() {
                return _class_private_field_get(this, _vertexSize);
            }
        },
        {
            key: "vertexOffset",
            get: function get() {
                return _class_private_field_get(this, _vertexOffset);
            }
        },
        {
            key: "colorOffset",
            get: function get() {
                return _class_private_field_get(this, _colorOffset);
            }
        },
        {
            key: "uvOffset",
            get: function get() {
                return _class_private_field_get(this, _uvOffset);
            }
        },
        {
            key: "vertexCount",
            get: function get() {
                return _class_private_field_get(this, _vertexCount);
            }
        }
    ]);
    return VertexBufferInfo;
}();
var ShaderType = function ShaderType() {
    "use strict";
    _class_call_check(this, ShaderType);
};
_define_property(ShaderType, "VERTEX", 1);
_define_property(ShaderType, "COMPUTE", 2);
_define_property(ShaderType, "FRAGMENT", 3);
var _x = /*#__PURE__*/ new WeakMap(), _y = /*#__PURE__*/ new WeakMap(), _z = /*#__PURE__*/ new WeakMap(), _value = /*#__PURE__*/ new WeakMap();
var Coordinate = /*#__PURE__*/ function() {
    "use strict";
    function Coordinate() {
        var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        _class_call_check(this, Coordinate);
        _class_private_field_init(this, _x, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _y, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _z, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _value, {
            writable: true,
            value: void 0
        });
        _class_private_field_set(this, _x, x);
        _class_private_field_set(this, _y, y);
        _class_private_field_set(this, _z, z);
        _class_private_field_set(this, _value, [
            x,
            y,
            z
        ]);
    }
    _create_class(Coordinate, [
        {
            key: "x",
            get: function get() {
                return _class_private_field_get(this, _x);
            },
            set: function set(value) {
                _class_private_field_set(this, _x, value);
                _class_private_field_get(this, _value)[0] = value;
            }
        },
        {
            key: "y",
            get: function get() {
                return _class_private_field_get(this, _y);
            },
            set: function set(value) {
                _class_private_field_set(this, _y, value);
                _class_private_field_get(this, _value)[1] = value;
            }
        },
        {
            key: "z",
            get: function get() {
                return _class_private_field_get(this, _z);
            },
            set: function set(value) {
                _class_private_field_set(this, _z, value);
                _class_private_field_get(this, _value)[2] = value;
            }
        },
        {
            key: "value",
            get: function get() {
                return _class_private_field_get(this, _value);
            }
        },
        {
            key: "set",
            value: function set(x, y, z) {
                _class_private_field_set(this, _x, x);
                _class_private_field_set(this, _y, y);
                _class_private_field_set(this, _z, z);
                _class_private_field_get(this, _value)[0] = x;
                _class_private_field_get(this, _value)[1] = y;
                _class_private_field_get(this, _value)[2] = z;
            }
        }
    ]);
    return Coordinate;
}();
var _value1 = /*#__PURE__*/ new WeakMap();
var RGBAColor = /*#__PURE__*/ function() {
    "use strict";
    function RGBAColor() {
        var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
        _class_call_check(this, RGBAColor);
        _class_private_field_init(this, _value1, {
            writable: true,
            value: void 0
        });
        if (r > 1 && g > 1 && b > 1) {
            r /= 255;
            g /= 255;
            b /= 255;
            if (a > 1) {
                a /= 255;
            }
        }
        _class_private_field_set(this, _value1, [
            r,
            g,
            b,
            a
        ]);
    }
    _create_class(RGBAColor, [
        {
            key: "r",
            get: function get() {
                return _class_private_field_get(this, _value1)[0];
            },
            set: function set(value) {
                _class_private_field_get(this, _value1)[0] = value;
            }
        },
        {
            key: "g",
            get: function get() {
                return _class_private_field_get(this, _value1)[1];
            },
            set: function set(value) {
                _class_private_field_get(this, _value1)[1] = value;
            }
        },
        {
            key: "b",
            get: function get() {
                return _class_private_field_get(this, _value1)[2];
            },
            set: function set(value) {
                _class_private_field_get(this, _value1)[2] = value;
            }
        },
        {
            key: "a",
            get: function get() {
                return _class_private_field_get(this, _value1)[3];
            },
            set: function set(value) {
                _class_private_field_get(this, _value1)[3] = value;
            }
        },
        {
            key: "value",
            get: function get() {
                return _class_private_field_get(this, _value1);
            }
        },
        {
            key: "brightness",
            get: function get() {
                // #Standard
                // LuminanceA = (0.2126*R) + (0.7152*G) + (0.0722*B)
                // #Percieved A
                // LuminanceB = (0.299*R + 0.587*G + 0.114*B)
                // #Perceived B, slower to calculate
                // LuminanceC = sqrt(0.299*(R**2) + 0.587*(G**2) + 0.114*(B**2))
                var _$_class_private_field_get = _sliced_to_array(_class_private_field_get(this, _value1), 4), r = _$_class_private_field_get[0], g = _$_class_private_field_get[1], b = _$_class_private_field_get[2], a = _$_class_private_field_get[3];
                return 0.2126 * r + 0.7152 * g + 0.0722 * b;
            },
            set: function set(value) {
                _class_private_field_set(this, _value1, [
                    value,
                    value,
                    value,
                    1
                ]);
            }
        },
        {
            key: "set",
            value: function set(r, g, b, a) {
                _class_private_field_set(this, _value1, [
                    r,
                    g,
                    b,
                    a
                ]);
            }
        },
        {
            key: "setColor",
            value: function setColor(color) {
                _class_private_field_set(this, _value1, [
                    color.r,
                    color.g,
                    color.b,
                    color.a
                ]);
            }
        },
        {
            key: "add",
            value: function add(color) {
                var _$_class_private_field_get = _sliced_to_array(_class_private_field_get(this, _value1), 4), r = _$_class_private_field_get[0], g = _$_class_private_field_get[1], b = _$_class_private_field_get[2], a = _$_class_private_field_get[3];
                //this.#value = [(r + color.r)/2, (g + color.g)/2, (b + color.b)/2, (a + color.a)/2];
                //this.#value = [(r*a + color.r*color.a), (g*a + color.g*color.a), (b*a + color.b*color.a), 1];
                _class_private_field_set(this, _value1, [
                    r + color.r,
                    g + color.g,
                    b + color.b,
                    a + color.a
                ]);
            }
        },
        {
            key: "blend",
            value: function blend(color) {
                var _$_class_private_field_get = _sliced_to_array(_class_private_field_get(this, _value1), 4), r0 = _$_class_private_field_get[0], g0 = _$_class_private_field_get[1], b0 = _$_class_private_field_get[2], a0 = _$_class_private_field_get[3];
                var _color_value = _sliced_to_array(color.value, 4), r1 = _color_value[0], b1 = _color_value[1], g1 = _color_value[2], a1 = _color_value[3];
                var a01 = (1 - a0) * a1 + a0;
                var r01 = ((1 - a0) * a1 * r1 + a0 * r0) / a01;
                var g01 = ((1 - a0) * a1 * g1 + a0 * g0) / a01;
                var b01 = ((1 - a0) * a1 * b1 + a0 * b0) / a01;
                _class_private_field_set(this, _value1, [
                    r01,
                    g01,
                    b01,
                    a01
                ]);
            }
        },
        {
            key: "additive",
            value: function additive(color) {
                // https://gist.github.com/JordanDelcros/518396da1c13f75ee057
                var base = _class_private_field_get(this, _value1);
                var added = color.value;
                var mix = [];
                mix[3] = 1 - (1 - added[3]) * (1 - base[3]); // alpha
                mix[0] = Math.round(added[0] * added[3] / mix[3] + base[0] * base[3] * (1 - added[3]) / mix[3]); // red
                mix[1] = Math.round(added[1] * added[3] / mix[3] + base[1] * base[3] * (1 - added[3]) / mix[3]); // green
                mix[2] = Math.round(added[2] * added[3] / mix[3] + base[2] * base[3] * (1 - added[3]) / mix[3]); // blue
                _class_private_field_set(this, _value1, mix);
            }
        },
        {
            key: "equal",
            value: function equal(color) {
                return _class_private_field_get(this, _value1)[0] == color.r && _class_private_field_get(this, _value1)[1] == color.g && _class_private_field_get(this, _value1)[2] == color.b && _class_private_field_get(this, _value1)[3] == color.a;
            }
        },
        {
            key: "isNull",
            value: function isNull() {
                var _$_class_private_field_get = _sliced_to_array(_class_private_field_get(this, _value1), 4), r = _$_class_private_field_get[0], g = _$_class_private_field_get[1], b = _$_class_private_field_get[2], a = _$_class_private_field_get[3];
                return !(isNaN(r) && isNaN(g) && isNaN(b) && isNaN(a));
            }
        },
        {
            /**
     * Checks how close two colors are. Closest is `0`.
     * @param {RGBAColor} color : Color to check distance;
     * @returns Number distace up to `1.42` I think...
     */ key: "euclideanDistance",
            value: function euclideanDistance(color) {
                var _$_class_private_field_get = _sliced_to_array(_class_private_field_get(this, _value1), 3), r = _$_class_private_field_get[0], g = _$_class_private_field_get[1], b = _$_class_private_field_get[2];
                return Math.sqrt(Math.pow(r - color.r, 2) + Math.pow(g - color.g, 2) + Math.pow(b - color.b, 2));
            }
        }
    ], [
        {
            key: "average",
            value: function average(colors) {
                // https://sighack.com/post/averaging-rgb-colors-the-right-way
                var r = 0, g = 0, b = 0;
                for(var index = 0; index < colors.length; index++){
                    var color = colors[index];
                    //if (!color.isNull()) {
                    r += color.r * color.r;
                    g += color.g * color.g;
                    b += color.b * color.b;
                //a += color.a * color.a;
                //}
                }
                return new RGBAColor(Math.sqrt(r / colors.length), Math.sqrt(g / colors.length), Math.sqrt(b / colors.length));
            }
        },
        {
            key: "difference",
            value: function difference(c1, c2) {
                var r = 0;
                var g = 0;
                var b = 0;
                if (c1 && !c1.isNull() && c2 && !c2.isNull()) {
                    var r1 = c1.r, g1 = c1.g, b1 = c1.b;
                    var r2 = c2.r, g2 = c2.g, b2 = c2.b;
                    r = r1 - r2;
                    g = g1 - g2;
                    b = b1 - b2;
                }
                return new RGBAColor(r, g, b);
            }
        },
        {
            key: "colorRGBEuclideanDistance",
            value: function colorRGBEuclideanDistance(c1, c2) {
                return Math.sqrt(Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2));
            }
        },
        {
            key: "getClosestColorInPalette",
            value: function getClosestColorInPalette(color, palette) {
                if (!palette) {
                    throw 'Palette should be an array of `RGBA`s';
                }
                var distance = 100;
                var selectedColor = null;
                palette.forEach(function(paletteColor) {
                    var currentDistance = color.euclideanDistance(paletteColor);
                    if (currentDistance < distance) {
                        selectedColor = paletteColor;
                        distance = currentDistance;
                    }
                });
                return selectedColor;
            }
        }
    ]);
    return RGBAColor;
}();
var _time = /*#__PURE__*/ new WeakMap(), _oldTime = /*#__PURE__*/ new WeakMap(), _delta = /*#__PURE__*/ new WeakMap(), _now = /*#__PURE__*/ new WeakSet();
/**
 * To manage time and delta time,
 * based on https://github.com/mrdoob/three.js/blob/master/src/core/Clock.js
 */ var Clock = /*#__PURE__*/ function() {
    "use strict";
    function Clock() {
        _class_call_check(this, Clock);
        _class_private_method_init(this, _now);
        _class_private_field_init(this, _time, {
            writable: true,
            value: 0
        });
        _class_private_field_init(this, _oldTime, {
            writable: true,
            value: 0
        });
        _class_private_field_init(this, _delta, {
            writable: true,
            value: 0
        });
    }
    _create_class(Clock, [
        {
            key: "time",
            get: /**
     * Gets the current time, it does not calculate the time, it's calcualted
     *  when `getDelta()` is called.
     */ function get() {
                return _class_private_field_get(this, _time);
            }
        },
        {
            key: "delta",
            get: /**
     * Gets the last delta value, it does not calculate the delta, use `getDelta()`
     */ function get() {
                return _class_private_field_get(this, _delta);
            }
        },
        {
            /**
     * Calculate time since last frame
     * It also calculates `time`
     */ key: "getDelta",
            value: function getDelta() {
                _class_private_field_set(this, _delta, 0);
                var newTime = _class_private_method_get(this, _now, now).call(this);
                _class_private_field_set(this, _delta, (newTime - _class_private_field_get(this, _oldTime)) / 1000);
                _class_private_field_set(this, _oldTime, newTime);
                _class_private_field_set(this, _time, _class_private_field_get(this, _time) + _class_private_field_get(this, _delta));
                return _class_private_field_get(this, _delta);
            }
        }
    ]);
    return Clock;
}();
function now() {
    return (typeof performance === 'undefined' ? Date : performance).now();
}
var defaultStructs = "\n\nstruct Fragment {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec4<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) ratio: vec2<f32>,\n    @location(3) uvr: vec2<f32>,\n    @location(4) mouse: vec2<f32>\n}\n\nstruct Sound {\n    data: array<f32, 2048>,\n    //play\n    //dataLength\n    //duration\n    //currentPosition\n}\n\nstruct Event {\n    updated: u32,\n    data: array<f32>\n}\n";
/**
 * @type {string}
 * Default function for the Vertex shader that takes charge of automating the
 * creation of a few variables that are commonly used.
 * @param {vec4f} position
 * @param {vec4f} color
 * @param {vec2f} uv
 * @return {Fragment}
 */ var defaultVertexBody = "\nfn defaultVertexBody(position: vec4<f32>, color: vec4<f32>, uv: vec2<f32>) -> Fragment {\n    var result: Fragment;\n\n    let ratioX = params.screen.x / params.screen.y;\n    let ratioY = 1. / ratioX / (params.screen.y / params.screen.x);\n    result.ratio = vec2(ratioX, ratioY);\n    result.position = vec4<f32>(position);\n    result.color = vec4<f32>(color);\n    result.uv = uv;\n    result.uvr = vec2(uv.x * result.ratio.x, uv.y);\n    result.mouse = vec2(params.mouse.x / params.screen.x, params.mouse.y / params.screen.y);\n    result.mouse = result.mouse * vec2(1.,-1.) - vec2(0., -1.); // flip and move up\n\n    return result;\n}\n";
var size_4_align_4 = {
    size: 4,
    align: 4
};
var size_8_align_8 = {
    size: 8,
    align: 8
};
var size_12_align_16 = {
    size: 12,
    align: 16
};
var size_16_align_16 = {
    size: 16,
    align: 16
};
var size_16_align_8 = {
    size: 16,
    align: 8
};
var size_32_align_8 = {
    size: 32,
    align: 8
};
var size_24_align_16 = {
    size: 24,
    align: 16
};
var size_48_align_16 = {
    size: 48,
    align: 16
};
var size_32_align_16 = {
    size: 32,
    align: 16
};
var size_64_align_16 = {
    size: 64,
    align: 16
};
var typeSizes = {
    'bool': size_4_align_4,
    'f32': size_4_align_4,
    'i32': size_4_align_4,
    'u32': size_4_align_4,
    'vec2<bool>': size_8_align_8,
    'vec2<f32>': size_8_align_8,
    'vec2<i32>': size_8_align_8,
    'vec2<u32>': size_8_align_8,
    // 'vec2<bool>': size_8_align_8,
    'vec2f': size_8_align_8,
    'vec2i': size_8_align_8,
    'vec2u': size_8_align_8,
    'vec3<bool>': size_12_align_16,
    'vec3<f32>': size_12_align_16,
    'vec3<i32>': size_12_align_16,
    'vec3<u32>': size_12_align_16,
    // 'vec3<bool>': size_12_align_16,
    'vec3f': size_12_align_16,
    'vec3i': size_12_align_16,
    'vec3u': size_12_align_16,
    'vec4<bool>': size_16_align_16,
    'vec4<f32>': size_16_align_16,
    'vec4<i32>': size_16_align_16,
    'vec4<u32>': size_16_align_16,
    'mat2x2<f32>': size_16_align_8,
    'mat2x3<f32>': size_32_align_8,
    'mat2x4<f32>': size_32_align_8,
    'mat3x2<f32>': size_24_align_16,
    'mat3x3<f32>': size_48_align_16,
    'mat3x4<f32>': size_48_align_16,
    'mat4x2<f32>': size_32_align_16,
    'mat4x3<f32>': size_64_align_16,
    'mat4x4<f32>': size_64_align_16,
    // 'vec4<bool>': size_16_align_16,
    'vec4f': size_16_align_16,
    'vec4i': size_16_align_16,
    'vec4u': size_16_align_16,
    'mat2x2f': size_16_align_8,
    'mat2x3f': size_32_align_8,
    'mat2x4f': size_32_align_8,
    'mat3x2f': size_24_align_16,
    'mat3x3f': size_48_align_16,
    'mat3x4f': size_48_align_16,
    'mat4x2f': size_32_align_16,
    'mat4x3f': size_64_align_16,
    'mat4x4f': size_64_align_16
};
// ignore comments
var removeCommentsRE = /^(?:(?!\/\/|\/*.*\/).|\n)+/gim;
// struct name:
var getStructNameRE = /struct\s+?(\w+)\s*{[^}]+}\n?/g;
// what's inside a struct:
var insideStructRE = /struct\s+?\w+\s*{([^}]+)}\n?/g;
var arrayTypeAndAmountRE = /\s*<\s*([^,]+)\s*,?\s*(\d+)?\s*>/g;
var arrayIntegrityRE = /\s*(array\s*<\s*\w+\s*(?:,\s*\d+)?\s*>)\s*,?/g;
// you have to separete the result by splitting new lines
function removeComments(value) {
    var matches = value.matchAll(removeCommentsRE);
    var result = '';
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var match = _step.value;
            var captured = match[0];
            result += captured;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return result;
}
function getInsideStruct(value) {
    var matches = value.matchAll(insideStructRE);
    var lines = null;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var match = _step.value;
            lines = match[1].split('\n');
            lines = lines.map(function(element) {
                return element.trim();
            }).filter(function(e) {
                return e !== '';
            });
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return lines;
}
function getStructDataByName(value) {
    var matches = value.matchAll(getStructNameRE);
    var result = new Map();
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var match = _step.value;
            var captured = match[0];
            var name = match[1];
            var lines = getInsideStruct(captured);
            var types = lines.map(function(l) {
                var right = l.split(':')[1];
                var type = '';
                if (isArray(right)) {
                    var arrayMatch = right.matchAll(arrayIntegrityRE);
                    type = arrayMatch.next().value[1];
                } else {
                    type = right.split(',')[0].trim();
                }
                return type;
            });
            var names = lines.map(function(l) {
                var left = l.split(':')[0];
                var name = '';
                name = left.split(',')[0].trim();
                return name;
            });
            result.set(name, {
                captured: captured,
                lines: lines,
                types: types,
                unique_types: _to_consumable_array(new Set(types)),
                names: names
            });
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return result;
}
function getArrayTypeAndAmount(value) {
    var matches = value.matchAll(arrayTypeAndAmountRE);
    var result = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var match = _step.value;
            var type = match[1];
            var amount = match[2];
            result.push({
                type: type,
                amount: Number(amount)
            });
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return result;
}
function getPadding(bytes, aligment, nextTypeDataSize) {
    var nextMultiple = bytes + aligment - 1 & ~(aligment - 1);
    var needsPadding = bytes + nextTypeDataSize > nextMultiple;
    var padAmount = 0;
    if (needsPadding) {
        padAmount = nextMultiple - bytes;
    }
    return padAmount;
}
/**
 * Check if string has 'array' in it
 * @param {String} value
 * @returns {boolean}
 */ function isArray(value) {
    return value.indexOf('array') != -1;
}
function getArrayAlign(structName, structData) {
    var _getArrayTypeAndAmount = _sliced_to_array(getArrayTypeAndAmount(structName), 1), d = _getArrayTypeAndAmount[0];
    var t = typeSizes[d.type] || structData.get(d.type);
    if (!t) {
        throw new Error("".concat(d.type, " type has not been declared previously"));
    }
    // if it's not in typeSizes is a struct,
    //therefore probably stored in structData
    return t.align || t.maxAlign;
}
function getArrayTypeData(currentType, structData) {
    var _getArrayTypeAndAmount = _sliced_to_array(getArrayTypeAndAmount(currentType), 1), d = _getArrayTypeAndAmount[0];
    if (!d) {
        throw "".concat(currentType, " seems to have an error, maybe a wrong amount?");
    }
    if (d.amount == 0) {
        throw new Error("".concat(currentType, " has an amount of 0"));
    }
    // if is an array with no amount then use these default values
    var currentTypeData = {
        size: 16,
        align: 16
    };
    if (!!d.amount) {
        var t = typeSizes[d.type];
        if (t) {
            // if array, the size is equal to the align
            currentTypeData = {
                size: t.align * d.amount,
                align: t.align
            };
        // currentTypeData = { size: t.size * d.amount, align: t.align };
        // currentTypeData = { size: 0, align: 0 };
        } else {
            var sd = structData.get(d.type);
            if (sd) {
                currentTypeData = {
                    size: sd.bytes * d.amount,
                    align: sd.maxAlign
                };
            }
        }
    } else {
        var t1 = typeSizes[d.type] || structData.get(d.type);
        currentTypeData = {
            size: t1.size || t1.bytes,
            align: t1.maxAlign
        };
    }
    return currentTypeData;
}
var dataSize = function(value) {
    var noCommentsValue = removeComments(value);
    var structData = getStructDataByName(noCommentsValue);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        var _loop = function() {
            var _step_value = _sliced_to_array(_step.value, 2), structDatumKey = _step_value[0], structDatum = _step_value[1];
            // to obtain the higher max alignment, but this can be also calculated
            // in the next step
            structDatum.unique_types.forEach(function(ut) {
                var maxAlign = structDatum.maxAlign || 0;
                var align = 0;
                // if it doesn't exists in typeSizes is an Array or a new Struct
                if (!typeSizes[ut]) {
                    if (isArray(ut)) {
                        align = getArrayAlign(ut, structData);
                    } else {
                        var sd = structData.get(ut);
                        align = sd.maxAlign;
                    }
                } else {
                    align = typeSizes[ut].align;
                }
                maxAlign = align > maxAlign ? align : maxAlign;
                structDatum.maxAlign = maxAlign;
            });
            var byteCounter = 0;
            structDatum.types.forEach(function(t, i) {
                var name = structDatum.names[i];
                var currentType = t;
                var nextType = structDatum.types[i + 1];
                var currentTypeData = typeSizes[currentType];
                var nextTypeData = typeSizes[nextType];
                structDatum.paddings = structDatum.paddings || {};
                // if currentTypeData or nextTypeData have no data it means
                // it's a struct or an array
                // if it's a struct the data is already saved in structData
                // because it was calculated previously
                // assuming the struct was declared previously
                if (!currentTypeData) {
                    if (currentType) {
                        if (isArray(currentType)) {
                            currentTypeData = getArrayTypeData(currentType, structData);
                        } else {
                            var sd = structData.get(currentType);
                            if (sd) {
                                currentTypeData = {
                                    size: sd.bytes,
                                    align: sd.maxAlign
                                };
                            }
                        }
                    }
                }
                // read above
                if (!nextTypeData) {
                    if (nextType) {
                        if (isArray(nextType)) {
                            nextTypeData = getArrayTypeData(nextType, structData);
                        } else {
                            var sd1 = structData.get(nextType);
                            if (sd1) {
                                nextTypeData = {
                                    size: sd1.bytes,
                                    align: sd1.maxAlign
                                };
                            }
                        }
                    }
                }
                if (!!currentTypeData) {
                    byteCounter += currentTypeData.size;
                    if (currentTypeData.size === structDatum.maxAlign || !nextType) {
                        return;
                    }
                }
                if (!!nextTypeData) {
                    var padAmount = getPadding(byteCounter, structDatum.maxAlign, nextTypeData.size);
                    if (padAmount) {
                        structDatum.paddings[name] = padAmount / 4;
                        byteCounter += padAmount;
                    }
                }
            });
            var padAmount = getPadding(byteCounter, structDatum.maxAlign, 16);
            if (padAmount) {
                structDatum.paddings[''] = padAmount / 4;
                byteCounter += padAmount;
            }
            structDatum.bytes = byteCounter;
        };
        for(var _iterator = structData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return structData;
};
function loadImage(src) {
    return _async_to_generator(function() {
        return _ts_generator(this, function(_state) {
            return [
                2,
                new Promise(function(resolve, reject) {
                    var img = new Image();
                    img.src = src;
                    img.onload = function() {
                        return resolve(img);
                    };
                    img.onerror = function(err) {
                        return reject(err);
                    };
                })
            ];
        });
    })();
}
/**
 * Returns UTF-16 array of each char
 * @param {String} s
 * @returns {Array<Number>}
 */ function strToCodes(s) {
    return Array.from(s).map(function(c) {
        return c.charCodeAt(0);
    });
}
/**
 *
 * @param {Image} atlas Image atlas to parse
 * @param {CanvasRenderingContext2D} ctx Canvas context
 * @param {Number} index index in the atlas, so 0 is the first char
 * @param {{x: number, y: number}} size cell dimensions
 * @param {Number} finalIndex final positional index in the canvas
 */ function sprite(atlas, ctx, index, size, finalIndex) {
    var width = atlas.width;
    var numColumns = width / size.x;
    var x = index % numColumns;
    var y = Math.floor(index / numColumns);
    ctx.drawImage(atlas, x * size.x, y * size.y, size.x, size.y, size.x * finalIndex, 0, size.x, size.y);
}
/**
 * @typedef {number} SignedNumber
 * A numeric value that may be negative or positive.
 */ /**
 * Expects an atlas/spritesheed with chars in UTF-16 order.
 * This means `A` is expected at index `65`; if not there,
 * use offset to move backwards (negative) or forward (positive)
 * @param {String} str String used to extract letters from the image
 * @param {Image} atlasImg image with the Atlas to extract letters from
 * @param {{x: number, y: number}} size width and height in pixels of each letter
 * @param {SignedNumber} offset how many chars is the atlas offset from the UTF-16
 * @returns {string} Base64 image
 */ function strToImage(str, atlasImg, size) {
    var offset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    var chars = strToCodes(str);
    var canvas = document.createElement('canvas');
    canvas.width = chars.length * size.x;
    canvas.height = size.y;
    var ctx = canvas.getContext('2d');
    chars.forEach(function(c, i) {
        return sprite(atlasImg, ctx, c + offset, size, i);
    });
    return canvas.toDataURL('image/png');
}
var _canvasId = /*#__PURE__*/ new WeakMap(), _canvas = /*#__PURE__*/ new WeakMap(), _device = /*#__PURE__*/ new WeakMap(), _context = /*#__PURE__*/ new WeakMap(), _presentationFormat = /*#__PURE__*/ new WeakMap(), _renderPasses = /*#__PURE__*/ new WeakMap(), _postRenderPasses = /*#__PURE__*/ new WeakMap(), _vertexBufferInfo = /*#__PURE__*/ new WeakMap(), _buffer = /*#__PURE__*/ new WeakMap(), _internal = /*#__PURE__*/ new WeakMap(), _presentationSize = /*#__PURE__*/ new WeakMap(), _depthTexture = /*#__PURE__*/ new WeakMap(), _vertexArray = /*#__PURE__*/ new WeakMap(), _numColumns = /*#__PURE__*/ new WeakMap(), _numRows = /*#__PURE__*/ new WeakMap(), _commandsFinished = /*#__PURE__*/ new WeakMap(), _renderPassDescriptor = /*#__PURE__*/ new WeakMap(), _uniforms = /*#__PURE__*/ new WeakMap(), _storage = /*#__PURE__*/ new WeakMap(), _readStorage = /*#__PURE__*/ new WeakMap(), _samplers = /*#__PURE__*/ new WeakMap(), _textures2d = /*#__PURE__*/ new WeakMap(), _texturesToCopy = /*#__PURE__*/ new WeakMap(), _textures2dArray = /*#__PURE__*/ new WeakMap(), _texturesExternal = /*#__PURE__*/ new WeakMap(), _texturesStorage2d = /*#__PURE__*/ new WeakMap(), _bindingTextures = /*#__PURE__*/ new WeakMap(), _layers = /*#__PURE__*/ new WeakMap(), _originalCanvasWidth = /*#__PURE__*/ new WeakMap(), _originalCanvasHeigth = /*#__PURE__*/ new WeakMap(), _clock = /*#__PURE__*/ new WeakMap(), _time1 = /*#__PURE__*/ new WeakMap(), _delta1 = /*#__PURE__*/ new WeakMap(), _epoch = /*#__PURE__*/ new WeakMap(), _mouseX = /*#__PURE__*/ new WeakMap(), _mouseY = /*#__PURE__*/ new WeakMap(), _mouseDown = /*#__PURE__*/ new WeakMap(), _mouseClick = /*#__PURE__*/ new WeakMap(), _mouseWheel = /*#__PURE__*/ new WeakMap(), _mouseDelta = /*#__PURE__*/ new WeakMap(), _fullscreen = /*#__PURE__*/ new WeakMap(), _fitWindow = /*#__PURE__*/ new WeakMap(), _lastFitWindow = /*#__PURE__*/ new WeakMap(), _sounds = /*#__PURE__*/ new WeakMap(), _events = /*#__PURE__*/ new WeakMap(), _events_ids = /*#__PURE__*/ new WeakMap(), _dataSize = /*#__PURE__*/ new WeakMap(), _resizeCanvasToFitWindow = /*#__PURE__*/ new WeakMap(), _resizeCanvasToDefault = /*#__PURE__*/ new WeakMap(), _setScreenSize = /*#__PURE__*/ new WeakMap(), _onMouseMove = /*#__PURE__*/ new WeakMap(), _nameExists = /*#__PURE__*/ new WeakSet(), /**
     * @param {ShaderType} shaderType
     * @param {boolean} internal
     * @returns string with bindings
     */ _createDynamicGroupBindings = /*#__PURE__*/ new WeakSet(), _compileRenderPass = /*#__PURE__*/ new WeakMap(), _generateDataSize = /*#__PURE__*/ new WeakMap(), /**
     * @param {Float32Array} vertexArray
     * @returns buffer
     */ _createVertexBuffer = /*#__PURE__*/ new WeakSet(), /**
     * @param {Float32Array} data
     * @param {GPUBufferUsageFlags} usage
     * @param {Boolean} mappedAtCreation
     * @param {Number} size
     * @returns mapped buffer
     */ _createAndMapBuffer = /*#__PURE__*/ new WeakSet(), /**
     * It creates with size, no with data, so it's empty
     * @param {Number} size numItems * instanceByteSize ;
     * @param {GPUBufferUsageFlags} usage
     * @returns buffer
     */ _createBuffer = /*#__PURE__*/ new WeakSet(), _createParametersUniforms = /*#__PURE__*/ new WeakSet(), _createComputeBuffers = /*#__PURE__*/ new WeakSet(), _createTextureBindingToCopy = /*#__PURE__*/ new WeakSet(), _createTextureToSize = /*#__PURE__*/ new WeakSet(), _createComputeBindGroup = /*#__PURE__*/ new WeakSet(), _createPipeline = /*#__PURE__*/ new WeakSet(), /**
     * Creates the entries for the pipeline
     * @returns an array with the entries
     */ _createEntries = /*#__PURE__*/ new WeakSet(), _createParams = /*#__PURE__*/ new WeakSet(), _getWGSLCoordinate = /*#__PURE__*/ new WeakSet();
var Points = /*#__PURE__*/ function() {
    "use strict";
    function Points(canvasId) {
        var _this = this;
        _class_call_check(this, Points);
        _class_private_method_init(this, _nameExists);
        _class_private_method_init(this, _createDynamicGroupBindings);
        _class_private_method_init(this, _createVertexBuffer);
        _class_private_method_init(this, _createAndMapBuffer);
        _class_private_method_init(this, _createBuffer);
        _class_private_method_init(this, _createParametersUniforms);
        _class_private_method_init(this, _createComputeBuffers);
        _class_private_method_init(this, _createTextureBindingToCopy);
        _class_private_method_init(this, _createTextureToSize);
        _class_private_method_init(this, _createComputeBindGroup);
        _class_private_method_init(this, _createPipeline);
        _class_private_method_init(this, _createEntries);
        _class_private_method_init(this, _createParams);
        _class_private_method_init(this, _getWGSLCoordinate);
        _class_private_field_init(this, _canvasId, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _canvas, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _device, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _context, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _presentationFormat, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _renderPasses, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _postRenderPasses, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _vertexBufferInfo, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _buffer, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _internal, {
            writable: true,
            value: false
        });
        _class_private_field_init(this, _presentationSize, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _depthTexture, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _vertexArray, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _numColumns, {
            writable: true,
            value: 1
        });
        _class_private_field_init(this, _numRows, {
            writable: true,
            value: 1
        });
        _class_private_field_init(this, _commandsFinished, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _renderPassDescriptor, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _uniforms, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _storage, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _readStorage, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _samplers, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _textures2d, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _texturesToCopy, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _textures2dArray, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _texturesExternal, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _texturesStorage2d, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _bindingTextures, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _layers, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _originalCanvasWidth, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _originalCanvasHeigth, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _clock, {
            writable: true,
            value: new Clock()
        });
        _class_private_field_init(this, _time1, {
            writable: true,
            value: 0
        });
        _class_private_field_init(this, _delta1, {
            writable: true,
            value: 0
        });
        _class_private_field_init(this, _epoch, {
            writable: true,
            value: 0
        });
        _class_private_field_init(this, _mouseX, {
            writable: true,
            value: 0
        });
        _class_private_field_init(this, _mouseY, {
            writable: true,
            value: 0
        });
        _class_private_field_init(this, _mouseDown, {
            writable: true,
            value: false
        });
        _class_private_field_init(this, _mouseClick, {
            writable: true,
            value: false
        });
        _class_private_field_init(this, _mouseWheel, {
            writable: true,
            value: false
        });
        _class_private_field_init(this, _mouseDelta, {
            writable: true,
            value: [
                0,
                0
            ]
        });
        _class_private_field_init(this, _fullscreen, {
            writable: true,
            value: false
        });
        _class_private_field_init(this, _fitWindow, {
            writable: true,
            value: false
        });
        _class_private_field_init(this, _lastFitWindow, {
            writable: true,
            value: false
        });
        _class_private_field_init(this, _sounds, {
            writable: true,
            value: []
        }); // audio
        _class_private_field_init(this, _events, {
            writable: true,
            value: new Map()
        });
        _class_private_field_init(this, _events_ids, {
            writable: true,
            value: 0
        });
        _class_private_field_init(this, _dataSize, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _resizeCanvasToFitWindow, {
            writable: true,
            value: function() {
                if (_class_private_field_get(_this, _fitWindow)) {
                    var _class_private_field_get_parentNode = _class_private_field_get(_this, _canvas).parentNode, offsetWidth = _class_private_field_get_parentNode.offsetWidth, offsetHeight = _class_private_field_get_parentNode.offsetHeight;
                    _class_private_field_get(_this, _canvas).width = offsetWidth;
                    _class_private_field_get(_this, _canvas).height = offsetHeight;
                    _class_private_field_get(_this, _setScreenSize).call(_this);
                }
            }
        });
        _class_private_field_init(this, _resizeCanvasToDefault, {
            writable: true,
            value: function() {
                _class_private_field_get(_this, _canvas).width = _class_private_field_get(_this, _originalCanvasWidth);
                _class_private_field_get(_this, _canvas).height = _class_private_field_get(_this, _originalCanvasHeigth);
                _class_private_field_get(_this, _setScreenSize).call(_this);
            }
        });
        _class_private_field_init(this, _setScreenSize, {
            writable: true,
            value: function() {
                _class_private_field_set(_this, _presentationSize, [
                    _class_private_field_get(_this, _canvas).clientWidth,
                    _class_private_field_get(_this, _canvas).clientHeight
                ]);
                _class_private_field_get(_this, _context).configure({
                    device: _class_private_field_get(_this, _device),
                    format: _class_private_field_get(_this, _presentationFormat),
                    //size: this.#presentationSize,
                    width: _class_private_field_get(_this, _canvas).clientWidth,
                    height: _class_private_field_get(_this, _canvas).clientHeight,
                    alphaMode: 'premultiplied',
                    // Specify we want both RENDER_ATTACHMENT and COPY_SRC since we
                    // will copy out of the swapchain texture.
                    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
                });
                _class_private_field_set(_this, _depthTexture, _class_private_field_get(_this, _device).createTexture({
                    size: _class_private_field_get(_this, _presentationSize),
                    format: 'depth24plus',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                }));
                // this is to solve an issue that requires the texture to be resized
                // if the screen dimensions change, this for a `addTexture2d` with
                // `copyCurrentTexture` parameter set to `true`.
                _class_private_field_get(_this, _textures2d).forEach(function(texture2d) {
                    if (!texture2d.imageTexture && texture2d.texture) {
                        _class_private_method_get(_this, _createTextureBindingToCopy, createTextureBindingToCopy).call(_this, texture2d);
                    }
                });
            }
        });
        _class_private_field_init(this, _onMouseMove, {
            writable: true,
            value: function(e) {
                // get position relative to canvas
                var rect = _class_private_field_get(_this, _canvas).getBoundingClientRect();
                _class_private_field_set(_this, _mouseX, e.clientX - rect.left);
                _class_private_field_set(_this, _mouseY, e.clientY - rect.top);
            }
        });
        _class_private_field_init(this, _compileRenderPass, {
            writable: true,
            value: function(renderPass, index) {
                var vertexShader = renderPass.vertexShader;
                var computeShader = renderPass.computeShader;
                var fragmentShader = renderPass.fragmentShader;
                var colorsVertWGSL = vertexShader;
                var colorsComputeWGSL = computeShader;
                var colorsFragWGSL = fragmentShader;
                var dynamicGroupBindingsVertex = '';
                var dynamicGroupBindingsCompute = '';
                var dynamicGroupBindingsFragment = '';
                var dynamicStructParams = '';
                _class_private_field_get(_this, _uniforms).forEach(function(u) {
                    u.type = u.type || 'f32';
                    dynamicStructParams += /*wgsl*/ "".concat(u.name, ":").concat(u.type, ", \n	");
                });
                if (_class_private_field_get(_this, _uniforms).length) {
                    dynamicStructParams = /*wgsl*/ "struct Params {\n	".concat(dynamicStructParams, "\n}\n");
                }
                renderPass.hasVertexShader && (dynamicGroupBindingsVertex += dynamicStructParams);
                renderPass.hasComputeShader && (dynamicGroupBindingsCompute += dynamicStructParams);
                renderPass.hasFragmentShader && (dynamicGroupBindingsFragment += dynamicStructParams);
                renderPass.hasVertexShader && (dynamicGroupBindingsVertex += _class_private_method_get(_this, _createDynamicGroupBindings, createDynamicGroupBindings).call(_this, ShaderType.VERTEX, renderPass.internal));
                renderPass.hasComputeShader && (dynamicGroupBindingsCompute += _class_private_method_get(_this, _createDynamicGroupBindings, createDynamicGroupBindings).call(_this, ShaderType.COMPUTE, renderPass.internal));
                dynamicGroupBindingsFragment += _class_private_method_get(_this, _createDynamicGroupBindings, createDynamicGroupBindings).call(_this, ShaderType.FRAGMENT, renderPass.internal);
                renderPass.hasVertexShader && (colorsVertWGSL = dynamicGroupBindingsVertex + defaultStructs + defaultVertexBody + colorsVertWGSL);
                renderPass.hasComputeShader && (colorsComputeWGSL = dynamicGroupBindingsCompute + defaultStructs + colorsComputeWGSL);
                renderPass.hasFragmentShader && (colorsFragWGSL = dynamicGroupBindingsFragment + defaultStructs + colorsFragWGSL);
                console.groupCollapsed("Render Pass ".concat(index));
                console.groupCollapsed('VERTEX');
                console.log(colorsVertWGSL);
                console.groupEnd();
                if (renderPass.hasComputeShader) {
                    console.groupCollapsed('COMPUTE');
                    console.log(colorsComputeWGSL);
                    console.groupEnd();
                }
                console.groupCollapsed('FRAGMENT');
                console.log(colorsFragWGSL);
                console.groupEnd();
                console.groupEnd();
                renderPass.hasVertexShader && (renderPass.compiledShaders.vertex = colorsVertWGSL);
                renderPass.hasComputeShader && (renderPass.compiledShaders.compute = colorsComputeWGSL);
                renderPass.hasFragmentShader && (renderPass.compiledShaders.fragment = colorsFragWGSL);
            }
        });
        _class_private_field_init(this, _generateDataSize, {
            writable: true,
            value: function() {
                var allShaders = _class_private_field_get(_this, _renderPasses).map(function(renderPass) {
                    var _renderPass_compiledShaders = renderPass.compiledShaders, vertex = _renderPass_compiledShaders.vertex, compute = _renderPass_compiledShaders.compute, fragment = _renderPass_compiledShaders.fragment;
                    return vertex + compute + fragment;
                }).join('\n');
                _class_private_field_set(_this, _dataSize, dataSize(allShaders));
                // since uniforms are in a sigle struct
                // this is only required for storage
                _class_private_field_get(_this, _storage).forEach(function(s) {
                    if (!s.mapped) {
                        if (isArray(s.structName)) {
                            var typeData = getArrayTypeData(s.structName, _class_private_field_get(_this, _dataSize));
                            s.structSize = typeData.size;
                        } else {
                            var d = _class_private_field_get(_this, _dataSize).get(s.structName) || typeSizes[s.structName];
                            if (!d) {
                                throw "".concat(s.structName, " has not been defined.");
                            }
                            s.structSize = d.bytes || d.size;
                        }
                    }
                });
            }
        });
        _class_private_field_set(this, _canvasId, canvasId);
        _class_private_field_set(this, _canvas, document.getElementById(_class_private_field_get(this, _canvasId)));
        if (_class_private_field_get(this, _canvasId)) {
            _class_private_field_get(this, _canvas).addEventListener('click', function(e) {
                _class_private_field_set(_this, _mouseClick, true);
            });
            _class_private_field_get(this, _canvas).addEventListener('mousemove', _class_private_field_get(this, _onMouseMove), {
                passive: true
            });
            _class_private_field_get(this, _canvas).addEventListener('mousedown', function(e) {
                _class_private_field_set(_this, _mouseDown, true);
            });
            _class_private_field_get(this, _canvas).addEventListener('mouseup', function(e) {
                _class_private_field_set(_this, _mouseDown, false);
            });
            _class_private_field_get(this, _canvas).addEventListener('wheel', function(e) {
                _class_private_field_set(_this, _mouseWheel, true);
                _class_private_field_set(_this, _mouseDelta, [
                    e.deltaX,
                    e.deltaY
                ]);
            }, {
                passive: true
            });
            _class_private_field_set(this, _originalCanvasWidth, _class_private_field_get(this, _canvas).clientWidth);
            _class_private_field_set(this, _originalCanvasHeigth, _class_private_field_get(this, _canvas).clientHeight);
            window.addEventListener('resize', _class_private_field_get(this, _resizeCanvasToFitWindow), false);
            document.addEventListener("fullscreenchange", function(e) {
                _class_private_field_set(_this, _fullscreen, !!document.fullscreenElement);
                if (!_class_private_field_get(_this, _fullscreen) && !_class_private_field_get(_this, _fitWindow)) {
                    _class_private_field_get(_this, _resizeCanvasToDefault).call(_this);
                }
                if (!_class_private_field_get(_this, _fullscreen)) {
                    _this.fitWindow = _class_private_field_get(_this, _lastFitWindow);
                }
            });
        }
    }
    _create_class(Points, [
        {
            /**
     * @deprecated use setUniform
     */ key: "addUniform",
            value: function addUniform(name, value, structName) {
                if (structName && isArray(structName)) {
                    throw "".concat(structName, " is an array, which is currently not supported for Uniforms.");
                }
                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _uniforms), name)) {
                    return;
                }
                _class_private_field_get(this, _uniforms).push({
                    name: name,
                    value: value,
                    type: structName,
                    size: null,
                    internal: _class_private_field_get(this, _internal)
                });
            }
        },
        {
            /**
     * @deprecated use setUniform
     */ key: "updateUniform",
            value: function updateUniform(name, value) {
                var variable = _class_private_field_get(this, _uniforms).find(function(v1) {
                    return v1.name === name;
                });
                if (!variable) {
                    throw '`updateUniform()` can\'t be called without first `addUniform()`.';
                }
                variable.value = value;
            }
        },
        {
            /**
     * Set a param as uniform to send to all shaders.
     * A Uniform is a value that can only be changed
     * from the outside, and unless changed it remains
     * consistent.
     * @param {string} name name of the Param, you can invoke it later in shaders as `Params.[name]`
     * @param {Number|Boolean|Array<Number>} value Single number or a list of numbers. Boolean is converted to Number.
     * @param {string} structName type as `f32` or a custom struct. Default `few`
     */ key: "setUniform",
            value: function setUniform(name, value) {
                var structName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                var uniformToUpdate = _class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _uniforms), name);
                if (uniformToUpdate && structName) {
                    //if name exists is an update
                    throw '`setUniform()` can\'t set the structName of an already defined uniform.';
                }
                if (uniformToUpdate) {
                    uniformToUpdate.value = value;
                    return;
                }
                if (structName && isArray(structName)) {
                    throw "".concat(structName, " is an array, which is currently not supported for Uniforms.");
                }
                var uniform = {
                    name: name,
                    value: value,
                    type: structName,
                    size: null,
                    internal: _class_private_field_get(this, _internal)
                };
                _class_private_field_get(this, _uniforms).push(uniform);
                return uniform;
            }
        },
        {
            /**
     * Update a list of uniforms
     * @param {Array<Object>} arr object array of the type: `{name, value}`
     */ key: "updateUniforms",
            value: function updateUniforms(arr) {
                var _this = this;
                arr.forEach(function(uniform) {
                    var variable = _class_private_field_get(_this, _uniforms).find(function(v1) {
                        return v1.name === uniform.name;
                    });
                    if (!variable) {
                        throw '`updateUniform()` can\'t be called without first `addUniform()`.';
                    }
                    variable.value = uniform.value;
                });
            }
        },
        {
            /**
     * @deprecated use setStorage()
     */ key: "addStorage",
            value: function addStorage(name, structName, read, shaderType, arrayData) {
                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _storage), name)) {
                    return;
                }
                _class_private_field_get(this, _storage).push({
                    mapped: !!arrayData,
                    name: name,
                    structName: structName,
                    // structSize: null,
                    shaderType: shaderType,
                    read: read,
                    buffer: null,
                    internal: _class_private_field_get(this, _internal)
                });
            }
        },
        {
            /**
     * Creates a persistent memory buffer across every frame call.
     * @param {string} name Name that the Storage will have in the shader
     * @param {string} structName Name of the struct already existing on the
     * shader that will be the array<structName> of the Storage
     * @param {boolean} read if this is going to be used to read data back
     * @param {ShaderType} shaderType this tells to what shader the storage is bound
     */ key: "setStorage",
            value: function setStorage(name, structName, read, shaderType, arrayData) {
                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _storage), name)) {
                    throw "`setStorage()` You have already defined `".concat(name, "`");
                }
                var storage = {
                    mapped: !!arrayData,
                    name: name,
                    structName: structName,
                    // structSize: null,
                    shaderType: shaderType,
                    read: read,
                    buffer: null,
                    internal: _class_private_field_get(this, _internal)
                };
                _class_private_field_get(this, _storage).push(storage);
                return storage;
            }
        },
        {
            /**
     * @deprecated
     */ key: "addStorageMap",
            value: function addStorageMap(name, arrayData, structName, read, shaderType) {
                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _storage), name)) {
                    return;
                }
                _class_private_field_get(this, _storage).push({
                    mapped: true,
                    name: name,
                    structName: structName,
                    shaderType: shaderType,
                    array: arrayData,
                    buffer: null,
                    read: read,
                    internal: _class_private_field_get(this, _internal)
                });
            }
        },
        {
            /**
     * @deprecated use setStorageMap
     */ key: "updateStorageMap",
            value: function updateStorageMap(name, arrayData) {
                var variable = _class_private_field_get(this, _storage).find(function(v1) {
                    return v1.name === name;
                });
                if (!variable) {
                    throw '`updateStorageMap()` can\'t be called without first `addStorageMap()`.';
                }
                variable.array = arrayData;
            }
        },
        {
            /**
     * Creates a persistent memory buffer across every frame call that can be updated.
     * @param {string} name Name that the Storage will have in the shader.
     * @param {Array<Uint8Array>} arrayData array with the data that must match the struct.
     * @param {string} structName Name of the struct already existing on the
     * shader that will be the array<structName> of the Storage.
     * @param {boolean} read if this is going to be used to read data back.
     * @param {ShaderType} shaderType this tells to what shader the storage is bound
     */ key: "setStorageMap",
            value: function setStorageMap(name, arrayData, structName) {
                var read = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, shaderType = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
                var storageToUpdate = _class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _storage), name);
                if (storageToUpdate) {
                    storageToUpdate.array = arrayData;
                    return storageToUpdate;
                }
                var storage = {
                    mapped: true,
                    name: name,
                    structName: structName,
                    shaderType: shaderType,
                    array: arrayData,
                    buffer: null,
                    read: read,
                    internal: _class_private_field_get(this, _internal)
                };
                _class_private_field_get(this, _storage).push(storage);
                return storage;
            }
        },
        {
            key: "readStorage",
            value: function readStorage(name) {
                return _async_to_generator(function() {
                    var storageItem, arrayBuffer, arrayBufferCopy;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                storageItem = _class_private_field_get(this, _readStorage).find(function(storageItem) {
                                    return storageItem.name === name;
                                });
                                arrayBuffer = null;
                                arrayBufferCopy = null;
                                if (!storageItem) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    storageItem.buffer.mapAsync(GPUMapMode.READ)
                                ];
                            case 1:
                                _state.sent();
                                arrayBuffer = storageItem.buffer.getMappedRange();
                                arrayBufferCopy = new Float32Array(arrayBuffer.slice(0));
                                storageItem.buffer.unmap();
                                _state.label = 2;
                            case 2:
                                return [
                                    2,
                                    arrayBufferCopy
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            /**
     * @deprecated use setLayers
     */ key: "addLayers",
            value: function addLayers(numLayers, shaderType) {
                for(var layerIndex = 0; layerIndex < numLayers; layerIndex++){
                    _class_private_field_get(this, _layers).shaderType = shaderType;
                    _class_private_field_get(this, _layers).push({
                        name: "layer".concat(layerIndex),
                        size: _class_private_field_get(this, _canvas).width * _class_private_field_get(this, _canvas).height,
                        structName: 'vec4<f32>',
                        structSize: 16,
                        array: null,
                        buffer: null,
                        internal: _class_private_field_get(this, _internal)
                    });
                }
            }
        },
        {
            /**
     * Layers of data made of `vec4f`
     * @param {Number} numLayers
     * @param {ShaderType} shaderType
     */ key: "setLayers",
            value: function setLayers(numLayers, shaderType) {
                // TODO: check what data to return
                for(var layerIndex = 0; layerIndex < numLayers; layerIndex++){
                    _class_private_field_get(this, _layers).shaderType = shaderType;
                    _class_private_field_get(this, _layers).push({
                        name: "layer".concat(layerIndex),
                        size: _class_private_field_get(this, _canvas).width * _class_private_field_get(this, _canvas).height,
                        structName: 'vec4<f32>',
                        structSize: 16,
                        array: null,
                        buffer: null,
                        internal: _class_private_field_get(this, _internal)
                    });
                }
            }
        },
        {
            /**
     * @deprecated use setSampler
     */ key: "addSampler",
            value: function addSampler(name, descriptor, shaderType) {
                if ('sampler' == name) {
                    throw '`name` can not be sampler since is a WebGPU keyword';
                }
                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _samplers), name)) {
                    return;
                }
                // Create a sampler with linear filtering for smooth interpolation.
                descriptor = descriptor || {
                    addressModeU: 'clamp-to-edge',
                    addressModeV: 'clamp-to-edge',
                    magFilter: 'linear',
                    minFilter: 'linear',
                    mipmapFilter: 'linear'
                };
                _class_private_field_get(this, _samplers).push({
                    name: name,
                    descriptor: descriptor,
                    shaderType: shaderType,
                    resource: null,
                    internal: _class_private_field_get(this, _internal)
                });
            }
        },
        {
            /**
     * Creates a `sampler` to be sent to the shaders.
     * @param {string} name Name of the `sampler` to be called in the shaders.
     * @param {GPUSamplerDescriptor} descriptor
     */ key: "setSampler",
            value: function setSampler(name, descriptor, shaderType) {
                if ('sampler' == name) {
                    throw 'setSampler: `name` can not be sampler since is a WebGPU keyword.';
                }
                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _samplers), name)) {
                    throw "setSampler: `".concat(name, "` already exists.");
                }
                // Create a sampler with linear filtering for smooth interpolation.
                descriptor = descriptor || {
                    addressModeU: 'clamp-to-edge',
                    addressModeV: 'clamp-to-edge',
                    magFilter: 'linear',
                    minFilter: 'linear',
                    mipmapFilter: 'linear'
                };
                var sampler = {
                    name: name,
                    descriptor: descriptor,
                    shaderType: shaderType,
                    resource: null,
                    internal: _class_private_field_get(this, _internal)
                };
                _class_private_field_get(this, _samplers).push(sampler);
                return sampler;
            }
        },
        {
            /**
     * @deprecated use setTexture2d
     */ key: "addTexture2d",
            value: function addTexture2d(name, copyCurrentTexture, shaderType, renderPassIndex) {
                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _textures2d), name)) {
                    return;
                }
                _class_private_field_get(this, _textures2d).push({
                    name: name,
                    copyCurrentTexture: copyCurrentTexture,
                    shaderType: shaderType,
                    texture: null,
                    renderPassIndex: renderPassIndex,
                    internal: _class_private_field_get(this, _internal)
                });
            }
        },
        {
            /**
     * Create a `texture_2d` in the shaders.
     * @param {string} name Name to call the texture in the shaders.
     * @param {boolean} copyCurrentTexture If you want the fragment output to be copied here.
     */ key: "setTexture2d",
            value: function setTexture2d(name, copyCurrentTexture, shaderType, renderPassIndex) {
                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _textures2d), name)) {
                    throw "setTexture2d: `".concat(name, "` already exists.");
                }
                var texture2d = {
                    name: name,
                    copyCurrentTexture: copyCurrentTexture,
                    shaderType: shaderType,
                    texture: null,
                    renderPassIndex: renderPassIndex,
                    internal: _class_private_field_get(this, _internal)
                };
                _class_private_field_get(this, _textures2d).push(texture2d);
                return texture2d;
            }
        },
        {
            key: "copyTexture",
            value: function copyTexture(nameTextureA, nameTextureB) {
                var texture2d_A = _class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _textures2d), nameTextureA);
                var texture2d_B = _class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _textures2d), nameTextureB);
                if (!(texture2d_A && texture2d_B)) {
                    console.error('One of the textures does not exist.');
                }
                var a = texture2d_A.texture;
                var cubeTexture = _class_private_field_get(this, _device).createTexture({
                    size: [
                        a.width,
                        a.height,
                        1
                    ],
                    format: 'rgba8unorm',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
                });
                texture2d_B.texture = cubeTexture;
                _class_private_field_get(this, _texturesToCopy).push({
                    a: a,
                    b: texture2d_B.texture
                });
            }
        },
        {
            key: "addTextureImage",
            value: /**
     * @deprecated use setTextureImage
     */ function addTextureImage(name, path, shaderType) {
                return _async_to_generator(function() {
                    var response, blob, imageBitmap;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _textures2d), name)) {
                                    return [
                                        2
                                    ];
                                }
                                return [
                                    4,
                                    fetch(path)
                                ];
                            case 1:
                                response = _state.sent();
                                return [
                                    4,
                                    response.blob()
                                ];
                            case 2:
                                blob = _state.sent();
                                return [
                                    4,
                                    createImageBitmap(blob)
                                ];
                            case 3:
                                imageBitmap = _state.sent();
                                _class_private_field_get(this, _textures2d).push({
                                    name: name,
                                    copyCurrentTexture: false,
                                    shaderType: shaderType,
                                    texture: null,
                                    imageTexture: {
                                        bitmap: imageBitmap
                                    },
                                    internal: _class_private_field_get(this, _internal)
                                });
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "updateTextureImage",
            value: /**
     * @deprecated use setTextureImage
     */ function updateTextureImage(name, path, shaderType) {
                return _async_to_generator(function() {
                    var response, blob, imageBitmap, texture2d, cubeTexture;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (!_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _textures2d), name)) {
                                    console.warn('image can not be updated');
                                    return [
                                        2
                                    ];
                                }
                                return [
                                    4,
                                    fetch(path)
                                ];
                            case 1:
                                response = _state.sent();
                                return [
                                    4,
                                    response.blob()
                                ];
                            case 2:
                                blob = _state.sent();
                                return [
                                    4,
                                    createImageBitmap(blob)
                                ];
                            case 3:
                                imageBitmap = _state.sent();
                                texture2d = _class_private_field_get(this, _textures2d).filter(function(obj) {
                                    return obj.name == name;
                                })[0];
                                texture2d.imageTexture.bitmap = imageBitmap;
                                cubeTexture = _class_private_field_get(this, _device).createTexture({
                                    size: [
                                        imageBitmap.width,
                                        imageBitmap.height,
                                        1
                                    ],
                                    format: 'rgba8unorm',
                                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
                                });
                                _class_private_field_get(this, _device).queue.copyExternalImageToTexture({
                                    source: imageBitmap
                                }, {
                                    texture: cubeTexture
                                }, [
                                    imageBitmap.width,
                                    imageBitmap.height
                                ]);
                                texture2d.texture = cubeTexture;
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "setTextureImage",
            value: /**
     * Load an image as texture_2d
     * @param {string} name
     * @param {string} path
     * @param {ShaderType} shaderType
     */ function setTextureImage(name, path) {
                var shaderType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                return _async_to_generator(function() {
                    var texture2dToUpdate, response, blob, imageBitmap, cubeTexture, texture2d;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                texture2dToUpdate = _class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _textures2d), name);
                                return [
                                    4,
                                    fetch(path)
                                ];
                            case 1:
                                response = _state.sent();
                                return [
                                    4,
                                    response.blob()
                                ];
                            case 2:
                                blob = _state.sent();
                                return [
                                    4,
                                    createImageBitmap(blob)
                                ];
                            case 3:
                                imageBitmap = _state.sent();
                                if (texture2dToUpdate) {
                                    if (shaderType) {
                                        throw '`setTextureImage()` the param `shaderType` should not be updated after its creation.';
                                    }
                                    texture2dToUpdate.imageTexture.bitmap = imageBitmap;
                                    cubeTexture = _class_private_field_get(this, _device).createTexture({
                                        size: [
                                            imageBitmap.width,
                                            imageBitmap.height,
                                            1
                                        ],
                                        format: 'rgba8unorm',
                                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
                                    });
                                    _class_private_field_get(this, _device).queue.copyExternalImageToTexture({
                                        source: imageBitmap
                                    }, {
                                        texture: cubeTexture
                                    }, [
                                        imageBitmap.width,
                                        imageBitmap.height
                                    ]);
                                    texture2dToUpdate.texture = cubeTexture;
                                    return [
                                        2,
                                        texture2dToUpdate
                                    ];
                                }
                                texture2d = {
                                    name: name,
                                    copyCurrentTexture: false,
                                    shaderType: shaderType,
                                    texture: null,
                                    imageTexture: {
                                        bitmap: imageBitmap
                                    },
                                    internal: _class_private_field_get(this, _internal)
                                };
                                _class_private_field_get(this, _textures2d).push(texture2d);
                                return [
                                    2,
                                    texture2d
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "setTextureString",
            value: /**
     * Loads a text string as a texture.
     * Using an Atlas or a Spritesheet with UTF-16 chars (`path`) it will create a new texture
     * that contains only the `text` characters.
     * Characters in the atlas `path` must be in order of the UTF-16 chars.
     * It can have missing characters at the end or at the start, so the `offset` is added to take account for those chars.
     * For example, `A` is 65, but if one character is removed before the letter `A`, then offset is -1
     * @param {String} name id of the wgsl variable in the shader
     * @param {String} text text you want to load as texture
     * @param {String} path atlas to grab characters from
     * @param {{x: number, y: number}} size size of a individual character e.g.: `{x:10, y:20}`
     * @param {Number} offset how many characters back or forward it must move to start
     * @param {String} shaderType
     * @returns
     */ function setTextureString(name, text, path, size) {
                var offset = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, shaderType = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
                return _async_to_generator(function() {
                    var atlas, textImg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                return [
                                    4,
                                    loadImage(path)
                                ];
                            case 1:
                                atlas = _state.sent();
                                textImg = strToImage(text, atlas, size, offset);
                                return [
                                    2,
                                    this.setTextureImage(name, textImg, shaderType)
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "setTextureImageArray",
            value: /**
     * Load images as texture_2d_array
     * @param {string} name
     * @param {Array} paths
     * @param {ShaderType} shaderType
     */ // TODO: verify if this can be updated after creation
            // TODO: return texture2dArray object
            function setTextureImageArray(name, paths, shaderType) {
                return _async_to_generator(function() {
                    var imageBitmaps, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, path, response, blob, _, err;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _textures2dArray), name)) {
                                    // TODO: throw exception here
                                    return [
                                        2
                                    ];
                                }
                                imageBitmaps = [];
                                _iteratorAbruptCompletion = false, _didIteratorError = false;
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    9,
                                    10,
                                    15
                                ]);
                                _iterator = _async_iterator(paths);
                                _state.label = 2;
                            case 2:
                                return [
                                    4,
                                    _iterator.next()
                                ];
                            case 3:
                                if (!(_iteratorAbruptCompletion = !(_step = _state.sent()).done)) return [
                                    3,
                                    8
                                ];
                                _value = _step.value;
                                path = _value;
                                console.log(path);
                                return [
                                    4,
                                    fetch(path)
                                ];
                            case 4:
                                response = _state.sent();
                                return [
                                    4,
                                    response.blob()
                                ];
                            case 5:
                                blob = _state.sent();
                                _ = imageBitmaps.push;
                                return [
                                    4,
                                    createImageBitmap(blob)
                                ];
                            case 6:
                                _.apply(imageBitmaps, [
                                    _state.sent()
                                ]);
                                _state.label = 7;
                            case 7:
                                _iteratorAbruptCompletion = false;
                                return [
                                    3,
                                    2
                                ];
                            case 8:
                                return [
                                    3,
                                    15
                                ];
                            case 9:
                                err = _state.sent();
                                _didIteratorError = true;
                                _iteratorError = err;
                                return [
                                    3,
                                    15
                                ];
                            case 10:
                                _state.trys.push([
                                    10,
                                    ,
                                    13,
                                    14
                                ]);
                                if (!(_iteratorAbruptCompletion && _iterator.return != null)) return [
                                    3,
                                    12
                                ];
                                return [
                                    4,
                                    _iterator.return()
                                ];
                            case 11:
                                _state.sent();
                                _state.label = 12;
                            case 12:
                                return [
                                    3,
                                    14
                                ];
                            case 13:
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                                return [
                                    7
                                ];
                            case 14:
                                return [
                                    7
                                ];
                            case 15:
                                _class_private_field_get(this, _textures2dArray).push({
                                    name: name,
                                    copyCurrentTexture: false,
                                    shaderType: shaderType,
                                    texture: null,
                                    imageTextures: {
                                        bitmaps: imageBitmaps
                                    },
                                    internal: _class_private_field_get(this, _internal)
                                });
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "addTextureVideo",
            value: /**
     * @deprecated use setTextureVideo
     */ function addTextureVideo(name, path, shaderType) {
                return _async_to_generator(function() {
                    var video;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _texturesExternal), name)) {
                                    return [
                                        2
                                    ];
                                }
                                video = document.createElement('video');
                                video.loop = true;
                                video.autoplay = true;
                                video.muted = true;
                                video.src = new URL(path, import.meta.url).toString();
                                return [
                                    4,
                                    video.play()
                                ];
                            case 1:
                                _state.sent();
                                _class_private_field_get(this, _texturesExternal).push({
                                    name: name,
                                    shaderType: shaderType,
                                    video: video,
                                    internal: _class_private_field_get(this, _internal)
                                });
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "setTextureVideo",
            value: /**
     * Load an video as texture2d
     * @param {string} name
     * @param {string} path
     * @param {ShaderType} shaderType
     */ function setTextureVideo(name, path, shaderType) {
                return _async_to_generator(function() {
                    var video, textureExternal;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _texturesExternal), name)) {
                                    throw "setTextureVideo: ".concat(name, " already exists.");
                                }
                                video = document.createElement('video');
                                video.loop = true;
                                video.autoplay = true;
                                video.muted = true;
                                video.src = new URL(path, import.meta.url).toString();
                                return [
                                    4,
                                    video.play()
                                ];
                            case 1:
                                _state.sent();
                                textureExternal = {
                                    name: name,
                                    shaderType: shaderType,
                                    video: video,
                                    internal: _class_private_field_get(this, _internal)
                                };
                                _class_private_field_get(this, _texturesExternal).push(textureExternal);
                                return [
                                    2,
                                    textureExternal
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "addTextureWebcam",
            value: /**
     * @deprecated use setTextureWebcam
     */ function addTextureWebcam(name, shaderType) {
                return _async_to_generator(function() {
                    var video;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _texturesExternal), name)) {
                                    return [
                                        2
                                    ];
                                }
                                video = document.createElement('video');
                                //video.loop = true;
                                //video.autoplay = true;
                                video.muted = true;
                                if (!navigator.mediaDevices.getUserMedia) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    navigator.mediaDevices.getUserMedia({
                                        video: true
                                    }).then(function(stream) {
                                        return _async_to_generator(function() {
                                            return _ts_generator(this, function(_state) {
                                                switch(_state.label){
                                                    case 0:
                                                        video.srcObject = stream;
                                                        return [
                                                            4,
                                                            video.play()
                                                        ];
                                                    case 1:
                                                        _state.sent();
                                                        return [
                                                            2
                                                        ];
                                                }
                                            });
                                        })();
                                    }).catch(function(err) {
                                        console.log(err);
                                    })
                                ];
                            case 1:
                                _state.sent();
                                _state.label = 2;
                            case 2:
                                _class_private_field_get(this, _texturesExternal).push({
                                    name: name,
                                    shaderType: shaderType,
                                    video: video,
                                    internal: _class_private_field_get(this, _internal)
                                });
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "setTextureWebcam",
            value: /**
     * Load webcam as texture2d
     * @param {string} name
     * @param {ShaderType} shaderType
     */ function setTextureWebcam(name, shaderType) {
                return _async_to_generator(function() {
                    var video, textureExternal;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _texturesExternal), name)) {
                                    throw "setTextureWebcam: ".concat(name, " already exists.");
                                }
                                video = document.createElement('video');
                                //video.loop = true;
                                //video.autoplay = true;
                                video.muted = true;
                                if (!navigator.mediaDevices.getUserMedia) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    navigator.mediaDevices.getUserMedia({
                                        video: true
                                    }).then(function(stream) {
                                        return _async_to_generator(function() {
                                            return _ts_generator(this, function(_state) {
                                                switch(_state.label){
                                                    case 0:
                                                        video.srcObject = stream;
                                                        return [
                                                            4,
                                                            video.play()
                                                        ];
                                                    case 1:
                                                        _state.sent();
                                                        return [
                                                            2
                                                        ];
                                                }
                                            });
                                        })();
                                    }).catch(function(err) {
                                        console.log(err);
                                    })
                                ];
                            case 1:
                                _state.sent();
                                _state.label = 2;
                            case 2:
                                textureExternal = {
                                    name: name,
                                    shaderType: shaderType,
                                    video: video,
                                    internal: _class_private_field_get(this, _internal)
                                };
                                _class_private_field_get(this, _texturesExternal).push(textureExternal);
                                return [
                                    2,
                                    textureExternal
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            /**
     * @deprecated use setAudio
     */ key: "addAudio",
            value: function addAudio(name, path, volume, loop, autoplay) {
                var audio = new Audio(path);
                audio.volume = volume;
                audio.autoplay = autoplay;
                audio.loop = loop;
                var sound = {
                    name: name,
                    path: path,
                    audio: audio,
                    analyser: null,
                    data: null
                };
                // this.#audio.play();
                // audio
                var audioContext = new AudioContext();
                var resume = function(_) {
                    audioContext.resume();
                };
                if (audioContext.state === 'suspended') {
                    document.body.addEventListener('touchend', resume, false);
                    document.body.addEventListener('click', resume, false);
                }
                var source = audioContext.createMediaElementSource(audio);
                // // audioContext.createMediaStreamSource()
                var analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                var bufferLength = analyser.fftSize; //analyser.frequencyBinCount;
                // const bufferLength = analyser.frequencyBinCount;
                var data = new Uint8Array(bufferLength);
                // analyser.getByteTimeDomainData(data);
                analyser.getByteFrequencyData(data);
                // storage that will have the data on WGSL
                this.setStorageMap(name, data, // `array<f32, ${bufferLength}>`
                'Sound' // custom struct in defaultStructs.js
                );
                // uniform that will have the data length as a quick reference
                this.setUniform("".concat(name, "Length"), analyser.frequencyBinCount);
                sound.analyser = analyser;
                sound.data = data;
                _class_private_field_get(this, _sounds).push(sound);
                return audio;
            }
        },
        {
            /**
     * Assigns an audio FrequencyData to a StorageMap
     * @param {string} name name of the Storage and prefix of the length variable e.g. `[name]Length`.
     * @param {string} path
     * @param {Number} volume
     * @param {boolean} loop
     * @param {boolean} autoplay
     * @returns {HTMLAudioElement}
     */ key: "setAudio",
            value: function setAudio(name, path, volume, loop, autoplay) {
                var audio = new Audio(path);
                audio.volume = volume;
                audio.autoplay = autoplay;
                audio.loop = loop;
                var sound = {
                    name: name,
                    path: path,
                    audio: audio,
                    analyser: null,
                    data: null
                };
                // this.#audio.play();
                // audio
                var audioContext = new AudioContext();
                var resume = function(_) {
                    audioContext.resume();
                };
                if (audioContext.state === 'suspended') {
                    document.body.addEventListener('touchend', resume, false);
                    document.body.addEventListener('click', resume, false);
                }
                var source = audioContext.createMediaElementSource(audio);
                // // audioContext.createMediaStreamSource()
                var analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                var bufferLength = analyser.fftSize; //analyser.frequencyBinCount;
                // const bufferLength = analyser.frequencyBinCount;
                var data = new Uint8Array(bufferLength);
                // analyser.getByteTimeDomainData(data);
                analyser.getByteFrequencyData(data);
                // storage that will have the data on WGSL
                this.setStorageMap(name, data, // `array<f32, ${bufferLength}>`
                'Sound' // custom struct in defaultStructs.js
                );
                // uniform that will have the data length as a quick reference
                this.setUniform("".concat(name, "Length"), analyser.frequencyBinCount);
                sound.analyser = analyser;
                sound.data = data;
                _class_private_field_get(this, _sounds).push(sound);
                return audio;
            }
        },
        {
            // TODO: verify this method
            key: "setTextureStorage2d",
            value: function setTextureStorage2d(name, shaderType) {
                if (_class_private_method_get(this, _nameExists, nameExists).call(this, _class_private_field_get(this, _texturesStorage2d), name)) {
                    throw "setTextureStorage2d: ".concat(name, " already exists.");
                }
                var texturesStorage2d = {
                    name: name,
                    shaderType: shaderType,
                    texture: null,
                    internal: _class_private_field_get(this, _internal)
                };
                _class_private_field_get(this, _texturesStorage2d).push(texturesStorage2d);
                return texturesStorage2d;
            }
        },
        {
            /**
     * @deprecated use setBindingTexture
     */ key: "addBindingTexture",
            value: function addBindingTexture(computeName, fragmentName, size) {
                _class_private_field_get(this, _bindingTextures).push({
                    compute: {
                        name: computeName,
                        shaderType: ShaderType.COMPUTE
                    },
                    fragment: {
                        name: fragmentName,
                        shaderType: ShaderType.FRAGMENT
                    },
                    texture: null,
                    size: size,
                    internal: _class_private_field_get(this, _internal)
                });
            }
        },
        {
            /**
     * Sets a texture to the compute and fragment shader, in the compute you can
     * write to the texture, and in the fragment you can read the texture, so is
     * a one way communication method.
     * @param {string} computeName name of the variable in the compute shader
     * @param {string} fragmentName name of the variable in the fragment shader
     * @param {Array<number, 2>} size dimensions of the texture, by default screen
     * size
     * @returns
     */ key: "setBindingTexture",
            value: function setBindingTexture(computeName, fragmentName, size) {
                // TODO: validate that names don't exist already
                var bindingTexture = {
                    compute: {
                        name: computeName,
                        shaderType: ShaderType.COMPUTE
                    },
                    fragment: {
                        name: fragmentName,
                        shaderType: ShaderType.FRAGMENT
                    },
                    texture: null,
                    size: size,
                    internal: _class_private_field_get(this, _internal)
                };
                _class_private_field_get(this, _bindingTextures).push(bindingTexture);
                return bindingTexture;
            }
        },
        {
            /**
     * Listen for an event dispatched from WGSL code
     * @param {String} name Number that represents an event Id
     * @param {Function} callback function to be called when the event occurs
     */ key: "addEventListener",
            value: function addEventListener(name, callback, structSize) {
                // TODO: remove structSize
                // this extra 4 is for the boolean flag in the Event struct
                var data = Array(structSize + 4).fill(0);
                this.setStorageMap(name, data, 'Event', true);
                _class_private_field_get(this, _events).set(_class_private_field_get(this, _events_ids), {
                    id: _class_private_field_get(this, _events_ids),
                    name: name,
                    callback: callback
                });
                ++_class_private_field_update(this, _events_ids).value;
            }
        },
        {
            /**
     * @private
     * for internal use:
     * to flag add* methods and variables as part of the RenderPasses
     */ key: "_setInternal",
            value: function _setInternal(value) {
                _class_private_field_set(this, _internal, value);
            }
        },
        {
            /**
     * Establishes the density of the base mesh, by default 1x1, meaning two triangles.
     * The final number of triangles is `numColumns` * `numRows` * `2` ( 2 being the triangles )
     * @param {Number} numColumns quads horizontally
     * @param {Number} numRows quads vertically
     */ key: "setMeshDensity",
            value: function setMeshDensity(numColumns, numRows) {
                if (numColumns == 0 || numRows == 0) {
                    throw 'Parameters should be greater than 0';
                }
                _class_private_field_set(this, _numColumns, numColumns);
                _class_private_field_set(this, _numRows, numRows);
            }
        },
        {
            key: "init",
            value: /**
     * One time function to call to initialize the shaders.
     * @param {Array<RenderPass>} renderPasses Collection of RenderPass, which contain Vertex, Compute and Fragment shaders.
     * @returns false | undefined
     */ function init(renderPasses) {
                return _async_to_generator(function() {
                    var hasComputeShaders, adapter, err, _tmp;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _class_private_field_set(this, _renderPasses, renderPasses.concat(_class_private_field_get(this, _postRenderPasses)));
                                // initializing internal uniforms
                                this.setUniform(UniformKeys.TIME, _class_private_field_get(this, _time1));
                                this.setUniform(UniformKeys.DELTA, _class_private_field_get(this, _delta1));
                                this.setUniform(UniformKeys.EPOCH, _class_private_field_get(this, _epoch));
                                this.setUniform(UniformKeys.SCREEN, [
                                    0,
                                    0
                                ], 'vec2f');
                                this.setUniform(UniformKeys.MOUSE, [
                                    0,
                                    0
                                ], 'vec2f');
                                this.setUniform(UniformKeys.MOUSE_CLICK, _class_private_field_get(this, _mouseClick));
                                this.setUniform(UniformKeys.MOUSE_DOWN, _class_private_field_get(this, _mouseDown));
                                this.setUniform(UniformKeys.MOUSE_WHEEL, _class_private_field_get(this, _mouseWheel));
                                this.setUniform(UniformKeys.MOUSE_DELTA, _class_private_field_get(this, _mouseDelta), 'vec2f');
                                hasComputeShaders = _class_private_field_get(this, _renderPasses).some(function(renderPass) {
                                    return renderPass.hasComputeShader;
                                });
                                if (!hasComputeShaders && _class_private_field_get(this, _bindingTextures).length) {
                                    throw ' `addBindingTexture` requires at least one Compute Shader in a `RenderPass`';
                                }
                                _class_private_field_get(this, _renderPasses).forEach(_class_private_field_get(this, _compileRenderPass));
                                _class_private_field_get(this, _generateDataSize).call(this);
                                //
                                adapter = null;
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                return [
                                    4,
                                    navigator.gpu.requestAdapter()
                                ];
                            case 2:
                                adapter = _state.sent();
                                return [
                                    3,
                                    4
                                ];
                            case 3:
                                err = _state.sent();
                                console.log(err);
                                return [
                                    3,
                                    4
                                ];
                            case 4:
                                if (!adapter) {
                                    return [
                                        2,
                                        false
                                    ];
                                }
                                _tmp = [
                                    this,
                                    _device
                                ];
                                return [
                                    4,
                                    adapter.requestDevice()
                                ];
                            case 5:
                                _class_private_field_set.apply(void 0, _tmp.concat([
                                    _state.sent()
                                ]));
                                _class_private_field_get(this, _device).lost.then(function(info) {
                                    console.log(info);
                                });
                                if (_class_private_field_get(this, _canvas) !== null) _class_private_field_set(this, _context, _class_private_field_get(this, _canvas).getContext('webgpu'));
                                _class_private_field_set(this, _presentationFormat, navigator.gpu.getPreferredCanvasFormat());
                                if (_class_private_field_get(this, _canvasId)) {
                                    if (_class_private_field_get(this, _fitWindow)) {
                                        _class_private_field_get(this, _resizeCanvasToFitWindow).call(this);
                                    } else {
                                        _class_private_field_get(this, _resizeCanvasToDefault).call(this);
                                    }
                                }
                                _class_private_field_set(this, _renderPassDescriptor, {
                                    colorAttachments: [
                                        {
                                            //view: textureView,
                                            clearValue: {
                                                r: 0.0,
                                                g: 0.0,
                                                b: 0.0,
                                                a: 1.0
                                            },
                                            loadOp: 'clear',
                                            storeOp: 'store'
                                        }
                                    ],
                                    depthStencilAttachment: {
                                        //view: this.#depthTexture.createView(),
                                        depthClearValue: 1.0,
                                        depthLoadOp: 'clear',
                                        depthStoreOp: 'store'
                                    }
                                });
                                return [
                                    4,
                                    this.createScreen()
                                ];
                            case 6:
                                _state.sent();
                                return [
                                    2,
                                    true
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            /**
     * Mainly to be used with RenderPasses.js
     * @param {RenderPass} renderPass
     */ key: "addRenderPass",
            value: function addRenderPass(renderPass) {
                _class_private_field_get(this, _postRenderPasses).push(renderPass);
            }
        },
        {
            key: "renderPasses",
            get: function get() {
                return _class_private_field_get(this, _renderPasses);
            }
        },
        {
            key: "createScreen",
            value: /**
     * Adds two triangles called points per number of columns and rows
     */ function createScreen() {
                return _async_to_generator(function() {
                    var hasVertexAndFragmentShader, colors, xIndex, yIndex, coordinate;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                hasVertexAndFragmentShader = _class_private_field_get(this, _renderPasses).some(function(renderPass) {
                                    return renderPass.hasVertexAndFragmentShader;
                                });
                                if (hasVertexAndFragmentShader) {
                                    colors = [
                                        new RGBAColor(1, 0, 0),
                                        new RGBAColor(0, 1, 0),
                                        new RGBAColor(0, 0, 1),
                                        new RGBAColor(1, 1, 0)
                                    ];
                                    for(xIndex = 0; xIndex < _class_private_field_get(this, _numRows); xIndex++){
                                        for(yIndex = 0; yIndex < _class_private_field_get(this, _numColumns); yIndex++){
                                            coordinate = new Coordinate(xIndex * _class_private_field_get(this, _canvas).clientWidth / _class_private_field_get(this, _numColumns), yIndex * _class_private_field_get(this, _canvas).clientHeight / _class_private_field_get(this, _numRows), .3);
                                            this.addPoint(coordinate, _class_private_field_get(this, _canvas).clientWidth / _class_private_field_get(this, _numColumns), _class_private_field_get(this, _canvas).clientHeight / _class_private_field_get(this, _numRows), colors);
                                        }
                                    }
                                    _class_private_method_get(this, _createVertexBuffer, createVertexBuffer).call(this, new Float32Array(_class_private_field_get(this, _vertexArray)));
                                }
                                _class_private_method_get(this, _createComputeBuffers, createComputeBuffers).call(this);
                                return [
                                    4,
                                    _class_private_method_get(this, _createPipeline, createPipeline).call(this)
                                ];
                            case 1:
                                _state.sent();
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "update",
            value: function update() {
                return _async_to_generator(function() {
                    var _this, commandEncoder, swapChainTexture;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _this = this;
                                if (!_class_private_field_get(this, _canvas) || !_class_private_field_get(this, _device)) return [
                                    2
                                ];
                                //--------------------------------------------
                                _class_private_field_set(this, _delta1, _class_private_field_get(this, _clock).getDelta());
                                _class_private_field_set(this, _time1, _class_private_field_get(this, _clock).time);
                                _class_private_field_set(this, _epoch, new Date() / 1000);
                                this.setUniform(UniformKeys.TIME, _class_private_field_get(this, _time1));
                                this.setUniform(UniformKeys.DELTA, _class_private_field_get(this, _delta1));
                                this.setUniform(UniformKeys.EPOCH, _class_private_field_get(this, _epoch));
                                this.setUniform(UniformKeys.SCREEN, [
                                    _class_private_field_get(this, _canvas).width,
                                    _class_private_field_get(this, _canvas).height
                                ]);
                                this.setUniform(UniformKeys.MOUSE, [
                                    _class_private_field_get(this, _mouseX),
                                    _class_private_field_get(this, _mouseY)
                                ]);
                                this.setUniform(UniformKeys.MOUSE_CLICK, _class_private_field_get(this, _mouseClick));
                                this.setUniform(UniformKeys.MOUSE_DOWN, _class_private_field_get(this, _mouseDown));
                                this.setUniform(UniformKeys.MOUSE_WHEEL, _class_private_field_get(this, _mouseWheel));
                                this.setUniform(UniformKeys.MOUSE_DELTA, _class_private_field_get(this, _mouseDelta));
                                //--------------------------------------------
                                _class_private_method_get(this, _createParametersUniforms, createParametersUniforms).call(this);
                                // TODO: create method for this
                                _class_private_field_get(this, _storage).forEach(function(storageItem) {
                                    if (storageItem.mapped) {
                                        var values = new Float32Array(storageItem.array);
                                        storageItem.buffer = _class_private_method_get(_this, _createAndMapBuffer, createAndMapBuffer).call(_this, values, storageItem.usage);
                                    }
                                });
                                // AUDIO
                                // this.#analyser.getByteTimeDomainData(this.#dataArray);
                                _class_private_field_get(this, _sounds).forEach(function(sound) {
                                    var _sound_analyser;
                                    (_sound_analyser = sound.analyser) === null || _sound_analyser === void 0 ? void 0 : _sound_analyser.getByteFrequencyData(sound.data);
                                });
                                // END AUDIO
                                _class_private_field_get(this, _texturesExternal).forEach(function(externalTexture) {
                                    externalTexture.texture = _class_private_field_get(_this, _device).importExternalTexture({
                                        source: externalTexture.video
                                    });
                                    if ('requestVideoFrameCallback' in externalTexture.video) {
                                        externalTexture.video.requestVideoFrameCallback(function() {});
                                    }
                                });
                                _class_private_method_get(this, _createComputeBindGroup, createComputeBindGroup).call(this);
                                commandEncoder = _class_private_field_get(this, _device).createCommandEncoder();
                                _class_private_field_get(this, _renderPasses).forEach(function(renderPass) {
                                    if (renderPass.hasComputeShader) {
                                        var passEncoder = commandEncoder.beginComputePass();
                                        passEncoder.setPipeline(renderPass.computePipeline);
                                        if (_class_private_field_get(_this, _uniforms).length) {
                                            passEncoder.setBindGroup(0, renderPass.computeBindGroup);
                                        }
                                        passEncoder.dispatchWorkgroups(renderPass.workgroupCountX, renderPass.workgroupCountY, renderPass.workgroupCountZ);
                                        passEncoder.end();
                                    }
                                });
                                // ---------------------
                                _class_private_field_get(this, _renderPassDescriptor).colorAttachments[0].view = _class_private_field_get(this, _context).getCurrentTexture().createView();
                                _class_private_field_get(this, _renderPassDescriptor).depthStencilAttachment.view = _class_private_field_get(this, _depthTexture).createView();
                                swapChainTexture = _class_private_field_get(this, _context).getCurrentTexture();
                                //commandEncoder = this.#device.createCommandEncoder();
                                _class_private_field_get(this, _renderPasses).forEach(function(renderPass, renderPassIndex) {
                                    if (renderPass.hasVertexAndFragmentShader) {
                                        var passEncoder = commandEncoder.beginRenderPass(_class_private_field_get(_this, _renderPassDescriptor));
                                        passEncoder.setPipeline(renderPass.renderPipeline);
                                        _class_private_method_get(_this, _createParams, createParams).call(_this);
                                        if (_class_private_field_get(_this, _uniforms).length) {
                                            passEncoder.setBindGroup(0, renderPass.uniformBindGroup);
                                        }
                                        passEncoder.setVertexBuffer(0, _class_private_field_get(_this, _buffer));
                                        /**
                 * vertexCount: number The number of vertices to draw
                 * instanceCount?: number | undefined The number of instances to draw
                 * firstVertex?: number | undefined Offset into the vertex buffers, in vertices, to begin drawing from
                 * firstInstance?: number | undefined First instance to draw
                 */ //passEncoder.draw(3, 1, 0, 0);
                                        passEncoder.draw(_class_private_field_get(_this, _vertexBufferInfo).vertexCount);
                                        passEncoder.end();
                                        // Copy the rendering results from the swapchain into |texture2d.texture|.
                                        _class_private_field_get(_this, _textures2d).forEach(function(texture2d) {
                                            if (texture2d.renderPassIndex == renderPassIndex || texture2d.renderPassIndex == null) {
                                                if (texture2d.copyCurrentTexture) {
                                                    commandEncoder.copyTextureToTexture({
                                                        texture: swapChainTexture
                                                    }, {
                                                        texture: texture2d.texture
                                                    }, _class_private_field_get(_this, _presentationSize));
                                                }
                                            }
                                        });
                                        _class_private_field_get(_this, _texturesToCopy).forEach(function(texturePair) {
                                            // console.log(texturePair.a);
                                            // this.#createTextureToSize(texturePair.b, texturePair.a.width, texturePair.a.height);
                                            commandEncoder.copyTextureToTexture({
                                                texture: texturePair.a
                                            }, {
                                                texture: texturePair.b
                                            }, [
                                                texturePair.a.width,
                                                texturePair.a.height
                                            ]);
                                        });
                                        _class_private_field_set(_this, _texturesToCopy, []);
                                    }
                                });
                                if (_class_private_field_get(this, _readStorage).length) {
                                    _class_private_field_get(this, _readStorage).forEach(function(readStorageItem) {
                                        var storageItem = _class_private_field_get(_this, _storage).find(function(storageItem) {
                                            return storageItem.name === readStorageItem.name;
                                        });
                                        commandEncoder.copyBufferToBuffer(storageItem.buffer /* source buffer */ , 0 /* source offset */ , readStorageItem.buffer /* destination buffer */ , 0 /* destination offset */ , readStorageItem.buffer.size /* size */ );
                                    });
                                }
                                // ---------------------
                                _class_private_field_get(this, _commandsFinished).push(commandEncoder.finish());
                                _class_private_field_get(this, _device).queue.submit(_class_private_field_get(this, _commandsFinished));
                                _class_private_field_set(this, _commandsFinished, []);
                                //
                                //this.#vertexArray = [];
                                // reset mouse values because it doesn't happen by itself
                                _class_private_field_set(this, _mouseClick, false);
                                _class_private_field_set(this, _mouseWheel, false);
                                _class_private_field_set(this, _mouseDelta, [
                                    0,
                                    0
                                ]);
                                return [
                                    4,
                                    this.read()
                                ];
                            case 1:
                                _state.sent();
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "read",
            value: function read() {
                return _async_to_generator(function() {
                    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step_value, key, event, eventRead, id, err;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    6,
                                    7,
                                    8
                                ]);
                                _iterator = _class_private_field_get(this, _events)[Symbol.iterator]();
                                _state.label = 2;
                            case 2:
                                if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                                    3,
                                    5
                                ];
                                _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], event = _step_value[1];
                                return [
                                    4,
                                    this.readStorage(event.name)
                                ];
                            case 3:
                                eventRead = _state.sent();
                                if (eventRead) {
                                    id = eventRead[0];
                                    if (id != 0) {
                                        event.callback && event.callback(eventRead.slice(1, -1));
                                    }
                                }
                                _state.label = 4;
                            case 4:
                                _iteratorNormalCompletion = true;
                                return [
                                    3,
                                    2
                                ];
                            case 5:
                                return [
                                    3,
                                    8
                                ];
                            case 6:
                                err = _state.sent();
                                _didIteratorError = true;
                                _iteratorError = err;
                                return [
                                    3,
                                    8
                                ];
                            case 7:
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                                return [
                                    7
                                ];
                            case 8:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            /**
     * Adds two triangles as a quad called Point
     * @param {Coordinate} coordinate `x` from 0 to canvas.width, `y` from 0 to canvas.height, `z` it goes from 0.0 to 1.0 and forward
     * @param {Number} width point width
     * @param {Number} height point height
     * @param {Array<RGBAColor>} colors one color per corner
     * @param {Boolean} useTexture
     */ key: "addPoint",
            value: function addPoint(coordinate, width, height, colors) {
                var useTexture = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                var x = coordinate.x, y = coordinate.y, z = coordinate.z;
                var nx = _class_private_method_get(this, _getWGSLCoordinate, getWGSLCoordinate).call(this, x, _class_private_field_get(this, _canvas).width);
                var ny = _class_private_method_get(this, _getWGSLCoordinate, getWGSLCoordinate).call(this, y, _class_private_field_get(this, _canvas).height, true);
                var nz = z;
                var nw = _class_private_method_get(this, _getWGSLCoordinate, getWGSLCoordinate).call(this, x + width, _class_private_field_get(this, _canvas).width);
                var nh = _class_private_method_get(this, _getWGSLCoordinate, getWGSLCoordinate).call(this, y + height, _class_private_field_get(this, _canvas).height);
                var _colors_ = colors[0], r0 = _colors_.r, g0 = _colors_.g, b0 = _colors_.b, a0 = _colors_.a;
                var _colors_1 = colors[1], r1 = _colors_1.r, g1 = _colors_1.g, b1 = _colors_1.b, a1 = _colors_1.a;
                var _colors_2 = colors[2], r2 = _colors_2.r, g2 = _colors_2.g, b2 = _colors_2.b, a2 = _colors_2.a;
                var _colors_3 = colors[3], r3 = _colors_3.r, g3 = _colors_3.g, b3 = _colors_3.b, a3 = _colors_3.a;
                _class_private_field_get(this, _vertexArray).push(+nx, +ny, nz, 1, r0, g0, b0, a0, (+nx + 1) * .5, (+ny + 1) * .5, +nw, +ny, nz, 1, r1, g1, b1, a1, (+nw + 1) * .5, (+ny + 1) * .5, +nw, -nh, nz, 1, r3, g3, b3, a3, (+nw + 1) * .5, (-nh + 1) * .5, +nx, +ny, nz, 1, r0, g0, b0, a0, (+nx + 1) * .5, (+ny + 1) * .5, +nx, -nh, nz, 1, r2, g2, b2, a2, (+nx + 1) * .5, (-nh + 1) * .5, +nw, -nh, nz, 1, r3, g3, b3, a3, (+nw + 1) * .5, (-nh + 1) * .5);
            }
        },
        {
            key: "canvas",
            get: function get() {
                return _class_private_field_get(this, _canvas);
            }
        },
        {
            key: "device",
            get: function get() {
                return _class_private_field_get(this, _device);
            }
        },
        {
            key: "context",
            get: function get() {
                return _class_private_field_get(this, _context);
            }
        },
        {
            key: "presentationFormat",
            get: function get() {
                return _class_private_field_get(this, _presentationFormat);
            }
        },
        {
            key: "buffer",
            get: function get() {
                return _class_private_field_get(this, _buffer);
            }
        },
        {
            key: "fullscreen",
            get: function get() {
                return _class_private_field_get(this, _fullscreen);
            },
            set: function set(value) {
                if (value) {
                    _class_private_field_set(this, _lastFitWindow, _class_private_field_get(this, _fitWindow));
                    this.fitWindow = value;
                    _class_private_field_get(this, _canvas).requestFullscreen().catch(function(err) {
                        throw "Error attempting to enable fullscreen mode: ".concat(err.message, " (").concat(err.name, ")");
                    });
                    _class_private_field_set(this, _fullscreen, true);
                } else {
                    document.exitFullscreen();
                    _class_private_field_set(this, _fullscreen, false);
                    _class_private_field_get(this, _resizeCanvasToDefault).call(this);
                }
            }
        },
        {
            key: "fitWindow",
            get: function get() {
                return _class_private_field_get(this, _fitWindow);
            },
            set: function set(value) {
                if (!_class_private_field_get(this, _context)) {
                    throw 'fitWindow must be assigned after Points.init() call or you don\'t have a Canvas assigned in the constructor';
                }
                _class_private_field_set(this, _fitWindow, value);
                if (_class_private_field_get(this, _fitWindow)) {
                    _class_private_field_get(this, _resizeCanvasToFitWindow).call(this);
                } else {
                    _class_private_field_get(this, _resizeCanvasToDefault).call(this);
                }
            }
        }
    ]);
    return Points;
}();
function nameExists(arrayOfObjects, name) {
    return arrayOfObjects.find(function(obj) {
        return obj.name == name;
    });
}
function createDynamicGroupBindings(shaderType, internal) {
    // `internal` here is a flag for a custom pass
    internal = internal || false;
    if (!shaderType) {
        throw '`ShaderType` is required';
    }
    var groupId = 0;
    var dynamicGroupBindings = '';
    var bindingIndex = 0;
    if (_class_private_field_get(this, _uniforms).length) {
        dynamicGroupBindings += /*wgsl*/ "@group(".concat(groupId, ") @binding(").concat(bindingIndex, ") var <uniform> params: Params;\n");
        bindingIndex += 1;
    }
    _class_private_field_get(this, _storage).forEach(function(storageItem) {
        var internalCheck = internal == storageItem.internal;
        if (!storageItem.shaderType && internalCheck || storageItem.shaderType == shaderType && internalCheck) {
            var T = storageItem.structName;
            dynamicGroupBindings += /*wgsl*/ "@group(".concat(groupId, ") @binding(").concat(bindingIndex, ") var <storage, read_write> ").concat(storageItem.name, ": ").concat(T, ";\n");
            bindingIndex += 1;
        }
    });
    if (_class_private_field_get(this, _layers).length) {
        if (!_class_private_field_get(this, _layers).shaderType || _class_private_field_get(this, _layers).shaderType == shaderType) {
            var totalSize = 0;
            _class_private_field_get(this, _layers).forEach(function(layerItem) {
                return totalSize += layerItem.size;
            });
            dynamicGroupBindings += /*wgsl*/ "@group(".concat(groupId, ") @binding(").concat(bindingIndex, ") var <storage, read_write> layers: array<array<vec4<f32>, ").concat(totalSize, ">>;\n");
            bindingIndex += 1;
        }
    }
    _class_private_field_get(this, _samplers).forEach(function(sampler, index) {
        var internalCheck = internal == sampler.internal;
        if (!sampler.shaderType && internalCheck || sampler.shaderType == shaderType && internalCheck) {
            dynamicGroupBindings += /*wgsl*/ "@group(".concat(groupId, ") @binding(").concat(bindingIndex, ") var ").concat(sampler.name, ": sampler;\n");
            bindingIndex += 1;
        }
    });
    _class_private_field_get(this, _texturesStorage2d).forEach(function(texture, index) {
        var internalCheck = internal && texture.internal;
        if (!texture.shaderType && internalCheck || texture.shaderType == shaderType && internalCheck) {
            dynamicGroupBindings += /*wgsl*/ "@group(".concat(groupId, ") @binding(").concat(bindingIndex, ") var ").concat(texture.name, ": texture_storage_2d<rgba8unorm, write>;\n");
            bindingIndex += 1;
        }
    });
    _class_private_field_get(this, _textures2d).forEach(function(texture, index) {
        var internalCheck = internal == texture.internal;
        if (!texture.shaderType && internalCheck || texture.shaderType == shaderType && internalCheck) {
            dynamicGroupBindings += /*wgsl*/ "@group(".concat(groupId, ") @binding(").concat(bindingIndex, ") var ").concat(texture.name, ": texture_2d<f32>;\n");
            bindingIndex += 1;
        }
    });
    _class_private_field_get(this, _textures2dArray).forEach(function(texture, index) {
        var internalCheck = internal == texture.internal;
        if (!texture.shaderType && internalCheck || texture.shaderType == shaderType && internalCheck) {
            dynamicGroupBindings += /*wgsl*/ "@group(".concat(groupId, ") @binding(").concat(bindingIndex, ") var ").concat(texture.name, ": texture_2d_array<f32>;\n");
            bindingIndex += 1;
        }
    });
    _class_private_field_get(this, _texturesExternal).forEach(function(externalTexture) {
        var internalCheck = internal == externalTexture.internal;
        if (!externalTexture.shaderType && internalCheck || externalTexture.shaderType == shaderType && internalCheck) {
            dynamicGroupBindings += /*wgsl*/ "@group(".concat(groupId, ") @binding(").concat(bindingIndex, ") var ").concat(externalTexture.name, ": texture_external;\n");
            bindingIndex += 1;
        }
    });
    _class_private_field_get(this, _bindingTextures).forEach(function(bindingTexture) {
        var internalCheck = internal == bindingTexture.internal;
        if (bindingTexture.compute.shaderType == shaderType && internalCheck) {
            dynamicGroupBindings += /*wgsl*/ "@group(".concat(groupId, ") @binding(").concat(bindingIndex, ") var ").concat(bindingTexture.compute.name, ": texture_storage_2d<rgba8unorm, write>;\n");
            bindingIndex += 1;
        }
        if (bindingTexture.fragment.shaderType == shaderType && internalCheck) {
            dynamicGroupBindings += /*wgsl*/ "@group(".concat(groupId, ") @binding(").concat(bindingIndex, ") var ").concat(bindingTexture.fragment.name, ": texture_2d<f32>;\n");
            bindingIndex += 1;
        }
    });
    return dynamicGroupBindings;
}
function createVertexBuffer(vertexArray) {
    _class_private_field_set(this, _vertexBufferInfo, new VertexBufferInfo(vertexArray));
    _class_private_field_set(this, _buffer, _class_private_method_get(this, _createAndMapBuffer, createAndMapBuffer).call(this, vertexArray, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST));
}
function createAndMapBuffer(data, usage) {
    var mappedAtCreation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, size = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    var buffer = _class_private_field_get(this, _device).createBuffer({
        mappedAtCreation: mappedAtCreation,
        size: size || data.byteLength,
        usage: usage
    });
    new Float32Array(buffer.getMappedRange()).set(data);
    buffer.unmap();
    return buffer;
}
function createBuffer(size, usage) {
    var buffer = _class_private_field_get(this, _device).createBuffer({
        size: size,
        usage: usage
    });
    return buffer;
}
function createParametersUniforms() {
    var paramsDataSize = _class_private_field_get(this, _dataSize).get('Params');
    var paddings = paramsDataSize.paddings;
    // we check the paddings list and add 0's to just the ones that need it
    var uniformsClone = JSON.parse(JSON.stringify(_class_private_field_get(this, _uniforms)));
    var arrayValues = uniformsClone.map(function(v1) {
        var padding = paddings[v1.name];
        if (padding) {
            if (v1.value.constructor !== Array) {
                v1.value = [
                    v1.value
                ];
            }
            for(var i = 0; i < padding; i++){
                v1.value.push(0);
            }
        }
        return v1.value;
    }).flat(1);
    var finalPadding = paddings[''];
    if (finalPadding) {
        for(var i = 0; i < finalPadding; i++){
            arrayValues.push(0);
        }
    }
    var values = new Float32Array(arrayValues);
    _class_private_field_get(this, _uniforms).buffer = _class_private_method_get(this, _createAndMapBuffer, createAndMapBuffer).call(this, values, GPUBufferUsage.UNIFORM, true, paramsDataSize.bytes);
}
function createComputeBuffers() {
    var _this = this;
    //--------------------------------------------
    _class_private_method_get(this, _createParametersUniforms, createParametersUniforms).call(this);
    //--------------------------------------------
    _class_private_field_get(this, _storage).forEach(function(storageItem) {
        var usage = GPUBufferUsage.STORAGE;
        if (storageItem.read) {
            var readStorageItem = {
                name: storageItem.name,
                size: storageItem.structSize
            };
            if (storageItem.mapped) {
                readStorageItem = {
                    name: storageItem.name,
                    size: storageItem.array.length
                };
            }
            _class_private_field_get(_this, _readStorage).push(readStorageItem);
            usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC;
        }
        storageItem.usage = usage;
        if (storageItem.mapped) {
            var values = new Float32Array(storageItem.array);
            storageItem.buffer = _class_private_method_get(_this, _createAndMapBuffer, createAndMapBuffer).call(_this, values, usage);
        } else {
            storageItem.buffer = _class_private_method_get(_this, _createBuffer, createBuffer).call(_this, storageItem.structSize, usage);
        }
    });
    //--------------------------------------------
    _class_private_field_get(this, _readStorage).forEach(function(readStorageItem) {
        readStorageItem.buffer = _class_private_field_get(_this, _device).createBuffer({
            size: readStorageItem.size,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        });
    });
    //--------------------------------------------
    if (_class_private_field_get(this, _layers).length) {
        //let layerValues = [];
        var layersSize = 0;
        _class_private_field_get(this, _layers).forEach(function(layerItem) {
            layersSize += layerItem.size * layerItem.structSize;
        });
        _class_private_field_get(this, _layers).buffer = _class_private_method_get(this, _createBuffer, createBuffer).call(this, layersSize, GPUBufferUsage.STORAGE);
    }
    //--------------------------------------------
    _class_private_field_get(this, _samplers).forEach(function(sampler) {
        return sampler.resource = _class_private_field_get(_this, _device).createSampler(sampler.descriptor);
    });
    //--------------------------------------------
    _class_private_field_get(this, _texturesStorage2d).forEach(function(textureStorage2d) {
        textureStorage2d.texture = _class_private_field_get(_this, _device).createTexture({
            size: _class_private_field_get(_this, _presentationSize),
            format: 'rgba8unorm',
            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
        });
    });
    //--------------------------------------------
    _class_private_field_get(this, _textures2d).forEach(function(texture2d) {
        if (texture2d.imageTexture) {
            var cubeTexture;
            var imageBitmap = texture2d.imageTexture.bitmap;
            cubeTexture = _class_private_field_get(_this, _device).createTexture({
                label: texture2d.name,
                size: [
                    imageBitmap.width,
                    imageBitmap.height,
                    1
                ],
                format: 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
            });
            _class_private_field_get(_this, _device).queue.copyExternalImageToTexture({
                source: imageBitmap
            }, {
                texture: cubeTexture
            }, [
                imageBitmap.width,
                imageBitmap.height
            ]);
            texture2d.texture = cubeTexture;
        // } else if (texture2d.copyCurrentTexture) {
        } else {
            _class_private_method_get(_this, _createTextureBindingToCopy, createTextureBindingToCopy).call(_this, texture2d);
        }
    });
    //--------------------------------------------
    _class_private_field_get(this, _textures2dArray).forEach(function(texture2dArray) {
        if (texture2dArray.imageTextures) {
            var cubeTexture;
            var imageBitmaps = texture2dArray.imageTextures.bitmaps;
            cubeTexture = _class_private_field_get(_this, _device).createTexture({
                size: [
                    imageBitmaps[0].width,
                    imageBitmaps[0].height,
                    imageBitmaps.length
                ],
                format: 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
            });
            imageBitmaps.forEach(function(imageBitmap, i) {
                _class_private_field_get(_this, _device).queue.copyExternalImageToTexture({
                    source: imageBitmap
                }, {
                    texture: cubeTexture,
                    origin: {
                        x: 0,
                        y: 0,
                        z: i
                    }
                }, [
                    imageBitmap.width,
                    imageBitmap.height,
                    1
                ]);
            });
            texture2dArray.texture = cubeTexture;
        } else {
            _class_private_method_get(_this, _createTextureBindingToCopy, createTextureBindingToCopy).call(_this, texture2dArray);
        }
    });
    //--------------------------------------------
    _class_private_field_get(this, _texturesExternal).forEach(function(externalTexture) {
        externalTexture.texture = _class_private_field_get(_this, _device).importExternalTexture({
            source: externalTexture.video
        });
    });
    //--------------------------------------------
    _class_private_field_get(this, _bindingTextures).forEach(function(bindingTexture) {
        bindingTexture.texture = _class_private_field_get(_this, _device).createTexture({
            size: bindingTexture.size || _class_private_field_get(_this, _presentationSize),
            format: 'rgba8unorm',
            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
        });
    });
}
function createTextureBindingToCopy(texture2d) {
    texture2d.texture = _class_private_field_get(this, _device).createTexture({
        label: texture2d.name,
        size: _class_private_field_get(this, _presentationSize),
        format: _class_private_field_get(this, _presentationFormat),
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
}
function createTextureToSize(texture2d, width, height) {
    texture2d.texture = _class_private_field_get(this, _device).createTexture({
        label: texture2d.name,
        size: [
            width,
            height
        ],
        format: _class_private_field_get(this, _presentationFormat),
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
}
function createComputeBindGroup() {
    var _this = this;
    _class_private_field_get(this, _renderPasses).forEach(function(renderPass, index) {
        if (renderPass.hasComputeShader) {
            var entries = _class_private_method_get(_this, _createEntries, createEntries).call(_this, ShaderType.COMPUTE);
            if (entries.length) {
                var bglEntries = [];
                entries.forEach(function(entry, index) {
                    var bglEntry = {
                        binding: index,
                        visibility: GPUShaderStage.COMPUTE
                    };
                    bglEntry[entry.type.name] = {
                        'type': entry.type.type
                    };
                    if (entry.type.format) {
                        bglEntry[entry.type.name].format = entry.type.format;
                    }
                    if (entry.type.viewDimension) {
                        bglEntry[entry.type.name].viewDimension = entry.type.viewDimension;
                    }
                    bglEntries.push(bglEntry);
                });
                renderPass.bindGroupLayout = _class_private_field_get(_this, _device).createBindGroupLayout({
                    entries: bglEntries
                });
                /**
                     * @type {GPUBindGroup}
                     */ renderPass.computeBindGroup = _class_private_field_get(_this, _device).createBindGroup({
                    label: "_createComputeBindGroup 0 - ".concat(index),
                    layout: renderPass.bindGroupLayout,
                    entries: entries
                });
            }
        }
    });
}
function createPipeline() {
    return _async_to_generator(function() {
        var _this;
        return _ts_generator(this, function(_state) {
            _this = this;
            _class_private_method_get(this, _createComputeBindGroup, createComputeBindGroup).call(this);
            _class_private_field_get(this, _renderPasses).forEach(function(renderPass, index) {
                if (renderPass.hasComputeShader) {
                    renderPass.computePipeline = _class_private_field_get(_this, _device).createComputePipeline({
                        layout: _class_private_field_get(_this, _device).createPipelineLayout({
                            bindGroupLayouts: [
                                renderPass.bindGroupLayout
                            ]
                        }),
                        label: "_createPipeline() - ".concat(index),
                        compute: {
                            module: _class_private_field_get(_this, _device).createShaderModule({
                                code: renderPass.compiledShaders.compute
                            }),
                            entryPoint: "main"
                        }
                    });
                }
            });
            //--------------------------------------
            _class_private_method_get(this, _createParams, createParams).call(this);
            //this.createVertexBuffer(new Float32Array(this.#vertexArray));
            // enum GPUPrimitiveTopology {
            //     'point-list',
            //     'line-list',
            //     'line-strip',
            //     'triangle-list',
            //     'triangle-strip',
            // };
            _class_private_field_get(this, _renderPasses).forEach(function(renderPass) {
                if (renderPass.hasVertexAndFragmentShader) {
                    renderPass.renderPipeline = _class_private_field_get(_this, _device).createRenderPipeline({
                        // layout: 'auto',
                        layout: _class_private_field_get(_this, _device).createPipelineLayout({
                            bindGroupLayouts: [
                                renderPass.bindGroupLayout
                            ]
                        }),
                        //primitive: { topology: 'triangle-strip' },
                        primitive: {
                            topology: 'triangle-list'
                        },
                        depthStencil: {
                            depthWriteEnabled: true,
                            depthCompare: 'less',
                            format: 'depth24plus'
                        },
                        vertex: {
                            module: _class_private_field_get(_this, _device).createShaderModule({
                                code: renderPass.compiledShaders.vertex
                            }),
                            entryPoint: 'main',
                            buffers: [
                                {
                                    arrayStride: _class_private_field_get(_this, _vertexBufferInfo).vertexSize,
                                    attributes: [
                                        {
                                            // position
                                            shaderLocation: 0,
                                            offset: _class_private_field_get(_this, _vertexBufferInfo).vertexOffset,
                                            format: 'float32x4'
                                        },
                                        {
                                            // colors
                                            shaderLocation: 1,
                                            offset: _class_private_field_get(_this, _vertexBufferInfo).colorOffset,
                                            format: 'float32x4'
                                        },
                                        {
                                            // uv
                                            shaderLocation: 2,
                                            offset: _class_private_field_get(_this, _vertexBufferInfo).uvOffset,
                                            format: 'float32x2'
                                        }
                                    ]
                                }
                            ]
                        },
                        fragment: {
                            module: _class_private_field_get(_this, _device).createShaderModule({
                                code: renderPass.compiledShaders.fragment
                            }),
                            entryPoint: 'main',
                            targets: [
                                {
                                    format: _class_private_field_get(_this, _presentationFormat),
                                    blend: {
                                        alpha: {
                                            srcFactor: 'src-alpha',
                                            dstFactor: 'one-minus-src-alpha',
                                            operation: 'add'
                                        },
                                        color: {
                                            srcFactor: 'src-alpha',
                                            dstFactor: 'one-minus-src-alpha',
                                            operation: 'add'
                                        }
                                    },
                                    writeMask: GPUColorWrite.ALL
                                }
                            ]
                        }
                    });
                }
            });
            return [
                2
            ];
        });
    }).call(this);
}
function createEntries(shaderType, internal) {
    internal = internal || false;
    var entries = [];
    var bindingIndex = 0;
    if (_class_private_field_get(this, _uniforms).length) {
        entries.push({
            binding: bindingIndex++,
            resource: {
                label: 'uniform',
                buffer: _class_private_field_get(this, _uniforms).buffer
            },
            type: {
                name: 'buffer',
                type: 'uniform'
            }
        });
    }
    if (_class_private_field_get(this, _storage).length) {
        _class_private_field_get(this, _storage).forEach(function(storageItem) {
            var internalCheck = internal == storageItem.internal;
            if (!storageItem.shaderType && internalCheck || storageItem.shaderType == shaderType && internalCheck) {
                entries.push({
                    binding: bindingIndex++,
                    resource: {
                        label: 'storage',
                        buffer: storageItem.buffer
                    },
                    type: {
                        name: 'buffer',
                        type: 'storage'
                    }
                });
            }
        });
    }
    if (_class_private_field_get(this, _layers).length) {
        if (!_class_private_field_get(this, _layers).shaderType || _class_private_field_get(this, _layers).shaderType == shaderType) {
            entries.push({
                binding: bindingIndex++,
                resource: {
                    label: 'layer',
                    buffer: _class_private_field_get(this, _layers).buffer
                },
                type: {
                    name: 'buffer',
                    type: 'storage'
                }
            });
        }
    }
    if (_class_private_field_get(this, _samplers).length) {
        _class_private_field_get(this, _samplers).forEach(function(sampler, index) {
            var internalCheck = internal == sampler.internal;
            if (!sampler.shaderType && internalCheck || sampler.shaderType == shaderType && internalCheck) {
                entries.push({
                    binding: bindingIndex++,
                    resource: sampler.resource,
                    type: {
                        name: 'sampler',
                        type: 'filtering'
                    }
                });
            }
        });
    }
    if (_class_private_field_get(this, _texturesStorage2d).length) {
        _class_private_field_get(this, _texturesStorage2d).forEach(function(textureStorage2d, index) {
            var internalCheck = internal == textureStorage2d.internal;
            if (!textureStorage2d.shaderType && internalCheck || textureStorage2d.shaderType == shaderType && internalCheck) {
                entries.push({
                    label: 'texture storage 2d',
                    binding: bindingIndex++,
                    resource: textureStorage2d.texture.createView(),
                    type: {
                        name: 'storageTexture',
                        type: 'write-only'
                    }
                });
            }
        });
    }
    if (_class_private_field_get(this, _textures2d).length) {
        _class_private_field_get(this, _textures2d).forEach(function(texture2d, index) {
            var internalCheck = internal == texture2d.internal;
            if (!texture2d.shaderType && internalCheck || texture2d.shaderType == shaderType && internalCheck) {
                entries.push({
                    label: 'texture 2d',
                    binding: bindingIndex++,
                    resource: texture2d.texture.createView(),
                    type: {
                        name: 'texture',
                        type: 'float'
                    }
                });
            }
        });
    }
    if (_class_private_field_get(this, _textures2dArray).length) {
        _class_private_field_get(this, _textures2dArray).forEach(function(texture2dArray, index) {
            var internalCheck = internal == texture2dArray.internal;
            if (!texture2dArray.shaderType && internalCheck || texture2dArray.shaderType == shaderType && internalCheck) {
                entries.push({
                    label: 'texture 2d array',
                    binding: bindingIndex++,
                    resource: texture2dArray.texture.createView({
                        dimension: '2d-array',
                        baseArrayLayer: 0,
                        arrayLayerCount: texture2dArray.imageTextures.bitmaps.length
                    }),
                    type: {
                        name: 'texture',
                        type: 'float',
                        viewDimension: '2d-array'
                    }
                });
            }
        });
    }
    if (_class_private_field_get(this, _texturesExternal).length) {
        _class_private_field_get(this, _texturesExternal).forEach(function(externalTexture) {
            var internalCheck = internal == externalTexture.internal;
            if (!externalTexture.shaderType && internalCheck || externalTexture.shaderType == shaderType && internalCheck) {
                entries.push({
                    label: 'external texture',
                    binding: bindingIndex++,
                    resource: externalTexture.texture,
                    type: {
                        name: 'externalTexture'
                    }
                });
            }
        });
    }
    if (_class_private_field_get(this, _bindingTextures).length) {
        _class_private_field_get(this, _bindingTextures).forEach(function(bindingTexture) {
            var internalCheck = internal == bindingTexture.internal;
            if (bindingTexture.compute.shaderType == shaderType && internalCheck) {
                entries.push({
                    label: 'binding texture',
                    binding: bindingIndex++,
                    resource: bindingTexture.texture.createView(),
                    type: {
                        name: 'storageTexture',
                        type: 'write-only',
                        format: 'rgba8unorm'
                    }
                });
            }
        });
        _class_private_field_get(this, _bindingTextures).forEach(function(bindingTexture) {
            var internalCheck = internal == bindingTexture.internal;
            if (bindingTexture.fragment.shaderType == shaderType && internalCheck) {
                entries.push({
                    label: 'binding texture 2',
                    binding: bindingIndex++,
                    resource: bindingTexture.texture.createView(),
                    type: {
                        name: 'texture',
                        type: 'float'
                    }
                });
            }
        });
    }
    return entries;
}
function createParams() {
    var _this = this;
    _class_private_field_get(this, _renderPasses).forEach(function(renderPass) {
        var entries = _class_private_method_get(_this, _createEntries, createEntries).call(_this, ShaderType.FRAGMENT, renderPass.internal);
        if (entries.length) {
            var bglEntries = [];
            entries.forEach(function(entry, index) {
                var bglEntry = {
                    binding: index,
                    visibility: GPUShaderStage.FRAGMENT
                };
                bglEntry[entry.type.name] = {
                    'type': entry.type.type
                };
                if (entry.type.viewDimension) {
                    bglEntry[entry.type.name].viewDimension = entry.type.viewDimension;
                }
                // TODO: 1262
                // if you remove this there's an error that I think is not explained right
                // it talks about a storage in index 1 but it was actually the 0
                // and so is to this uniform you have to change the visibility
                // not remove the type and leaving it empty as it seems you have to do here:
                // https://gpuweb.github.io/gpuweb/#bindgroup-examples
                if (entry.type.type == 'uniform') {
                    bglEntry.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
                }
                bglEntries.push(bglEntry);
            });
            renderPass.bindGroupLayout = _class_private_field_get(_this, _device).createBindGroupLayout({
                entries: bglEntries
            });
            renderPass.uniformBindGroup = _class_private_field_get(_this, _device).createBindGroup({
                label: '_createParams() 0',
                layout: renderPass.bindGroupLayout,
                entries: entries
            });
        }
    });
}
function getWGSLCoordinate(value, side) {
    var invert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var direction = invert ? -1 : 1;
    var p = value / side;
    return (p * 2 - 1) * direction;
}
export { Points };

