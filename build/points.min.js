/* @ts-self-types="./points.d.ts" */
import{RenderPass as RenderPass$1}from"points";function getWGSLCoordinate(value,side,invert=false){const direction=invert?-1:1;const p=value/side;return(p*2-1)*direction}const BARYCENTRICS=[[1,0,0],[0,1,0],[0,0,1]];class PrimitiveTopology{static POINT_LIST="point-list";static LINE_LIST="line-list";static LINE_STRIP="line-strip";static TRIANGLE_LIST="triangle-list";static TRIANGLE_STRIP="triangle-strip"}class LoadOp{static CLEAR="clear";static LOAD="load"}class FrontFace{static CCW="ccw";static CW="cw"}class CullMode{static NONE="none";static FRONT="front";static BACK="back"}class RenderPass{#index=null;#vertexShader;#computeShader;#fragmentShader;#compiledShaders;#computePipeline=null;#renderPipeline=null;#name=null;#computeBindGroup=null;#fragmentBindGroup=null;#vertexBindGroup=null;#bindGroupLayoutFragment=null;#bindGroupLayoutVertex=null;#bindGroupLayoutCompute=null;#hasComputeShader;#hasVertexShader;#hasFragmentShader;#hasVertexAndFragmentShader;#workgroupCountX;#workgroupCountY;#workgroupCountZ;#callback=null;#required=null;#instanceCount=1;#internal=false;#params=null;#vertexArray=[];#vertexBuffer=null;#vertexBufferInfo=null;#depthWriteEnabled=false;#textureDepth=null;#loadOp=LoadOp.CLEAR;#clearValue={r:0,g:0,b:0,a:1};#meshCounter=0;#meshes=[];#topology=PrimitiveTopology.TRIANGLE_LIST;#cullMode=CullMode.BACK;#frontFace=FrontFace.CCW;#descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]};#depthStencilAttachment={depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"};#bundle=null;#device=null;constructor(vertexShader,fragmentShader,computeShader,workgroupCountX,workgroupCountY,workgroupCountZ,init){this.#vertexShader=vertexShader;this.#computeShader=computeShader;this.#fragmentShader=fragmentShader;this.#callback=init;this.#internal=!!init;this.#compiledShaders={vertex:"",compute:"",fragment:""};this.#hasComputeShader=!!this.#computeShader;this.#hasVertexShader=!!this.#vertexShader;this.#hasFragmentShader=!!this.#fragmentShader;this.#hasVertexAndFragmentShader=this.#hasVertexShader&&this.#hasFragmentShader;this.#workgroupCountX=workgroupCountX||8;this.#workgroupCountY=workgroupCountY||8;this.#workgroupCountZ=workgroupCountZ||1;Object.seal(this)}get index(){return this.#index}set index(value){this.#index=value}get vertexShader(){return this.#vertexShader}get computeShader(){return this.#computeShader}get fragmentShader(){return this.#fragmentShader}set computePipeline(value){this.#computePipeline=value}get computePipeline(){return this.#computePipeline}set renderPipeline(value){this.#renderPipeline=value}get renderPipeline(){return this.#renderPipeline}set computeBindGroup(value){this.#computeBindGroup=value}get computeBindGroup(){return this.#computeBindGroup}set fragmentBindGroup(value){this.#fragmentBindGroup=value}get fragmentBindGroup(){return this.#fragmentBindGroup}set vertexBindGroup(value){this.#vertexBindGroup=value}get vertexBindGroup(){return this.#vertexBindGroup}set bindGroupLayoutFragment(value){this.#bindGroupLayoutFragment=value}get bindGroupLayoutFragment(){return this.#bindGroupLayoutFragment}set bindGroupLayoutVertex(value){this.#bindGroupLayoutVertex=value}get bindGroupLayoutVertex(){return this.#bindGroupLayoutVertex}set bindGroupLayoutCompute(value){this.#bindGroupLayoutCompute=value}get bindGroupLayoutCompute(){return this.#bindGroupLayoutCompute}get compiledShaders(){return this.#compiledShaders}get hasComputeShader(){return this.#hasComputeShader}get hasVertexShader(){return this.#hasVertexShader}get hasFragmentShader(){return this.#hasFragmentShader}get hasVertexAndFragmentShader(){return this.#hasVertexAndFragmentShader}get workgroupCountX(){return this.#workgroupCountX}set workgroupCountX(val){this.#workgroupCountX=val}get workgroupCountY(){return this.#workgroupCountY}set workgroupCountY(val){this.#workgroupCountY=val}get workgroupCountZ(){return this.#workgroupCountZ}set workgroupCountZ(val){this.#workgroupCountZ=val}init(points){this.#params||={};this.#callback?.(points,this.#params)}get required(){return this.#required}set required(val){this.#required=val}get instanceCount(){this.#instanceCount=this.#meshes.reduce((sum,mesh)=>sum+mesh.instanceCount,0);return this.#instanceCount}get name(){return this.#name}set name(val){this.#name=val}get internal(){return this.#internal}get params(){return this.#params}set params(val){this.#params=val}get vertexArray(){return new Float32Array(this.#vertexArray)}set vertexArray(val){this.#vertexArray=val}get vertexBufferInfo(){return this.#vertexBufferInfo}set vertexBufferInfo(val){this.#vertexBufferInfo=val}get vertexBuffer(){return this.#vertexBuffer}set vertexBuffer(val){this.#vertexBuffer=val}get depthWriteEnabled(){return this.#depthWriteEnabled}set depthWriteEnabled(val){if(val){this.#descriptor.depthStencilAttachment=this.#depthStencilAttachment}this.#depthWriteEnabled=val}get textureDepth(){return this.#textureDepth}set textureDepth(val){this.#textureDepth=val}get loadOp(){return this.#loadOp}set loadOp(val){this.#loadOp=val;this.#descriptor.colorAttachments[0].loadOp=this.#loadOp}get clearValue(){return this.#clearValue}set clearValue(val){this.#clearValue=val;this.#descriptor.colorAttachments[0].clearValue=this.#clearValue}get descriptor(){return this.#descriptor}get topology(){return this.#topology}set topology(val){this.#topology=val}get cullMode(){return this.#cullMode}set cullMode(val){this.#cullMode=val}get frontFace(){return this.#frontFace}set frontFace(val){this.#frontFace=val}get bundle(){return this.#bundle}set bundle(val){this.#bundle=val}get device(){return this.#device}set device(val){this.#device=val}addPoint(coordinate,width,height,colors,canvas1,useTexture=false){const{x,y,z}=coordinate;const nx=getWGSLCoordinate(x,canvas1.width);const ny=getWGSLCoordinate(y,canvas1.height,true);const nw=getWGSLCoordinate(x+width,canvas1.width);const nh=getWGSLCoordinate(y+height,canvas1.height);const nz=z;const normals=[0,0,1];const id=this.#meshCounter;const{r:r0,g:g0,b:b0,a:a0}=colors[0];const{r:r1,g:g1,b:b1,a:a1}=colors[1];const{r:r2,g:g2,b:b2,a:a2}=colors[2];const{r:r3,g:g3,b:b3,a:a3}=colors[3];this.#vertexArray.push(+nx,+ny,nz,1,r0,g0,b0,a0,(+nx+1)*.5,(+ny+1)*.5,...normals,id,...BARYCENTRICS[0],+nx,-nh,nz,1,r1,g1,b1,a1,(+nx+1)*.5,(-nh+1)*.5,...normals,id,...BARYCENTRICS[1],+nw,+ny,nz,1,r2,g2,b2,a2,(+nw+1)*.5,(+ny+1)*.5,...normals,id,...BARYCENTRICS[2]);this.#vertexArray.push(+nx,-nh,nz,1,r1,g1,b1,a1,(+nx+1)*.5,(-nh+1)*.5,...normals,id,...BARYCENTRICS[0],+nw,-nh,nz,1,r3,g3,b3,a3,(+nw+1)*.5,(-nh+1)*.5,...normals,id,...BARYCENTRICS[1],+nw,+ny,nz,1,r2,g2,b2,a2,(+nw+1)*.5,(+ny+1)*.5,...normals,id,...BARYCENTRICS[2]);const mesh={name:"_plane_",id,instanceCount:1,verticesCount:6};this.#meshes.push(mesh);++this.#meshCounter;return mesh}addPlane(name,coordinate={x:0,y:0,z:0},dimensions={width:1,height:1},color={r:1,g:0,b:1,a:0},segments={x:1,y:1}){const{x,y,z}=coordinate;const{width,height}=dimensions;const{x:sx,y:sy}=segments;const hw=width/2;const hh=height/2;const{r,g,b,a}=color;const normal=[0,0,1];const id=this.#meshCounter;const grid=[];for(let iy=0;iy<=sy;iy++){const v=iy/sy;const posY=y-hh+v*height;for(let ix=0;ix<=sx;ix++){const u=ix/sx;const posX=x-hw+u*width;grid.push({position:[posX,posY,z],uv:[u,v]})}}for(let iy=0;iy<sy;iy++){for(let ix=0;ix<sx;ix++){const rowSize=sx+1;const i0=iy*rowSize+ix;const i1=i0+1;const i2=i0+rowSize;const i3=i2+1;const quad=[grid[i0],grid[i1],grid[i3],grid[i0],grid[i3],grid[i2]];quad.forEach(({position:[vx,vy,vz],uv:[u,v]},i)=>{this.#vertexArray.push(+vx,+vy,+vz,1,r,g,b,a,u,v,...normal,id,...BARYCENTRICS[i%3])})}}const mesh={name,id,instanceCount:1,verticesCount:sx*sy*6};this.#meshes.push(mesh);++this.#meshCounter;return mesh}addCube(name,coordinate={x:0,y:0,z:0},dimensions={width:1,height:1,depth:1},color={r:1,g:0,b:1,a:0}){const{x,y,z}=coordinate;const{width,height,depth}=dimensions;const hw=width/2;const hh=height/2;const hd=depth/2;const corners=[[x-hw,y-hh,z-hd],[x+hw,y-hh,z-hd],[x+hw,y+hh,z-hd],[x-hw,y+hh,z-hd],[x-hw,y-hh,z+hd],[x+hw,y-hh,z+hd],[x+hw,y+hh,z+hd],[x-hw,y+hh,z+hd]];const faceUVs=[[[0,0],[1,0],[1,1],[0,1]],[[0,0],[1,0],[1,1],[0,1]],[[0,0],[1,0],[1,1],[0,1]],[[0,0],[1,0],[1,1],[0,1]],[[0,0],[1,0],[1,1],[0,1]],[[0,0],[1,0],[1,1],[0,1]]];const faceNormals=[[0,0,-1],[0,0,1],[-1,0,0],[1,0,0],[0,1,0],[0,-1,0]];const faces=[[0,3,2,1],[4,5,6,7],[0,4,7,3],[5,1,2,6],[3,7,6,2],[0,1,5,4]];for(let i=0;i<6;i++){const[i0,i1,i2,i3]=faces[i];const{r,g,b,a}=color;const normals=faceNormals[i];const v=[corners[i0],corners[i1],corners[i2],corners[i3]];const uv=faceUVs[i];const verts=[[v[0],uv[0]],[v[1],uv[1]],[v[2],uv[2]],[v[0],uv[0]],[v[2],uv[2]],[v[3],uv[3]]];verts.forEach(([[vx,vy,vz],[u,v]],i)=>{this.#vertexArray.push(+vx,+vy,+vz,1,r,g,b,a,u,v,...normals,this.#meshCounter,...BARYCENTRICS[i%3])})}const mesh={name,id:this.#meshCounter,instanceCount:1,verticesCount:36};this.#meshes.push(mesh);++this.#meshCounter;return mesh}addSphere(name,coordinate={x:0,y:0,z:0},color={r:1,g:0,b:1,a:0},radius=1,segments=16,rings=12){const{x,y,z}=coordinate;const{r,g,b,a}=color;const vertexGrid=[];for(let lat=0;lat<=rings;lat++){const theta=lat*Math.PI/rings;const sinTheta=Math.sin(theta);const cosTheta=Math.cos(theta);vertexGrid[lat]=[];for(let lon=0;lon<=segments;lon++){const phi=lon*2*Math.PI/segments;const sinPhi=Math.sin(phi);const cosPhi=Math.cos(phi);const nx=cosPhi*sinTheta;const ny=cosTheta;const nz=sinPhi*sinTheta;const vx=x+radius*nx;const vy=y+radius*ny;const vz=z+radius*nz;const u=lon/segments;const v=lat/rings;vertexGrid[lat][lon]=[vx,vy,vz,1,r,g,b,a,u,v,nx,ny,nz,this.#meshCounter]}}const b0=BARYCENTRICS[0];const b1=BARYCENTRICS[1];const b2=BARYCENTRICS[2];for(let lat=0;lat<rings;lat++){for(let lon=0;lon<segments;lon++){const v1=vertexGrid[lat][lon];const v2=vertexGrid[lat+1][lon];const v3=vertexGrid[lat+1][lon+1];const v4=vertexGrid[lat][lon+1];this.#vertexArray.push(...v1,...b0,...v3,...b1,...v2,...b2);this.#vertexArray.push(...v1,...b0,...v4,...b1,...v3,...b2)}}const mesh={name,id:this.#meshCounter,instanceCount:1,verticesCount:rings*segments*6};this.#meshes.push(mesh);++this.#meshCounter;return mesh}addTorus(name,coordinate={x:0,y:0,z:0},radius=1,tube=.4,radialSegments=32,tubularSegments=24,color={r:1,g:0,b:1,a:1}){const{x,y,z}=coordinate;const{r,g,b,a}=color;const vertices=[];const normals=[];const uvs=[];const indices=[];for(let k=0;k<=radialSegments;k++){const v=k/radialSegments*Math.PI*2;const cosV=Math.cos(v);const sinV=Math.sin(v);for(let i=0;i<=tubularSegments;i++){const u=i/tubularSegments*Math.PI*2;const cosU=Math.cos(u);const sinU=Math.sin(u);const tx=(radius+tube*cosV)*cosU+x;const ty=(radius+tube*cosV)*sinU+y;const tz=tube*sinV+z;const nx=cosV*cosU;const ny=cosV*sinU;const nz=sinV;vertices.push([tx,ty,tz]);normals.push([nx,ny,nz]);uvs.push([i/tubularSegments,k/radialSegments])}}for(let k=1;k<=radialSegments;k++){for(let i=1;i<=tubularSegments;i++){const a=(tubularSegments+1)*k+i-1;const b=(tubularSegments+1)*(k-1)+i-1;const c=(tubularSegments+1)*(k-1)+i;const d=(tubularSegments+1)*k+i;indices.push([a,b,d]);indices.push([b,c,d])}}for(const[i0,i1,i2]of indices){for(const i of[i0,i1,i2]){const[vx,vy,vz]=vertices[i];const[nx,ny,nz]=normals[i];const[u,v]=uvs[i];this.#vertexArray.push(vx,vy,vz,1,r,g,b,a,u,v,nx,ny,nz,this.#meshCounter,...BARYCENTRICS[i%3])}}const mesh={name,id:this.#meshCounter,instanceCount:1,verticesCount:indices.length*3};this.#meshes.push(mesh);++this.#meshCounter;return mesh}addCylinder(name,coordinate={x:0,y:0,z:0},radius=.5,height=1,radialSegments=32,cap=true,color={r:1,g:0,b:1,a:1}){const{x:cx,y:cy,z:cz}=coordinate;const{r,g,b,a}=color;const halfHeight=height/2;const vertices=[];const normals=[];const uvs=[];const indices=[];for(let i=0;i<=radialSegments;i++){const theta=i/radialSegments*Math.PI*2;const cosTheta=Math.cos(theta);const sinTheta=Math.sin(theta);const px=cx+radius*cosTheta;const pz=cz+radius*sinTheta;vertices.push([px,cy-halfHeight,pz]);normals.push([cosTheta,0,sinTheta]);uvs.push([i/radialSegments,0]);vertices.push([px,cy+halfHeight,pz]);normals.push([cosTheta,0,sinTheta]);uvs.push([i/radialSegments,1])}for(let i=0;i<radialSegments;i++){const base=i*2;indices.push([base,base+1,base+3]);indices.push([base,base+3,base+2])}if(cap){const bottomCenterIndex=vertices.length;vertices.push([cx,cy-halfHeight,cz]);normals.push([0,-1,0]);uvs.push([.5,.5]);const topCenterIndex=vertices.length;vertices.push([cx,cy+halfHeight,cz]);normals.push([0,1,0]);uvs.push([.5,.5]);for(let i=0;i<radialSegments;i++){const theta=i/radialSegments*Math.PI*2;const nextTheta=(i+1)/radialSegments*Math.PI*2;const x0=cx+radius*Math.cos(theta);const z0=cz+radius*Math.sin(theta);const x1=cx+radius*Math.cos(nextTheta);const z1=cz+radius*Math.sin(nextTheta);const bottomIdx0=vertices.length;vertices.push([x0,cy-halfHeight,z0]);normals.push([0,-1,0]);uvs.push([.5+.5*Math.cos(theta),.5+.5*Math.sin(theta)]);const bottomIdx1=vertices.length;vertices.push([x1,cy-halfHeight,z1]);normals.push([0,-1,0]);uvs.push([.5+.5*Math.cos(nextTheta),.5+.5*Math.sin(nextTheta)]);indices.push([bottomCenterIndex,bottomIdx0,bottomIdx1]);const topIdx0=vertices.length;vertices.push([x0,cy+halfHeight,z0]);normals.push([0,1,0]);uvs.push([.5+.5*Math.cos(theta),.5+.5*Math.sin(theta)]);const topIdx1=vertices.length;vertices.push([x1,cy+halfHeight,z1]);normals.push([0,1,0]);uvs.push([.5+.5*Math.cos(nextTheta),.5+.5*Math.sin(nextTheta)]);indices.push([topCenterIndex,topIdx1,topIdx0])}}for(const ii of indices){ii.forEach((i,k)=>{const[vx,vy,vz]=vertices[i];const[nx,ny,nz]=normals[i];const[u,v]=uvs[i];this.#vertexArray.push(vx,vy,vz,1,r,g,b,a,u,v,nx,ny,nz,this.#meshCounter,...BARYCENTRICS[k%3])})}const mesh={name,id:this.#meshCounter,instanceCount:1,verticesCount:indices.length*3};this.#meshes.push(mesh);++this.#meshCounter;return mesh}addMesh(name,vertices,colors,colorSize,uvs,normals,indices){const verticesCount=indices.length;for(let i=0;i<verticesCount;i++){const index=indices[i];const vertex=vertices.slice(index*3,index*3+3);const color=colors?.slice(index*colorSize,index*colorSize+colorSize);const uv=uvs.slice(index*2,index*2+2);const normal=normals.slice(index*3,index*3+3);const[x,y,z]=vertex;const[r,g,b]=color||[1,0,1];const[u,v]=uv;this.#vertexArray.push(+x,+y,+z,1,r,g,b,1,u,v,...normal,this.#meshCounter,...BARYCENTRICS[i%3])}const mesh={name,id:this.#meshCounter,instanceCount:1,verticesCount};this.#meshes.push(mesh);++this.#meshCounter;return mesh}get meshes(){return this.#meshes}}const vert$9=`

@vertex
fn main(in: VertexIn) -> FragmentIn {

    return defaultVertexBody(in.position, in.color, in.uv, in.normal);
}
`;const texture=`
fn texture(texture:texture_2d<f32>, aSampler:sampler, uv:vec2f, crop:bool) -> vec4f {
    let flipTexture = vec2(1.,-1.);
    let flipTextureCoordinates = vec2(-1.,1.);
    let dims:vec2u = textureDimensions(texture, 0);
    let dimsF32 = vec2f(dims);

    let minScreenSize = params.screen.y;
    let imageRatio = dimsF32 / minScreenSize;

    let displaceImagePosition =  vec2(0., 1.);

    let imageUV = uv / imageRatio * flipTexture + displaceImagePosition;

    var rgbaImage = textureSample(texture, aSampler, imageUV);

    // e.g. if uv.x < 0. OR uv.y < 0. || uv.x > imageRatio.x OR uv.y > imageRatio.y
    if (crop && (any(uv < vec2(0.0)) || any(uv > imageRatio))) {
        rgbaImage = vec4(0.);
    }

    return rgbaImage;
}
`;const texturePosition=`
fn texturePosition(texture:texture_2d<f32>, aSampler:sampler, position:vec2f, uv:vec2f, crop:bool) -> vec4f {
    let flipTexture = vec2(1.,-1.);
    let flipTextureCoordinates = vec2(-1.,1.);
    let dims: vec2<u32> = textureDimensions(texture, 0);
    let dimsF32 = vec2f(dims);

    let minScreenSize = params.screen.y;
    let imageRatio = dimsF32 / minScreenSize;

    let displaceImagePosition = position * flipTextureCoordinates / imageRatio + vec2(0., 1.);
    let top = position + vec2(0, imageRatio.y);

    let imageUV = uv / imageRatio * flipTexture + displaceImagePosition;
    var rgbaImage = textureSample(texture, aSampler, imageUV);

    // e.g. if uv.x < 0. OR uv.y < 0. || uv.x > imageRatio.x OR uv.y > imageRatio.y
    if (crop && (any(uv < position) || any(uv > position + imageRatio))) {
        rgbaImage = vec4(0.);
    }

    return rgbaImage;
}
`;const pixelateTexturePosition=`
fn pixelateTexturePosition(texture:texture_2d<f32>, textureSampler:sampler, position:vec2f, pixelsWidth:f32, pixelsHeight:f32, uv:vec2f) -> vec4f {
    let dx = pixelsWidth * (1. / params.screen.x);
    let dy = pixelsHeight * (1. / params.screen.y);

    let coord = vec2(dx*floor( uv.x / dx), dy * floor( uv.y / dy));

    //texturePosition(texture:texture_2d<f32>, aSampler:sampler, position:vec2f, uv:vec2f, crop:bool) -> vec4f {
    return texturePosition(texture, textureSampler, position, coord, true);
}
`;const frag$9=`

${texture}

@fragment
fn main(in: FragmentIn) -> @location(0) vec4f {

    let imageColor = texture(renderpass_feedbackTexture, renderpass_feedbackSampler, in.uvr, true);
    let finalColor = (imageColor + params.color_color) * params.color_blendAmount;

    return finalColor;
}
`;const color$1=new RenderPass$1(vert$9,frag$9,null,8,8,1,(points,params)=>{points.setSampler("renderpass_feedbackSampler",null).internal=true;points.setTexture2d("renderpass_feedbackTexture",true).internal=true;points.setUniform("color_blendAmount",params.blendAmount||.5);points.setUniform("color_color",params.color||[1,.75,.79,1],"vec4f")});color$1.required=["color","blendAmount"];color$1.name="Color";const vert$8=`

@vertex
fn main(in: VertexIn) -> FragmentIn {

    return defaultVertexBody(in.position, in.color, in.uv, in.normal);
}
`;const fnusin=`
fn fnusin(speed: f32) -> f32{
    return (sin(params.time * speed) + 1.) * .5;
}
`;const RED=`
const RED = vec4(1.,0.,0.,1.);
`;const GREEN=`
const GREEN = vec4(0.,1.,0.,1.);
`;const BLUE=`
const BLUE = vec4(0.,0.,1.,1.);
`;const WHITE=`
const WHITE = vec4(1.,1.,1.,1.);
`;const bloom$1=`
fn bloom(input:f32, iterations:i32, intensity:f32) -> f32 {
    var output = 0.;
    let iterationsF32 = f32(iterations);
    for (var k = 0; k < iterations; k++) {
        let kf32 = f32(k);
        for (var n = 0; n < iterations; n++) {
            let coef = cos(2. * PI * kf32 * f32(n) / iterationsF32 );
            output += input * coef * intensity;
        }
    }
    return output;
}
`;const brightness=`
fn brightness(color:vec4f) -> f32 {
    // // Standard
    // LuminanceA = (0.2126*R) + (0.7152*G) + (0.0722*B)
    // // Percieved A
    // LuminanceB = (0.299*R + 0.587*G + 0.114*B)
    // // Perceived B, slower to calculate
    // LuminanceC = sqrt(0.299*(R**2) + 0.587*(G**2) + 0.114*(B**2))
    return (0.2126 * color.r) + (0.7152 * color.g) + (0.0722 * color.b);
}
`;const frag$8=`

${fnusin}
${texturePosition}
${brightness}
${WHITE}

@fragment
fn main(in: FragmentIn) -> @location(0) vec4f {

    let imageColor = texturePosition(renderpass_feedbackTexture, renderpass_feedbackSampler, vec2(0., 0), in.uvr, true);
    let finalColor:vec4f = brightness(imageColor) * WHITE;

    return finalColor;
}
`;const grayscale=new RenderPass$1(vert$8,frag$8,null,8,8,1,(points,params)=>{points.setSampler("renderpass_feedbackSampler",null).internal=true;points.setTexture2d("renderpass_feedbackTexture",true).internal=true});grayscale.name="Grayscale";const vert$7=`

@vertex
fn main(in: VertexIn) -> FragmentIn {

    return defaultVertexBody(in.position, in.color, in.uv, in.normal);
}
`;const frag$7=`

${texturePosition}

@fragment
fn main(in: FragmentIn) -> @location(0) vec4f {

    let imageColor = texturePosition(renderpass_feedbackTexture, renderpass_feedbackSampler, vec2(0., 0), in.uvr, true);


    // --------- chromatic displacement vector
    let cdv = vec2(params.chromaticAberration_distance, 0.);
    let d = distance(vec2(.5,.5), in.uvr);
    let imageColorR = texturePosition(renderpass_feedbackTexture, renderpass_feedbackSampler, vec2(0.) * in.ratio, in.uvr + cdv * d, true).r;
    let imageColorG = texturePosition(renderpass_feedbackTexture, renderpass_feedbackSampler, vec2(0.) * in.ratio, in.uvr, true).g;
    let imageColorB = texturePosition(renderpass_feedbackTexture, renderpass_feedbackSampler, vec2(0.) * in.ratio, in.uvr - cdv * d, true).b;

    let finalColor:vec4f = vec4(imageColorR, imageColorG, imageColorB, 1);

    return finalColor;
}
`;const chromaticAberration=new RenderPass$1(vert$7,frag$7,null,8,8,1,(points,params)=>{points.setSampler("renderpass_feedbackSampler",null).internal=true;points.setTexture2d("renderpass_feedbackTexture",true).internal=true;points.setUniform("chromaticAberration_distance",params.distance||.02)});chromaticAberration.required=["distance"];chromaticAberration.name="Chromatic Aberration";const vert$6=`

@vertex
fn main(in: VertexIn) -> FragmentIn {

    return defaultVertexBody(in.position, in.color, in.uv, in.normal);
}
`;const frag$6=`

${texturePosition}
${pixelateTexturePosition}

@fragment
fn main(in: FragmentIn) -> @location(0) vec4f {


    let pixelatedColor = pixelateTexturePosition(
        renderpass_feedbackTexture,
        renderpass_feedbackSampler,
        vec2(0.),
        params.pixelate_pixelDims.x,
        params.pixelate_pixelDims.y,
        in.uvr
    );

    let finalColor:vec4f = pixelatedColor;

    return finalColor;
}
`;const pixelate=new RenderPass$1(vert$6,frag$6,null,8,8,1,(points,params)=>{points.setSampler("renderpass_feedbackSampler",null).internal=true;points.setTexture2d("renderpass_feedbackTexture",true).internal=true;points.setUniform("pixelate_pixelDims",params.pixelDimensions||[10,10],"vec2f")});pixelate.required=["pixelDimensions"];pixelate.name="Pixelate";const vert$5=`

@vertex
fn main(in: VertexIn) -> FragmentIn {

    return defaultVertexBody(in.position, in.color, in.uv, in.normal);
}
`;const PI=`const PI = 3.14159265;`;const polar=`
fn polar(distance: f32, radians: f32) -> vec2f {
    return vec2f(distance * cos(radians), distance * sin(radians));
}
`;const rotateVector=`
fn rotateVector(p:vec2f, rads:f32 ) -> vec2f {
    let s = sin(rads);
    let c = cos(rads);
    let xnew = p.x * c - p.y * s;
    let ynew = p.x * s + p.y * c;
    return vec2(xnew, ynew);
}
`;const snoise=`

fn mod289_v3(x: vec3f) -> vec3f {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

fn mod289_v2(x: vec2f) -> vec2f {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

fn permute(x: vec3f) -> vec3f {
    return mod289_v3(((x*34.0)+10.0)*x);
}

fn snoise(v:vec2f) -> f32 {
    let C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                       -0.577350269189626,  // -1.0 + 2.0 * C.x
                        0.024390243902439); // 1.0 / 41.0
    // First corner
    var i  = floor(v + dot(v, C.yy) );
    var x0 = v -   i + dot(i, C.xx);

    // Other corners
    var i1 = vec2(0.);
    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
    //i1.y = 1.0 - i1.x;
    //i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    if(x0.x > x0.y){ i1 = vec2(1.0, 0.0); }else{ i1 = vec2(0.0, 1.0); }
    //x0 = x0 - 0.0 + 0.0 * C.xx ;
    // x1 = x0 - i1 + 1.0 * C.xx ;
    // x2 = x0 - 1.0 + 2.0 * C.xx ;
    var x12 = x0.xyxy + C.xxzz;
    //x12.xy -= i1;
    x12 = vec4(x12.xy - i1, x12.zw); // ?? fix

    // Permutations
    i = mod289_v2(i); // Avoid truncation effects in permutation
    let p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
          + i.x + vec3(0.0, i1.x, 1.0 ));

    var m = max(vec3(0.5) - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), vec3(0.0));
    m = m*m ;
    m = m*m ;

    // Gradients: 41 points uniformly over a line, mapped onto a diamond.
    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

    let x = 2.0 * fract(p * C.www) - 1.0;
    let h = abs(x) - 0.5;
    let ox = floor(x + 0.5);
    let a0 = x - ox;

    // Normalise gradients implicitly by scaling m
    // Approximation of: m *= inversesqrt( a0*a0 + h*h );
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

    // Compute final noise value at P
    var g = vec3(0.);
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    //g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    g = vec3(g.x,a0.yz * x12.xz + h.yz * x12.yw);
    return 130.0 * dot(m, g);
  }
`;const frag$5=`

${texture}
${rotateVector}
${snoise}
${PI}
${WHITE}
${polar}

fn angle(p1:vec2f, p2:vec2f) -> f32 {
    let d = p1 - p2;
    return abs(atan2(d.y, d.x)) / PI;
}

@fragment
fn main(in: FragmentIn) -> @location(0) vec4f {

    let imagePosition = vec2(0.0,0.0) * in.ratio;
    let center = vec2(.5,.5) * in.ratio;
    let d = distance(center, in.uvr); // sqrt(dot(d, d));

    //vector from center to current fragment
    let vectorToCenter = in.uvr - center;
    let sqrtDotCenter = sqrt(dot(center, center));

    //amount of effect
    let power =  2.0 * PI / (2.0 * sqrtDotCenter )  * (params.lensDistortion_amount - 0.5);
    //radius of 1:1 effect
    var bind = .0;
    if (power > 0.0){
        //stick to corners
        bind = sqrtDotCenter;
    } else {
        //stick to borders
        if (in.ratio.x < 1.0) {
            bind = center.x;
        } else {
            bind = center.y;
        };
    }

    //Weird formulas
    var nuv = in.uvr;
    if (power > 0.0){//fisheye
        nuv = center + normalize(vectorToCenter) * tan(d * power) * bind / tan( bind * power);
    } else if (power < 0.0){//antifisheye
        nuv = center + normalize(vectorToCenter) * atan(d * -power * 10.0) * bind / atan(-power * bind * 10.0);
    } else {
        nuv = in.uvr;
    }

    // let imageColor = texturePosition(renderpass_feedbackTexture, renderpass_feedbackSampler, imagePosition, nuv, false);


    // Chromatic Aberration --
    // --------- chromatic displacement vector
    let cdv = vec2(params.lensDistortion_distance, 0.);
    // let dis = distance(vec2(.5,.5), in.uvr);
    let imageColorR = texture(renderpass_feedbackTexture, renderpass_feedbackSampler, nuv + cdv * params.lensDistortion_amount , true).r;
    let imageColorG = texture(renderpass_feedbackTexture, renderpass_feedbackSampler, nuv, true).g;
    let imageColorB = texture(renderpass_feedbackTexture, renderpass_feedbackSampler, nuv - cdv * params.lensDistortion_amount , true).b;

    let chromaticAberration:vec4f = vec4(imageColorR, imageColorG, imageColorB, 1);
    // -- Chromatic Aberration


    let finalColor = chromaticAberration;
    // let finalColor = vec4(nuv,0,1) * WHITE;

    return finalColor;
}
`;const lensDistortion=new RenderPass$1(vert$5,frag$5,null,8,8,1,(points,params)=>{points.setSampler("renderpass_feedbackSampler",null).internal=true;points.setTexture2d("renderpass_feedbackTexture",true).internal=true;points.setUniform("lensDistortion_amount",params.amount||.4);points.setUniform("lensDistortion_distance",params.distance||.01)});lensDistortion.required=["amount","distance"];lensDistortion.name="Lens Distortion";const vert$4=`

@vertex
fn main(in: VertexIn) -> FragmentIn {

    return defaultVertexBody(in.position, in.color, in.uv, in.normal);
}
`;const rand=`
var<private> rand_seed : vec2f;

fn rand() -> f32 {
    rand_seed.x = fract(cos(dot(rand_seed, vec2f(23.14077926, 232.61690225))) * 136.8168);
    rand_seed.y = fract(cos(dot(rand_seed, vec2f(54.47856553, 345.84153136))) * 534.7645);
    return rand_seed.y;
}
`;const frag$4=`

${texture}
${rand}
${snoise}

@fragment
fn main(in: FragmentIn) -> @location(0) vec4f {

    let imageColor = texture(renderpass_feedbackTexture, renderpass_feedbackSampler, in.uvr, true);

    rand_seed = in.uvr + params.time;

    let noise = rand() * .5 + .5;
    return (imageColor + imageColor * noise)  * .5;
}
`;const filmgrain=new RenderPass$1(vert$4,frag$4,null,8,8,1,(points,params)=>{points.setSampler("renderpass_feedbackSampler",null).internal=true;points.setTexture2d("renderpass_feedbackTexture",true).internal=true});filmgrain.name="Filmgrain";const vert$3=`

@vertex
fn main(in: VertexIn) -> FragmentIn {

    return defaultVertexBody(in.position, in.color, in.uv, in.normal);
}
`;const frag$3=`

${texturePosition}
${bloom$1}
${brightness}
${PI}

@fragment
fn main(in: FragmentIn) -> @location(0) vec4f {

    let startPosition = vec2(0.,0.);
    let rgbaImage = texturePosition(renderpass_feedbackTexture, renderpass_feedbackSampler, startPosition, in.uvr, false); //* .998046;

    let input = brightness(rgbaImage);
    let bloomVal = bloom(input, i32(params.bloom_iterations), params.bloom_amount);
    let rgbaBloom = vec4(bloomVal);

    let finalColor:vec4f = rgbaImage + rgbaBloom;

    return finalColor;
}
`;const bloom=new RenderPass$1(vert$3,frag$3,null,8,8,1,(points,params)=>{points.setSampler("renderpass_feedbackSampler",null).internal=true;points.setTexture2d("renderpass_feedbackTexture",true).internal=true;points.setUniform("bloom_amount",params.amount||.5);points.setUniform("bloom_iterations",params.iterations||2)});bloom.required=["amount","iterations"];bloom.name="Bloom";const vert$2=`

@vertex
fn main(in: VertexIn) -> FragmentIn {

    return defaultVertexBody(in.position, in.color, in.uv, in.normal);
}
`;const blur9=`
fn blur9(image: texture_2d<f32>, imageSampler:sampler, position:vec2f, uv:vec2f, resolution: vec2f, direction: vec2f) -> vec4f {
    var color = vec4(0.0);
    let off1 = vec2(1.3846153846) * direction;
    let off2 = vec2(3.2307692308) * direction;
    color += texturePosition(image, imageSampler, position, uv, true) * 0.2270270270;
    color += texturePosition(image, imageSampler, position, uv + (off1 / resolution), true) * 0.3162162162;
    color += texturePosition(image, imageSampler, position, uv - (off1 / resolution), true) * 0.3162162162;
    color += texturePosition(image, imageSampler, position, uv + (off2 / resolution), true) * 0.0702702703;
    color += texturePosition(image, imageSampler, position, uv - (off2 / resolution), true) * 0.0702702703;
    return color;
}
`;const frag$2=`

${texturePosition}
${PI}
${rotateVector}
${blur9}

@fragment
fn main(in: FragmentIn) -> @location(0) vec4f {

    return blur9(
        renderpass_feedbackTexture,
        renderpass_feedbackSampler,
        vec2(),
        in.uvr,
        params.blur_resolution, // resolution
        rotateVector(params.blur_direction, params.blur_radians) // direction
    );

}
`;const blur=new RenderPass$1(vert$2,frag$2,null,8,8,1,(points,params)=>{points.setSampler("renderpass_feedbackSampler",null).internal=true;points.setTexture2d("renderpass_feedbackTexture",true).internal=true;points.setUniform("blur_resolution",params.resolution||[50,50],"vec2f");points.setUniform("blur_direction",params.direction||[.4,.4],"vec2f");points.setUniform("blur_radians",params.radians||0)});blur.required=["resolution","direction","radians"];blur.name="Blur";const vert$1=`

@vertex
fn main(in: VertexIn) -> FragmentIn {

    return defaultVertexBody(in.position, in.color, in.uv, in.normal);
}
`;const frag$1=`

${texturePosition}
${snoise}

@fragment
fn main(in: FragmentIn) -> @location(0) vec4f {

    let scale = params.waves_scale;
    let intensity = params.waves_intensity;
    let n1 = (snoise(in.uv / scale + vec2(.03, .4) * params.time) * .5 + .5) * intensity;
    let n2 = (snoise(in.uv / scale + vec2(.3, .02) * params.time) * .5 + .5) * intensity;
    let n = n1 + n2;

    let imageColor = texturePosition(renderpass_feedbackTexture, renderpass_feedbackSampler, vec2(0., 0), in.uvr + n2, true);
    let finalColor:vec4f = imageColor;

    return finalColor;
}
`;const waves=new RenderPass$1(vert$1,frag$1,null,8,8,1,(points,params)=>{points.setSampler("renderpass_feedbackSampler",null).internal=true;points.setTexture2d("renderpass_feedbackTexture",true).internal=true;points.setUniform("waves_scale",params.scale||.45);points.setUniform("waves_intensity",params.intensity||.03)});waves.required=["scale","intensity"];waves.name="Waves";const vert=`

@vertex
fn main(in: VertexIn) -> FragmentIn {

    return defaultVertexBody(in.position, in.color, in.uv, in.normal);
}
`;const sdfRect=`

fn sdfRect(startPoint:vec2f, endPoint:vec2f, uv:vec2f) -> f32 {
    let value = select(
        0.,
        1.,
        (startPoint.x < uv.x) &&
        (startPoint.y < uv.y) &&
        (uv.x < endPoint.x) &&
        (uv.y < endPoint.y)
    );
    return smoothstep(0, .5,  value);
}

`;const frag=`

${fnusin}
${sdfRect}
${rotateVector}
${texture}
${RED+GREEN+BLUE}

const NUMCOLUMNS = 200.;

@fragment
fn main(in: FragmentIn) -> @location(0) vec4f {

    let numColumns = NUMCOLUMNS *  params.crt_scale;
    let numRows = NUMCOLUMNS * params.crt_scale;

    let pixelsWidth = params.screen.x / numColumns;
    let pixelsHeight = params.screen.y / numRows;
    let dx = pixelsWidth * (1. / params.screen.x);
    let dy = pixelsHeight * (1. / params.screen.y);

    // if column is pair then displace by this amount
    let x = select(0., .5, floor(in.uvr.x / dx) % 2 == 0.);

    let pixeleduv = vec2(dx*floor( in.uvr.x / dx), dy * floor(in.uvr.y / dy + x));
    let pixeleduvColor = vec4(pixeleduv, 0, 1);

    let subuv = fract(in.uvr * vec2(numColumns, numRows) + vec2(0,x));
    let subuvColor = vec4(subuv, 0, 1);

    // --------- chromatic displacement vector
    let cdv = vec2(params.crt_displacement, 0.);
    let imageColorG = texture(renderpass_feedbackTexture, renderpass_feedbackSampler, pixeleduv, true).g;
    let imageColorR = texture(renderpass_feedbackTexture, renderpass_feedbackSampler, pixeleduv + cdv, true).r;
    let imageColorB = texture(renderpass_feedbackTexture, renderpass_feedbackSampler, pixeleduv - cdv, true).b;

    let bottom_left = vec2(.0, .0);
    let top_right = bottom_left + vec2(.33, 1.);

    let margin = vec2(.01,0.) * 4;
    let margin_v = vec2(.0, .01) * 8;
    let offset = vec2(.33,0);
    let redSlot = RED * imageColorR * sdfRect(margin+margin_v+bottom_left + offset * 0, top_right - margin - margin_v + offset * 0, subuv); // subuv
    let greenSlot = GREEN * imageColorG * sdfRect(margin+margin_v+bottom_left + offset * 1, top_right - margin - margin_v + offset * 1, subuv);
    let blueSlot = BLUE * imageColorB * sdfRect(margin+margin_v+bottom_left + offset * 2, top_right - margin - margin_v + offset * 2, subuv);

    let finalColor = redSlot + greenSlot + blueSlot;

    return finalColor;
}
`;const color=new RenderPass$1(vert,frag,null,8,8,1,(points,params)=>{points.setSampler("renderpass_feedbackSampler",null).internal=true;points.setTexture2d("renderpass_feedbackTexture",true).internal=true;points.setUniform("crt_scale",params.scale||.39);points.setUniform("crt_displacement",params.displacement||.013)});color.required=["scale","displacement"];color.name="CRT";class RenderPasses{static COLOR=color$1;static GRAYSCALE=grayscale;static CHROMATIC_ABERRATION=chromaticAberration;static PIXELATE=pixelate;static LENS_DISTORTION=lensDistortion;static FILM_GRAIN=filmgrain;static BLOOM=bloom;static BLUR=blur;static WAVES=waves;static CRT=color}class UniformKeys{static TIME="time";static DELTA="delta";static EPOCH="epoch";static SCREEN="screen";static MOUSE="mouse";static MOUSE_CLICK="mouseClick";static MOUSE_DOWN="mouseDown";static MOUSE_WHEEL="mouseWheel";static MOUSE_DELTA="mouseDelta"}class VertexBufferInfo{#vertexSize;#vertexOffset;#colorOffset;#uvOffset;#normalOffset;#idOffset;#barycentricsOffset;#vertexCount;constructor(vertexArray,triangleDataLength=17,vertexOffset=0,colorOffset=4,uvOffset=8,normalsOffset=10,idOffset=13,barycentricsOffset=14){this.#vertexSize=vertexArray.BYTES_PER_ELEMENT*triangleDataLength;this.#vertexOffset=vertexArray.BYTES_PER_ELEMENT*vertexOffset;this.#colorOffset=vertexArray.BYTES_PER_ELEMENT*colorOffset;this.#uvOffset=vertexArray.BYTES_PER_ELEMENT*uvOffset;this.#normalOffset=vertexArray.BYTES_PER_ELEMENT*normalsOffset;this.#idOffset=vertexArray.BYTES_PER_ELEMENT*idOffset;this.#barycentricsOffset=vertexArray.BYTES_PER_ELEMENT*barycentricsOffset;this.#vertexCount=vertexArray.byteLength/this.#vertexSize}get vertexSize(){return this.#vertexSize}get vertexOffset(){return this.#vertexOffset}get colorOffset(){return this.#colorOffset}get uvOffset(){return this.#uvOffset}get normalOffset(){return this.#normalOffset}get idOffset(){return this.#idOffset}get barycentricsOffset(){return this.#barycentricsOffset}get vertexCount(){return this.#vertexCount}}class Coordinate{#x;#y;#z;#value;constructor(x=0,y=0,z=0){this.#x=x;this.#y=y;this.#z=z;this.#value=[x,y,z]}set x(value){this.#x=value;this.#value[0]=value}set y(value){this.#y=value;this.#value[1]=value}set z(value){this.#z=value;this.#value[2]=value}get x(){return this.#x}get y(){return this.#y}get z(){return this.#z}get value(){return this.#value}set(x,y,z){this.#x=x;this.#y=y;this.#z=z;this.#value[0]=x;this.#value[1]=y;this.#value[2]=z}}class RGBAColor{#value;constructor(r=0,g=0,b=0,a=1){if(r>1&&g>1&&b>1){r/=255;g/=255;b/=255;if(a>1){a/=255}}this.#value=[r,g,b,a]}set r(value){this.#value[0]=value}set g(value){this.#value[1]=value}set b(value){this.#value[2]=value}set a(value){this.#value[3]=value}get r(){return this.#value[0]}get g(){return this.#value[1]}get b(){return this.#value[2]}get a(){return this.#value[3]}get value(){return this.#value}get brightness(){let[r,g,b,a]=this.#value;return .2126*r+.7152*g+.0722*b}set brightness(value){this.#value=[value,value,value,1]}set(r,g,b,a){this.#value=[r,g,b,a]}setColor(color){this.#value=[color.r,color.g,color.b,color.a]}add(color){let[r,g,b,a]=this.#value;this.#value=[r+color.r,g+color.g,b+color.b,a+color.a]}blend(color){let[r0,g0,b0,a0]=this.#value;let[r1,b1,g1,a1]=color.value;let a01=(1-a0)*a1+a0;let r01=((1-a0)*a1*r1+a0*r0)/a01;let g01=((1-a0)*a1*g1+a0*g0)/a01;let b01=((1-a0)*a1*b1+a0*b0)/a01;this.#value=[r01,g01,b01,a01]}additive(color){let base=this.#value;let added=color.value;let mix=[];mix[3]=1-(1-added[3])*(1-base[3]);mix[0]=Math.round(added[0]*added[3]/mix[3]+base[0]*base[3]*(1-added[3])/mix[3]);mix[1]=Math.round(added[1]*added[3]/mix[3]+base[1]*base[3]*(1-added[3])/mix[3]);mix[2]=Math.round(added[2]*added[3]/mix[3]+base[2]*base[3]*(1-added[3])/mix[3]);this.#value=mix}equal(color){return this.#value[0]==color.r&&this.#value[1]==color.g&&this.#value[2]==color.b&&this.#value[3]==color.a}static average(colors){let r=0,g=0,b=0;for(let index=0;index<colors.length;index++){const color=colors[index];r+=color.r*color.r;g+=color.g*color.g;b+=color.b*color.b}return new RGBAColor(Math.sqrt(r/colors.length),Math.sqrt(g/colors.length),Math.sqrt(b/colors.length))}static difference(c1,c2){let r=0;let g=0;let b=0;if(c1&&!c1.isNull()&&c2&&!c2.isNull()){const{r:r1,g:g1,b:b1}=c1;const{r:r2,g:g2,b:b2}=c2;r=r1-r2;g=g1-g2;b=b1-b2}return new RGBAColor(r,g,b)}isNull(){const[r,g,b,a]=this.#value;return!(isNaN(r)&&isNaN(g)&&isNaN(b)&&isNaN(a))}static colorRGBEuclideanDistance(c1,c2){return Math.sqrt(Math.pow(c1.r-c2.r,2)+Math.pow(c1.g-c2.g,2)+Math.pow(c1.b-c2.b,2))}euclideanDistance(color){const[r,g,b]=this.#value;return Math.sqrt(Math.pow(r-color.r,2)+Math.pow(g-color.g,2)+Math.pow(b-color.b,2))}static getClosestColorInPalette(color,palette){if(!palette){throw"Palette should be an array of `RGBA`s"}let distance=100;let selectedColor=null;palette.forEach(paletteColor=>{let currentDistance=color.euclideanDistance(paletteColor);if(currentDistance<distance){selectedColor=paletteColor;distance=currentDistance}});return selectedColor}}class Clock{#time=0;#oldTime=0;#delta=0;constructor(){}get time(){return this.#time}get delta(){return this.#delta}#now(){return(typeof performance==="undefined"?Date:performance).now()}getDelta(){this.#delta=0;const newTime=this.#now();this.#delta=(newTime-this.#oldTime)/1e3;this.#oldTime=newTime;this.#time+=this.#delta;return this.#delta}}const defaultStructs=`

struct ComputeIn {
    @builtin(global_invocation_id) GID: vec3u,
    @builtin(workgroup_id) WID: vec3u,
    @builtin(local_invocation_id) LID: vec3u
}

struct VertexIn {
    @location(0) position:vec4f,
    @location(1) color:vec4f,
    @location(2) uv:vec2f,
    @location(3) normal:vec3f,
    @location(4) id:u32,       // mesh id
    @location(5) barycentrics: vec3f,
    @builtin(vertex_index) vertexIndex: u32,
    @builtin(instance_index) instanceIndex: u32
}

struct FragmentIn {
    @builtin(position) position: vec4f,
    @location(0) color: vec4f,
    @location(1) uv: vec2f,
    @location(2) ratio: vec2f,  // relation between params.screen.x and params.screen.y
    @location(3) uvr: vec2f,    // uv with aspect ratio corrected
    @location(4) mouse: vec2f,
    @location(5) normal: vec3f,
    @interpolate(flat) @location(6) id: u32, // mesh or instance id
    @location(7) barycentrics: vec3f,
    @location(8) world: vec3f,
}

struct Sound {
    data: array<f32, 2048>,
    //play
    //dataLength
    //duration
    //currentPosition
}

struct Event {
    updated: u32,
    // data: array<f32>
}
`;const defaultVertexBody=`
fn defaultVertexBody(position: vec4f, color: vec4f, uv: vec2f, normal: vec3f) -> FragmentIn {
    var result: FragmentIn;

    let ratioX = params.screen.x / params.screen.y;
    let ratioY = 1. / ratioX / (params.screen.y / params.screen.x);
    result.ratio = vec2(ratioX, ratioY);
    result.position = position;
    result.color = color;
    result.uv = uv;
    result.uvr = vec2(uv.x * result.ratio.x, uv.y);
    result.mouse = vec2(params.mouse.x / params.screen.x, params.mouse.y / params.screen.y);
    result.mouse = result.mouse * vec2(1.,-1.) - vec2(0., -1.); // flip and move up
    result.normal = normal;

    return result;
}
`;const size_2_align_2={size:2,align:2};const size_4_align_4={size:4,align:4};const size_6_align_8={size:6,align:8};const size_8_align_4={size:8,align:4};const size_8_align_8={size:8,align:8};const size_12_align_4={size:12,align:4};const size_12_align_16={size:12,align:16};const size_16_align_4={size:16,align:4};const size_16_align_16={size:16,align:16};const size_16_align_8={size:16,align:8};const size_24_align_8={size:24,align:8};const size_32_align_8={size:32,align:8};const size_32_align_16={size:32,align:16};const size_48_align_16={size:48,align:16};const size_64_align_16={size:64,align:16};const typeSizes={"bool":size_4_align_4,"i32":size_4_align_4,"u32":size_4_align_4,"f32":size_4_align_4,"f16":size_2_align_2,"atomic<u32>":size_4_align_4,"atomic<i32>":size_4_align_4,"vec2<bool>":size_8_align_8,"vec2<i32>":size_8_align_8,"vec2<u32>":size_8_align_8,"vec2<f32>":size_8_align_8,"vec2i":size_8_align_8,"vec2u":size_8_align_8,"vec2f":size_8_align_8,"vec2<f16>":size_4_align_4,"vec2h":size_4_align_4,"vec3<bool>":size_12_align_16,"vec3<i32>":size_12_align_16,"vec3<u32>":size_12_align_16,"vec3<f32>":size_12_align_16,"vec3i":size_12_align_16,"vec3u":size_12_align_16,"vec3f":size_12_align_16,"vec3<f16>":size_6_align_8,"vec3h":size_6_align_8,"vec4<bool>":size_16_align_16,"vec4<i32>":size_16_align_16,"vec4<u32>":size_16_align_16,"vec4<f32>":size_16_align_16,"vec4i":size_16_align_16,"vec4u":size_16_align_16,"vec4f":size_16_align_16,"vec4<f16>":size_8_align_8,"vec4h":size_8_align_8,"mat2x2<f32>":size_16_align_8,"mat2x2f":size_16_align_8,"mat2x2<f16>":size_8_align_4,"mat2x2h":size_8_align_4,"mat3x2<f32>":size_24_align_8,"mat3x2f":size_24_align_8,"mat3x2<f16>":size_12_align_4,"mat3x2h":size_12_align_4,"mat4x2<f32>":size_32_align_8,"mat4x2f":size_32_align_8,"mat4x2<f16>":size_16_align_4,"mat4x2h":size_16_align_4,"mat2x3<f32>":size_32_align_16,"mat2x3f":size_32_align_16,"mat2x3<f16>":size_16_align_8,"mat2x3h":size_16_align_8,"mat3x3<f32>":size_48_align_16,"mat3x3f":size_48_align_16,"mat3x3<f16>":size_24_align_8,"mat3x3h":size_24_align_8,"mat4x3<f32>":size_64_align_16,"mat4x3f":size_64_align_16,"mat4x3<f16>":size_32_align_8,"mat4x3h":size_32_align_8,"mat2x4<f32>":size_32_align_16,"mat2x4f":size_32_align_16,"mat2x4<f16>":size_16_align_8,"mat2x4h":size_16_align_8,"mat3x4<f32>":size_48_align_16,"mat3x4f":size_48_align_16,"mat3x4<f16>":size_24_align_8,"mat3x4h":size_24_align_8,"mat4x4<f32>":size_64_align_16,"mat4x4f":size_64_align_16,"mat4x4<f16>":size_32_align_8,"mat4x4h":size_32_align_8};const removeCommentsRE=/\/\*[\s\S]*?\*\/|\/\/.*/gim;const getStructNameRE=/struct\s+?(\w+)\s*{[^}]+}\n?/g;const insideStructRE=/struct\s+?\w+\s*{([^}]+)}\n?/g;const arrayTypeAndAmountRE=/\s*<\s*([^,]+)\s*,?\s*(\d+)?\s*>/g;const arrayIntegrityRE=/\s*(array\s*<\s*\w+\s*(?:,\s*\d+)?\s*>)\s*,?/g;function removeComments(value){const matches=value.matchAll(removeCommentsRE);for(const match of matches){const captured=match[0];value=value.replace(captured,"")}return value}function getInsideStruct(value){const matches=value.matchAll(insideStructRE);let lines=null;for(const match of matches){lines=match[1].split("\n");lines=lines.map(element=>element.trim()).filter(e=>e!=="")}return lines}function getStructDataByName(value){const matches=value.matchAll(getStructNameRE);let result=new Map;for(const match of matches){const captured=match[0];const name=match[1];const lines=getInsideStruct(captured);const types=lines.map(l=>{const right=l.split(":")[1];let type="";if(isArray(right)){const arrayMatch=right.matchAll(arrayIntegrityRE);type=arrayMatch.next().value[1]}else{type=right.split(",")[0].trim()}return type});const names=lines.map(l=>{const left=l.split(":")[0];let name="";name=left.split(",")[0].trim();return name});result.set(name,{captured,lines,types,unique_types:[...new Set(types)],names})}return result}function getArrayTypeAndAmount(value){const matches=value.matchAll(arrayTypeAndAmountRE);let result=[];for(const match of matches){const type=match[1];const amount=match[2];result.push({type,amount:Number(amount)})}return result}function isArray(value){return value.indexOf("array")!=-1}function getArrayTypeData(currentType,structData){const[d]=getArrayTypeAndAmount(currentType);if(!d){throw`${currentType} seems to have an error, maybe a wrong amount?`}if(d.amount==0){throw new Error(`${currentType} has an amount of 0`)}let currentTypeData=typeSizes[d.type]||structData.get(d.type);if(!currentTypeData){throw`Struct or type '${d.type}' in ${currentType} is not defined.`}if(d.amount){const t=typeSizes[d.type];if(t){currentTypeData={size:t.align*d.amount,align:t.align}}else{const sd=structData.get(d.type);if(sd){currentTypeData={size:sd.bytes*d.amount,align:sd.maxAlign}}}}return currentTypeData}function getPadding(bytes,maxSize){const remainder=bytes%maxSize;let remainingBytes=0;if(remainder){remainingBytes=maxSize-remainder}return remainingBytes}const MAX_ROW_SIZE=16;const HALF=2;const dataSize=value=>{const noCommentsValue=removeComments(value);const structData=getStructDataByName(noCommentsValue);structData.forEach(sd=>{let bytes=0;let remainingBytes=0;sd.paddings={};sd.names.forEach((name,i)=>{const type=sd.types[i];let typeSize=typeSizes[type];let repeat=0;if(!typeSize){if(type){if(isArray(type)){const[innerType]=getArrayTypeAndAmount(type);typeSize=typeSizes[innerType.type];repeat=innerType.amount;innerType.align=MAX_ROW_SIZE}else{const sd=structData.get(type);if(!sd){throw`Type or struct ${type} doesn't exist.`}typeSize={size:sd.bytes,align:MAX_ROW_SIZE}}}}const{size,align}=typeSize;const prevName=sd.names[i-1];do{let aligned=bytes%align===0;while(!aligned){remainingBytes-=HALF;bytes+=HALF;sd.paddings[prevName]||=0;sd.paddings[prevName]+=HALF;aligned=bytes%align===0}if(remainingBytes&&size>remainingBytes){bytes+=remainingBytes;sd.paddings[prevName]=remainingBytes;remainingBytes=0}bytes+=size;repeat--}while(repeat>0)remainingBytes=getPadding(bytes,MAX_ROW_SIZE)});remainingBytes=getPadding(bytes,MAX_ROW_SIZE);bytes+=remainingBytes;sd.bytes=bytes});return structData};async function loadImage(src){return new Promise((resolve,reject)=>{const img=new Image;img.src=src;img.onload=()=>resolve(img);img.onerror=err=>reject(err)})}function strToCodes(s){return Array.from(s).map(c=>c.charCodeAt(0))}function sprite(atlas,ctx,index,size,finalIndex){const{width}=atlas;const numColumns=width/size.x;const x=index%numColumns;const y=Math.floor(index/numColumns);ctx.drawImage(atlas,x*size.x,y*size.y,size.x,size.y,size.x*finalIndex,0,size.x,size.y)}function strToImage(str,atlasImg,size,offset=0){const chars=strToCodes(str);const canvas1=document.createElement("canvas");canvas1.width=chars.length*size.x;canvas1.height=size.y;const ctx=canvas1.getContext("2d");chars.forEach((c,i)=>sprite(atlasImg,ctx,c+offset,size,i));return canvas1.toDataURL("image/png")}class LayersArray extends Array{#buffer=null;#shaderType=null;constructor(...elements){super(...elements)}get buffer(){return this.#buffer}set buffer(v){this.#buffer=v}get shaderType(){return this.#shaderType}set shaderType(v){this.#shaderType=v}}class UniformsArray extends Array{#buffer=null;constructor(...elements){super(...elements)}get buffer(){return this.#buffer}set buffer(v){this.#buffer=v}}const R="r";const RW="rw";const cache={[GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT]:{[GPUShaderStage.COMPUTE]:RW,[GPUShaderStage.VERTEX]:R,[GPUShaderStage.FRAGMENT]:R},[GPUShaderStage.COMPUTE]:{[GPUShaderStage.COMPUTE]:RW,[GPUShaderStage.VERTEX]:null,[GPUShaderStage.FRAGMENT]:null},[GPUShaderStage.VERTEX]:{[GPUShaderStage.COMPUTE]:null,[GPUShaderStage.VERTEX]:R,[GPUShaderStage.FRAGMENT]:null},[GPUShaderStage.FRAGMENT]:{[GPUShaderStage.COMPUTE]:null,[GPUShaderStage.VERTEX]:null,[GPUShaderStage.FRAGMENT]:RW},[GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX]:{[GPUShaderStage.COMPUTE]:RW,[GPUShaderStage.VERTEX]:R,[GPUShaderStage.FRAGMENT]:null},[GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT]:{[GPUShaderStage.COMPUTE]:RW,[GPUShaderStage.VERTEX]:null,[GPUShaderStage.FRAGMENT]:RW},[GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT]:{[GPUShaderStage.COMPUTE]:null,[GPUShaderStage.VERTEX]:R,[GPUShaderStage.FRAGMENT]:R}};function getStorageAccessMode(currentStage,storageShaderTypes){return cache[storageShaderTypes][currentStage]}const bindingModes={[R]:"read",[RW]:"read_write"};const entriesModes={[R]:"read-only-storage",[RW]:"storage"};function normalize(v){const result=[0,0,0];const v0=v[0];const v1=v[1];const v2=v[2];const len=Math.sqrt(v0*v0+v1*v1+v2*v2);if(len>1e-5){result[0]=v0/len;result[1]=v1/len;result[2]=v2/len}return result}function sub(a,b){const result=[0,0,0];result[0]=a[0]-b[0];result[1]=a[1]-b[1];result[2]=a[2]-b[2];return result}function cross(a,b){const result=[0,0,0];const t1=a[2]*b[0]-a[0]*b[2];const t2=a[0]*b[1]-a[1]*b[0];result[0]=a[1]*b[2]-a[2]*b[1];result[1]=t1;result[2]=t2;return result}function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]}class Points{#canvasId=null;#canvas=null;#adapter=null;#device=null;#context=null;#presentationFormat=null;#renderPasses=null;#postRenderPasses=[];#buffer=null;#presentationSize=null;#numColumns=1;#numRows=1;#commandsFinished=[];#uniforms=new UniformsArray;#meshUniforms=new UniformsArray;#cameraUniforms=new UniformsArray;#constants=[];#storage=[];#readStorage=[];#samplers=[];#textures2d=[];#texturesDepth2d=[];#texturesToCopy=[];#textures2dArray=[];#texturesExternal=[];#texturesStorage2d=[];#bindingTextures=[];#layers=new LayersArray;#originalCanvasWidth=null;#originalCanvasHeigth=null;#clock=new Clock;#time=0;#delta=0;#epoch=0;#mouseX=0;#mouseY=0;#mouseDown=false;#mouseClick=false;#mouseWheel=false;#mouseDelta=[0,0];#fullscreen=false;#fitWindow=false;#lastFitWindow=false;#sounds=[];#events=new Map;#events_ids=0;#dataSize=null;#screenResized=false;#textureUpdated=false;constructor(canvasId){this.#canvasId=canvasId;this.#canvas=document.getElementById(this.#canvasId);if(this.#canvasId){this.#canvas.addEventListener("click",e=>{this.#mouseClick=true});this.#canvas.addEventListener("mousemove",this.#onMouseMove,{passive:true});this.#canvas.addEventListener("mousedown",e=>{this.#mouseDown=true});this.#canvas.addEventListener("mouseup",e=>{this.#mouseDown=false});this.#canvas.addEventListener("wheel",e=>{this.#mouseWheel=true;this.#mouseDelta=[e.deltaX,e.deltaY]},{passive:true});this.#originalCanvasWidth=this.#canvas.clientWidth;this.#originalCanvasHeigth=this.#canvas.clientHeight;window.addEventListener("resize",this.#resizeCanvasToFitWindow,false);document.addEventListener("fullscreenchange",e=>{this.#fullscreen=!!document.fullscreenElement;if(!this.#fullscreen&&!this.#fitWindow){this.#resizeCanvasToDefault()}if(!this.#fullscreen){this.fitWindow=this.#lastFitWindow}})}this.setUniform(UniformKeys.TIME,this.#time);this.setUniform(UniformKeys.DELTA,this.#delta);this.setUniform(UniformKeys.EPOCH,this.#epoch);this.setUniform(UniformKeys.MOUSE_CLICK,this.#mouseClick);this.setUniform(UniformKeys.MOUSE_DOWN,this.#mouseDown);this.setUniform(UniformKeys.MOUSE_WHEEL,this.#mouseWheel);this.setUniform(UniformKeys.SCREEN,[0,0],"vec2f");this.setUniform(UniformKeys.MOUSE,[0,0],"vec2f");this.setUniform(UniformKeys.MOUSE_DELTA,this.#mouseDelta,"vec2f")}#resizeCanvasToFitWindow=()=>{this.#screenResized=true;if(this.#fitWindow){const{offsetWidth,offsetHeight}=this.#canvas.parentNode;this.#canvas.width=offsetWidth;this.#canvas.height=offsetHeight;this.#setScreenSize()}};#resizeCanvasToDefault=()=>{this.#screenResized=true;this.#canvas.width=this.#originalCanvasWidth;this.#canvas.height=this.#originalCanvasHeigth;this.#setScreenSize()};#setScreenSize=()=>{this.#canvas.width=canvas.clientWidth;this.#canvas.height=canvas.clientHeight;this.#presentationSize=[this.#canvas.clientWidth,this.#canvas.clientHeight];this.#context.configure({label:"_context",device:this.#device,format:this.#presentationFormat,width:this.#presentationSize[0],height:this.#presentationSize[1],alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});this.#renderPasses.forEach(renderPass=>{renderPass.textureDepth=this.#createTextureDepth("_depthTexture")});this.#textures2d.forEach(texture2d=>{if(!texture2d.imageTexture&&texture2d.texture){this.#createTextureBindingToCopy(texture2d)}})};#onMouseMove=e=>{const rect=this.#canvas.getBoundingClientRect();this.#mouseX=e.clientX-rect.left;this.#mouseY=e.clientY-rect.top};setUniform(name,value,structName=null){const uniformToUpdate=this.#nameExists(this.#uniforms,name);if(uniformToUpdate&&structName){console.warn(`setUniform(${name}, [${value}], ${structName}) can't set the structName of an already defined uniform.`)}if(uniformToUpdate){uniformToUpdate.value=value;return uniformToUpdate}if(structName&&isArray(structName)){throw`${structName} is an array, which is currently not supported for Uniforms.`}const uniform={name:name,value:value,type:structName,size:null};Object.seal(uniform);this.#uniforms.push(uniform);return uniform}#setMeshUniform(name,value,structName=null){const uniformToUpdate=this.#nameExists(this.#meshUniforms,name);if(uniformToUpdate&&structName){console.warn(`#setMeshUniform(${name}, [${value}], ${structName}) can't set the structName of an already defined uniform.`)}if(uniformToUpdate){uniformToUpdate.value=value;return uniformToUpdate}if(structName&&isArray(structName)){throw`${structName} is an array, which is currently not supported for Uniforms.`}const uniform={name:name,value:value,type:structName,size:null};Object.seal(uniform);this.#meshUniforms.push(uniform);return uniform}#setCameraUniform(name,value,structName=null){const uniformToUpdate=this.#nameExists(this.#cameraUniforms,name);if(uniformToUpdate){uniformToUpdate.value=value;return uniformToUpdate}if(structName&&isArray(structName)){throw`${structName} is an array, which is currently not supported for Uniforms.`}const uniform={name:name,value:value,type:structName,size:null};Object.seal(uniform);this.#cameraUniforms.push(uniform);return uniform}updateUniforms(arr){arr.forEach(uniform=>{const variable=this.#uniforms.find(v=>v.name===uniform.name);if(!variable){throw"`updateUniform()` can't be called without first `setUniform()`."}variable.value=uniform.value})}setConstant(name,value,structName){const constantToUpdate=this.#nameExists(this.#constants,name);if(constantToUpdate){throw"`setConstant()` can't update a const after it has been set."}const constant={name,value,structName};this.#constants.push(constant);return constant}setStorage(name,structName,read,shaderType=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,arrayData=null){if(this.#nameExists(this.#storage,name)){throw`\`setStorage()\` You have already defined \`${name}\``}const storage={mapped:!!arrayData,name,structName,shaderType,read,buffer:null,internal:false};this.#storage.push(storage);return storage}setStorageMap(name,arrayData,structName,read=false,shaderType=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE){const storageToUpdate=this.#nameExists(this.#storage,name);if(!Array.isArray(arrayData)&&arrayData.constructor!==Uint8Array){arrayData=new Uint8Array([arrayData])}if(storageToUpdate){storageToUpdate.array=arrayData;storageToUpdate.updated=true;return storageToUpdate}const storage={stream:false,updated:true,mapped:true,name,structName,shaderType,array:arrayData,buffer:null,read,internal:false};this.#storage.push(storage);return storage}async readStorage(name){let storageItem=this.#readStorage.find(storageItem=>storageItem.name===name);let arrayBuffer=null;let arrayBufferCopy=null;if(storageItem){await storageItem.buffer.mapAsync(GPUMapMode.READ);arrayBuffer=storageItem.buffer.getMappedRange();arrayBufferCopy=new Float32Array(arrayBuffer.slice(0));storageItem.buffer.unmap()}return arrayBufferCopy}setLayers(numLayers,shaderType){for(let layerIndex=0;layerIndex<numLayers;layerIndex++){this.#layers.shaderType=shaderType;this.#layers.push({name:`layer${layerIndex}`,size:this.#canvas.width*this.#canvas.height,structName:"vec4f",structSize:16,array:null,buffer:null})}}#nameExists(arrayOfObjects,name){return arrayOfObjects.find(obj=>obj.name==name)}setSampler(name,descriptor,shaderType){if("sampler"==name){throw"setSampler: `name` can not be sampler since is a WebGPU keyword."}const exists=this.#nameExists(this.#samplers,name);if(exists){console.warn(`setSampler: \`${name}\` already exists.`);return exists}descriptor=descriptor||{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"};const sampler={name:name,descriptor:descriptor,shaderType:shaderType,resource:null,internal:false};this.#samplers.push(sampler);return sampler}setTexture2d(name,copyCurrentTexture,shaderType,renderPassIndex){const exists=this.#nameExists(this.#textures2d,name);if(exists){console.warn(`setTexture2d: \`${name}\` already exists.`);return exists}const texture2d={name,copyCurrentTexture,shaderType,texture:null,renderPassIndex,internal:false};this.#textures2d.push(texture2d);return texture2d}setTextureDepth2d(name,shaderType,renderPassIndex){const exists=this.#nameExists(this.#texturesDepth2d,name);if(exists){console.warn(`setTextureDepth2d: \`${name}\` already exists.`);return exists}renderPassIndex||=0;const textureDepth2d={name,shaderType,texture:null,renderPassIndex,internal:false};this.#texturesDepth2d.push(textureDepth2d);return textureDepth2d}copyTexture(nameTextureA,nameTextureB){const texture2d_A=this.#nameExists(this.#textures2d,nameTextureA);const texture2d_B=this.#nameExists(this.#textures2d,nameTextureB);if(!(texture2d_A&&texture2d_B)){console.error("One of the textures does not exist.")}const a=texture2d_A.texture;const cubeTexture=this.#device.createTexture({label:"_cubeTexture",size:[a.width,a.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});texture2d_B.texture=cubeTexture;this.#texturesToCopy.push({a,b:texture2d_B.texture})}async setTextureImage(name,path,shaderType=null){const texture2dToUpdate=this.#nameExists(this.#textures2d,name);const response=await fetch(path);const blob=await response.blob();const imageBitmap=await createImageBitmap(blob);if(texture2dToUpdate){if(shaderType){throw"`setTextureImage()` the param `shaderType` should not be updated after its creation."}this.#textureUpdated=true;texture2dToUpdate.imageTexture.bitmap=imageBitmap;const cubeTexture=this.#device.createTexture({label:"_cubeTexture setTextureImage",size:[imageBitmap.width,imageBitmap.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});this.#device.queue.copyExternalImageToTexture({source:imageBitmap},{texture:cubeTexture},[imageBitmap.width,imageBitmap.height]);texture2dToUpdate.texture=cubeTexture;return texture2dToUpdate}const texture2d={name:name,copyCurrentTexture:false,shaderType:shaderType,texture:null,renderPassIndex:null,imageTexture:{bitmap:imageBitmap},internal:false};this.#textures2d.push(texture2d);return texture2d}async setTextureString(name,text,path,size,offset=0,shaderType=null){const atlas=await loadImage(path);const textImg=strToImage(text,atlas,size,offset);return this.setTextureImage(name,textImg,shaderType)}async setTextureImageArray(name,paths,shaderType){if(this.#nameExists(this.#textures2dArray,name)){return}const imageBitmaps=[];for await(const path of paths){const response=await fetch(path);const blob=await response.blob();imageBitmaps.push(await createImageBitmap(blob))}const texture2dArrayItem={name:name,copyCurrentTexture:false,shaderType:shaderType,texture:null,imageTextures:{bitmaps:imageBitmaps},internal:false};this.#textures2dArray.push(texture2dArrayItem);return texture2dArrayItem}async setTextureVideo(name,path,shaderType){if(this.#nameExists(this.#texturesExternal,name)){throw`setTextureVideo: ${name} already exists.`}const video=document.createElement("video");video.loop=true;video.autoplay=true;video.muted=true;video.src=new URL(path,import.meta.url).toString();await video.play();const textureExternal={name:name,shaderType:shaderType,video:video,internal:false};this.#texturesExternal.push(textureExternal);return textureExternal}async setTextureWebcam(name,size={width:1080,height:1080},shaderType){if(this.#nameExists(this.#texturesExternal,name)){throw`setTextureWebcam: ${name} already exists.`}const video=document.createElement("video");video.muted=true;if(navigator.mediaDevices.getUserMedia){await navigator.mediaDevices.getUserMedia({video:{width:{ideal:size.width},height:{ideal:size.height}}}).then(async stream=>{video.srcObject=stream;await video.play()}).catch(err=>{throw err})}const textureExternal={name,shaderType,video,size,internal:false};this.#texturesExternal.push(textureExternal);return await new Promise(resolve=>resolve(textureExternal))}setAudio(name,path,volume,loop,autoplay){const audio=new Audio(path);audio.volume=volume;audio.autoplay=autoplay;audio.loop=loop;const sound={name:name,path:path,audio:audio,analyser:null,data:null};const audioContext=new AudioContext;const resume=_=>{audioContext.resume()};if(audioContext.state==="suspended"){document.body.addEventListener("touchend",resume,false);document.body.addEventListener("click",resume,false)}const source=audioContext.createMediaElementSource(audio);const analyser=audioContext.createAnalyser();analyser.fftSize=2048;source.connect(analyser);analyser.connect(audioContext.destination);const bufferLength=analyser.fftSize;const data=new Uint8Array(bufferLength);analyser.getByteFrequencyData(data);this.setStorageMap(name,data,"Sound").stream=true;this.setUniform(`${name}Length`,analyser.frequencyBinCount);sound.analyser=analyser;sound.data=data;this.#sounds.push(sound);return audio}setTextureStorage2d(name,shaderType){if(this.#nameExists(this.#texturesStorage2d,name)){throw`setTextureStorage2d: ${name} already exists.`}const texturesStorage2d={name:name,shaderType:shaderType,texture:null,internal:false};this.#texturesStorage2d.push(texturesStorage2d);return texturesStorage2d}setBindingTexture(writeName,readName,writeIndex,readIndex,size){if(Number.isInteger(writeIndex)&&!Number.isInteger(readIndex)||!Number.isInteger(writeIndex)&&Number.isInteger(readIndex)){throw"The parameters writeIndex and readIndex must both be declared."}const usesRenderPass=Number.isInteger(writeIndex)&&Number.isInteger(readIndex);const bindingTexture={write:{name:writeName,shaderType:GPUShaderStage.COMPUTE,renderPassIndex:writeIndex},read:{name:readName,shaderType:GPUShaderStage.FRAGMENT,renderPassIndex:readIndex},texture:null,size:size,usesRenderPass,internal:false};this.#bindingTextures.push(bindingTexture);return bindingTexture}setCameraPerspective(name,position=[0,0,-5],lookAt=[0,0,0],fov=45,near=.1,far=100,aspect=null){const fov_radians=fov*(Math.PI/180);const f=1/Math.tan(fov_radians/2);const nf=1/(near-far);aspect??=this.#canvas.width/this.#canvas.height;const perspectiveMatrix=[f/aspect,0,0,0,0,f,0,0,0,0,(far+near)*nf,-1,0,0,2*far*near*nf,0];this.#setCameraUniform(`${name}_projection`,perspectiveMatrix,"mat4x4<f32>");const up=[0,1,0];const ff=normalize(sub(lookAt,position));const r=normalize(cross(ff,up));const u=cross(r,ff);const viewMatrix=[r[0],u[0],-ff[0],0,r[1],u[1],-ff[1],0,r[2],u[2],-ff[2],0,-dot(r,position),-dot(u,position),dot(ff,position),1];this.#setCameraUniform(`${name}_view`,viewMatrix,"mat4x4<f32>")}setCameraOrthographic(name,left=-1,right=1,top=1,bottom=-1,near=-1,far=1,position=[0,0,-5],lookAt=[0,0,0]){const lr=1/(right-left);const bt=1/(top-bottom);const nf=1/(near-far);const orthoMatrix=[2*lr,0,0,0,0,2*bt,0,0,0,0,nf,0,-(right+left)*lr,-(top+bottom)*bt,near*nf,1];this.#setCameraUniform(`${name}_projection`,orthoMatrix,"mat4x4<f32>");const up=[0,1,0];const ff=normalize(sub(lookAt,position));const r=normalize(cross(ff,up));const u=cross(r,ff);const viewMatrix=[r[0],u[0],-ff[0],0,r[1],u[1],-ff[1],0,r[2],u[2],-ff[2],0,-dot(r,position),-dot(u,position),dot(ff,position),1];this.#setCameraUniform(`${name}_view`,viewMatrix,"mat4x4<f32>")}addEventListener(name,callback,structSize=1){const data=Array(4).fill(0);this.setStorageMap(name,data,"Event",true,GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT);this.setStorage(`${name}_data`,`array<f32, ${structSize}>`,true,GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT);this.#events.set(this.#events_ids,{id:this.#events_ids,name,callback});++this.#events_ids}#createDynamicGroupBindings(shaderType,{index:renderPassIndex,internal},groupId=0){if(!shaderType){throw"`GPUShaderStage` is required"}let dynamicGroupBindings="";let bindingIndex=0;if(this.#uniforms.length){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var <uniform> params: Params;
`;bindingIndex+=1}if(this.#meshUniforms.length){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var <uniform> mesh: Mesh;
`;bindingIndex+=1}if(this.#cameraUniforms.length){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var <uniform> camera: Camera;
`;bindingIndex+=1}this.#storage.forEach(storageItem=>{const isInternal=internal===storageItem.internal;if(isInternal&&(!storageItem.shaderType||storageItem.shaderType&shaderType)){const T=storageItem.structName;let accessMode=getStorageAccessMode(shaderType,storageItem.shaderType);accessMode=bindingModes[accessMode];dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var <storage, ${accessMode}> ${storageItem.name}: ${T};
`;bindingIndex+=1}});if(this.#layers.length){if(!this.#layers.shaderType||this.#layers.shaderType&shaderType){let totalSize=0;this.#layers.forEach(layerItem=>totalSize+=layerItem.size);dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var <storage, read_write> layers: array<array<vec4f, ${totalSize}>>;
`;bindingIndex+=1}}this.#samplers.forEach(sampler=>{const isInternal=internal===sampler.internal;if(isInternal&&(!sampler.shaderType||sampler.shaderType&shaderType)){const T=sampler.descriptor.compare?"sampler_comparison":"sampler";dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${sampler.name}: ${T};
`;bindingIndex+=1}});this.#texturesStorage2d.forEach(texture=>{const isInternal=internal===texture.internal;if(isInternal&&(!texture.shaderType||texture.shaderType&shaderType)){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_storage_2d<rgba8unorm, write>;
`;bindingIndex+=1}});this.#textures2d.forEach(texture=>{const isInternal=internal===texture.internal;if(isInternal&&(!texture.shaderType||texture.shaderType&shaderType)){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_2d<f32>;
`;bindingIndex+=1}});this.#texturesDepth2d.forEach(texture=>{const isInternal=internal===texture.internal;if(isInternal&&(!texture.shaderType||texture.shaderType&shaderType)){if(texture.renderPassIndex!==renderPassIndex){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_depth_2d;
`;bindingIndex+=1}}});this.#textures2dArray.forEach(texture=>{const isInternal=internal===texture.internal;if(isInternal&&(!texture.shaderType||texture.shaderType&shaderType)){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${texture.name}: texture_2d_array<f32>;
`;bindingIndex+=1}});this.#texturesExternal.forEach(externalTexture=>{const isInternal=internal===externalTexture.internal;if(isInternal&&(!externalTexture.shaderType||externalTexture.shaderType&shaderType)){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${externalTexture.name}: texture_external;
`;bindingIndex+=1}});this.#bindingTextures.forEach(bindingTexture=>{const{usesRenderPass}=bindingTexture;if(usesRenderPass){if(GPUShaderStage.VERTEX===shaderType){return}if(renderPassIndex===bindingTexture.write.renderPassIndex){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.write.name}: texture_storage_2d<rgba8unorm, write>;
`;bindingIndex+=1}if(renderPassIndex===bindingTexture.read.renderPassIndex){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.read.name}: texture_2d<f32>;
`;bindingIndex+=1}return}const isInternal=internal===bindingTexture.internal;if(isInternal&&bindingTexture.write.shaderType&shaderType){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.write.name}: texture_storage_2d<rgba8unorm, write>;
`;bindingIndex+=1}if(isInternal&&bindingTexture.read.shaderType&shaderType){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${bindingTexture.read.name}: texture_2d<f32>;
`;bindingIndex+=1}});return dynamicGroupBindings}#createDynamicGroupBindingsUpdate(shaderType,{index:renderPassIndex,internal},groupId=0){if(!shaderType){throw"`GPUShaderStage` is required"}let dynamicGroupBindings="";let bindingIndex=0;this.#texturesExternal.forEach(externalTexture=>{const isInternal=internal===externalTexture.internal;if(isInternal&&(!externalTexture.shaderType||externalTexture.shaderType&shaderType)){dynamicGroupBindings+=`@group(${groupId}) @binding(${bindingIndex}) var ${externalTexture.name}: texture_external;
`;bindingIndex+=1}});return dynamicGroupBindings}setMeshDensity(numColumns,numRows){if(numColumns==0||numRows==0){throw"Parameters should be greater than 0"}this.#numColumns=numColumns;this.#numRows=numRows}#compileRenderPass=(renderPass,index)=>{let vertexShader=renderPass.vertexShader;let computeShader=renderPass.computeShader;let fragmentShader=renderPass.fragmentShader;let colorsVertWGSL=vertexShader;let colorsComputeWGSL=computeShader;let colorsFragWGSL=fragmentShader;let dynamicGroupBindingsVertex="";let dynamicGroupBindingsCompute="";let dynamicGroupBindingsFragment="";let dynamicStructParams="";let dynamicStructMesh="";let dynamicStructCamera="";this.#uniforms.forEach(u=>{u.type=u.type||"f32";dynamicStructParams+=`${u.name}:${u.type}, 
	`});if(this.#uniforms.length){dynamicStructParams=`struct Params {
	${dynamicStructParams}
}
`}this.#meshUniforms.forEach(u=>{u.type=u.type||"f32";dynamicStructMesh+=`${u.name}:${u.type}, 
	`});if(this.#meshUniforms.length){dynamicStructMesh=`struct Mesh {
	${dynamicStructMesh}
}
`}this.#cameraUniforms.forEach(u=>{u.type=u.type||"f32";dynamicStructCamera+=`${u.name}:${u.type}, 
	`});if(this.#cameraUniforms.length){dynamicStructCamera=`struct Camera {
	${dynamicStructCamera}
}
`}this.#constants.forEach(c=>{dynamicStructParams+=`const ${c.name}:${c.structName} = ${c.value};
`});dynamicStructParams+=dynamicStructMesh;dynamicStructParams+=dynamicStructCamera;renderPass.index=index;renderPass.hasVertexShader&&(dynamicGroupBindingsVertex+=dynamicStructParams);renderPass.hasComputeShader&&(dynamicGroupBindingsCompute+=dynamicStructParams);renderPass.hasFragmentShader&&(dynamicGroupBindingsFragment+=dynamicStructParams);renderPass.hasVertexShader&&(dynamicGroupBindingsVertex+=this.#createDynamicGroupBindings(GPUShaderStage.VERTEX,renderPass));renderPass.hasComputeShader&&(dynamicGroupBindingsCompute+=this.#createDynamicGroupBindings(GPUShaderStage.COMPUTE,renderPass));dynamicGroupBindingsFragment+=this.#createDynamicGroupBindings(GPUShaderStage.FRAGMENT,renderPass,1);renderPass.hasVertexShader&&(colorsVertWGSL=dynamicGroupBindingsVertex+defaultStructs+defaultVertexBody+colorsVertWGSL);renderPass.hasComputeShader&&(colorsComputeWGSL=dynamicGroupBindingsCompute+defaultStructs+colorsComputeWGSL);renderPass.hasFragmentShader&&(colorsFragWGSL=dynamicGroupBindingsFragment+defaultStructs+colorsFragWGSL);console.groupCollapsed(`Render Pass ${index}: (${renderPass.name})`);console.groupCollapsed("VERTEX");console.log(colorsVertWGSL);console.groupEnd();if(renderPass.hasComputeShader){console.groupCollapsed("COMPUTE");console.log(colorsComputeWGSL);console.groupEnd()}console.groupCollapsed("FRAGMENT");console.log(colorsFragWGSL);console.groupEnd();console.groupEnd();renderPass.hasVertexShader&&(renderPass.compiledShaders.vertex=colorsVertWGSL);renderPass.hasComputeShader&&(renderPass.compiledShaders.compute=colorsComputeWGSL);renderPass.hasFragmentShader&&(renderPass.compiledShaders.fragment=colorsFragWGSL)};#generateDataSize=()=>{const allShaders=this.#renderPasses.map(renderPass=>{const{vertex,compute,fragment}=renderPass.compiledShaders;return vertex+compute+fragment}).join("\n");this.#dataSize=dataSize(allShaders);this.#storage.forEach(s=>{if(!s.mapped){if(isArray(s.structName)){const typeData=getArrayTypeData(s.structName,this.#dataSize);s.structSize=typeData.size}else{const d=this.#dataSize.get(s.structName)||typeSizes[s.structName];if(!d){throw`${s.structName} has not been defined.`}s.structSize=d.bytes||d.size}}})};async init(renderPasses){this.#renderPasses=renderPasses.concat(this.#postRenderPasses);let hasComputeShaders=this.#renderPasses.some(renderPass=>renderPass.hasComputeShader);if(!hasComputeShaders&&this.#bindingTextures.length){throw" `setBindingTexture` requires at least one Compute Shader in a `RenderPass`"}if(!this.#adapter){try{this.#adapter=await navigator.gpu.requestAdapter()}catch(err){console.log(err)}}if(!this.#adapter){return false}if(!this.#device){this.#device=await this.#adapter.requestDevice();this.#device.label=new Date().getMilliseconds()}console.log(this.#device.limits);this.#device.lost.then(info=>console.log(info));if(this.#canvas!==null)this.#context=this.#canvas.getContext("webgpu");this.#presentationFormat||=navigator.gpu.getPreferredCanvasFormat();if(this.#canvasId){if(this.#fitWindow){this.#resizeCanvasToFitWindow()}else{this.#resizeCanvasToDefault()}}this.#renderPasses.forEach((r,i)=>{r.init?.(this);r.meshes.forEach(mesh=>this.#setMeshUniform(mesh.name,mesh.id,"u32"));this.createScreen(r);r.vertexBufferInfo=new VertexBufferInfo(r.vertexArray);r.vertexBuffer=this.#createAndMapBuffer(r.vertexArray,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST);this.#compileRenderPass(r,i)});this.#generateDataSize();this.#createBuffers();this.#createPipeline();return true}addRenderPass(renderPass,params){if(this.renderPasses?.length){throw"`addPostRenderPass` should be called prior `Points.init()`"}renderPass.params=params||{};const requiredNotFound=renderPass.required?.filter(i=>!renderPass.params[i]&&!Number.isInteger(renderPass.params[i]));if(requiredNotFound?.length){const paramsRequired=requiredNotFound.join(", ");console.warn(`addRenderPass: (${renderPass.name}) parameters required: ${paramsRequired}`)}this.#postRenderPasses.push(renderPass);renderPass.init(this)}get renderPasses(){return this.#renderPasses}createScreen(renderPass){if(renderPass.vertexArray.length!==0){return}const hasVertexAndFragmentShader=this.#renderPasses.some(renderPass=>renderPass.hasVertexAndFragmentShader);if(hasVertexAndFragmentShader){let colors=[new RGBAColor(1,0,0),new RGBAColor(0,1,0),new RGBAColor(0,0,1),new RGBAColor(1,1,0)];for(let xIndex=0;xIndex<this.#numRows;xIndex++){for(let yIndex=0;yIndex<this.#numColumns;yIndex++){const coordinate=new Coordinate(xIndex*this.#canvas.clientWidth/this.#numColumns,yIndex*this.#canvas.clientHeight/this.#numRows,.3);renderPass.addPoint(coordinate,this.#canvas.clientWidth/this.#numColumns,this.#canvas.clientHeight/this.#numRows,colors,this.#canvas)}}}}#createAndMapBuffer(data,usage,mappedAtCreation=true,size=null){const buffer=this.#device.createBuffer({mappedAtCreation,size:Math.max(size,data.byteLength),usage});new Float32Array(buffer.getMappedRange()).set(data);buffer.unmap();return buffer}#createBuffer(size,usage){return this.#device.createBuffer({size,usage})}#writeBuffer(buffer,values){this.#device.queue.writeBuffer(buffer,0,new Float32Array(values))}#createUniformValues(uniformsArray,structName="Params"){const paramsDataSize=this.#dataSize.get(structName);const paddings=paramsDataSize.paddings;const uniformsClone=structuredClone(uniformsArray);let arrayValues=uniformsClone.map(v=>{const padding=paddings[v.name]/4;if(padding){if(v.value.constructor!==Array){v.value=[v.value]}for(let i=0;i<padding;i++){v.value.push(0)}}return v.value}).flat(1);return{values:new Float32Array(arrayValues),paramsDataSize}}#createParametersUniforms(){const{values,paramsDataSize}=this.#createUniformValues(this.#uniforms);this.#uniforms.buffer=this.#createAndMapBuffer(values,GPUBufferUsage.UNIFORM+GPUBufferUsage.COPY_DST,true,paramsDataSize.bytes);if(this.#meshUniforms.length){const{values,paramsDataSize}=this.#createUniformValues(this.#meshUniforms);this.#meshUniforms.buffer=this.#createAndMapBuffer(values,GPUBufferUsage.UNIFORM+GPUBufferUsage.COPY_DST,true,paramsDataSize.bytes)}if(this.#cameraUniforms.length){const{values,paramsDataSize}=this.#createUniformValues(this.#cameraUniforms);this.#cameraUniforms.buffer=this.#createAndMapBuffer(values,GPUBufferUsage.UNIFORM+GPUBufferUsage.COPY_DST,true,paramsDataSize.bytes)}}#writeParametersUniforms(){if(!this.#uniforms.buffer){console.error("An attempt to create uniforms has been made but no setUniform has been called. Maybe an update was called before a setUniform.")}const{values}=this.#createUniformValues(this.#uniforms);this.#writeBuffer(this.#uniforms.buffer,values);if(this.#meshUniforms.length){const{values}=this.#createUniformValues(this.#meshUniforms);this.#writeBuffer(this.#meshUniforms.buffer,values)}if(this.#cameraUniforms.length){const{values}=this.#createUniformValues(this.#cameraUniforms);this.#writeBuffer(this.#cameraUniforms.buffer,values)}}#writeStorages(){this.#storage.forEach(storageItem=>{const{updated,stream}=storageItem;if(storageItem.mapped&&(updated||stream)){const values=new Float32Array(storageItem.array);this.#writeBuffer(storageItem.buffer,values);if(!stream){storageItem.updated=false}}})}#createBuffers(){this.#createParametersUniforms();this.#storage.forEach(storageItem=>{let usage=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;if(storageItem.read){let readStorageItem={name:storageItem.name,size:storageItem.structSize};if(storageItem.mapped){readStorageItem={name:storageItem.name,size:storageItem.array.length}}this.#readStorage.push(readStorageItem);usage=usage|GPUBufferUsage.COPY_SRC}storageItem.usage=usage;if(storageItem.mapped){const values=new Float32Array(storageItem.array);storageItem.buffer=this.#createAndMapBuffer(values,usage)}else{storageItem.buffer=this.#createBuffer(storageItem.structSize,usage)}});this.#readStorage.forEach(readStorageItem=>{readStorageItem.buffer=this.#device.createBuffer({size:readStorageItem.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})});if(this.#layers.length){let layersSize=0;this.#layers.forEach(layerItem=>{layersSize+=layerItem.size*layerItem.structSize});this.#layers.buffer=this.#createBuffer(layersSize,GPUBufferUsage.STORAGE)}this.#samplers.forEach(sampler=>sampler.resource=this.#device.createSampler(sampler.descriptor));this.#texturesStorage2d.forEach(textureStorage2d=>{textureStorage2d.texture=this.#device.createTexture({label:`_createBuffers, texturesStorage2d: ${textureStorage2d.name}`,size:this.#presentationSize,format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST})});this.#textures2d.forEach(texture2d=>{if(texture2d.imageTexture){const imageBitmap=texture2d.imageTexture.bitmap;const cubeTexture=this.#device.createTexture({label:`_createBuffers, textures2d: ${texture2d.name}`,size:[imageBitmap.width,imageBitmap.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});this.#device.queue.copyExternalImageToTexture({source:imageBitmap},{texture:cubeTexture},[imageBitmap.width,imageBitmap.height]);texture2d.texture=cubeTexture}else{this.#createTextureBindingToCopy(texture2d)}});this.#texturesDepth2d.forEach(texture2d=>{const renderPass=this.#renderPasses.find(renderPass=>renderPass.index===texture2d.renderPassIndex);texture2d.texture=renderPass.textureDepth});this.#textures2dArray.forEach(texture2dArray=>{if(texture2dArray.imageTextures){let cubeTexture;const imageBitmaps=texture2dArray.imageTextures.bitmaps;cubeTexture=this.#device.createTexture({label:`_createBuffers cubeTexture texture2dArray: ${texture2dArray.name}`,size:[imageBitmaps[0].width,imageBitmaps[0].height,imageBitmaps.length],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});imageBitmaps.forEach((imageBitmap,i)=>{this.#device.queue.copyExternalImageToTexture({source:imageBitmap},{texture:cubeTexture,origin:{x:0,y:0,z:i}},[imageBitmap.width,imageBitmap.height,1])});texture2dArray.texture=cubeTexture}else{this.#createTextureBindingToCopy(texture2dArray)}});this.#texturesExternal.forEach(externalTexture=>{externalTexture.texture=this.#device.importExternalTexture({label:`_createBuffers, externalTexture: ${externalTexture.name}`,source:externalTexture.video})});this.#bindingTextures.forEach(bindingTexture=>{bindingTexture.texture=this.#device.createTexture({label:`_createBuffers, bindingTexture: ${bindingTexture.name}`,size:bindingTexture.size||this.#presentationSize,format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST})})}#createTextureBindingToCopy(texture2d){texture2d.texture=this.#device.createTexture({label:texture2d.name,size:this.#presentationSize,format:this.#presentationFormat,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST})}#createTextureDepth(name){return this.#device.createTexture({label:name,size:this.#presentationSize,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING})}#createTextureToSize(texture2d,width,height){texture2d.texture=this.#device.createTexture({label:texture2d.name,size:[width,height],format:this.#presentationFormat,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST})}#createPipeline(){this.#renderPasses.forEach(renderPass=>{if(renderPass.hasComputeShader){this.#createBindGroup(renderPass,GPUShaderStage.COMPUTE);renderPass.computePipeline=this.#device.createComputePipeline({layout:this.#device.createPipelineLayout({bindGroupLayouts:[renderPass.bindGroupLayoutCompute]}),label:`_createPipeline() - ${renderPass.index}`,compute:{module:this.#device.createShaderModule({code:renderPass.compiledShaders.compute}),entryPoint:"main"}})}if(renderPass.hasVertexAndFragmentShader){this.#createBindGroup(renderPass,GPUShaderStage.VERTEX);this.#createBindGroup(renderPass,GPUShaderStage.FRAGMENT);let depthStencil=undefined;if(renderPass.depthWriteEnabled){depthStencil={depthWriteEnabled:renderPass.depthWriteEnabled,depthCompare:"less",format:"depth32float"}}renderPass.renderPipeline=this.#device.createRenderPipeline({label:`render pipeline: renderPass ${renderPass.index} (${renderPass.name})`,layout:this.#device.createPipelineLayout({bindGroupLayouts:[renderPass.bindGroupLayoutVertex,renderPass.bindGroupLayoutFragment]}),primitive:{topology:renderPass.topology,cullMode:renderPass.cullMode,frontFace:renderPass.frontFace},depthStencil,vertex:{module:this.#device.createShaderModule({code:renderPass.compiledShaders.vertex}),entryPoint:"main",buffers:[{arrayStride:renderPass.vertexBufferInfo.vertexSize,attributes:[{shaderLocation:0,offset:renderPass.vertexBufferInfo.vertexOffset,format:"float32x4"},{shaderLocation:1,offset:renderPass.vertexBufferInfo.colorOffset,format:"float32x4"},{shaderLocation:2,offset:renderPass.vertexBufferInfo.uvOffset,format:"float32x2"},{shaderLocation:3,offset:renderPass.vertexBufferInfo.normalOffset,format:"float32x3"},{shaderLocation:4,offset:renderPass.vertexBufferInfo.idOffset,format:"uint32"},{shaderLocation:5,offset:renderPass.vertexBufferInfo.barycentricsOffset,format:"float32x3"}]}]},fragment:{module:this.#device.createShaderModule({code:renderPass.compiledShaders.fragment}),entryPoint:"main",targets:[{format:this.#presentationFormat,blend:{alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},writeMask:GPUColorWrite.ALL}]}})}})}#createEntries(shaderType,{index:renderPassIndex,internal}){let entries=[];let bindingIndex=0;if(this.#uniforms.length){entries.push({binding:bindingIndex++,resource:{label:"uniform",buffer:this.#uniforms.buffer},buffer:{type:"uniform"}})}if(this.#meshUniforms.length){entries.push({binding:bindingIndex++,resource:{label:"uniform",buffer:this.#meshUniforms.buffer},buffer:{type:"uniform"}})}if(this.#cameraUniforms.length){entries.push({binding:bindingIndex++,resource:{label:"uniform",buffer:this.#cameraUniforms.buffer},buffer:{type:"uniform"}})}this.#storage.forEach(storageItem=>{const isInternal=internal===storageItem.internal;if(isInternal&&(!storageItem.shaderType||storageItem.shaderType&shaderType)){let type=getStorageAccessMode(shaderType,storageItem.shaderType);type=entriesModes[type];entries.push({binding:bindingIndex++,resource:{label:"storage",buffer:storageItem.buffer},buffer:{type}})}});if(this.#layers.length){if(!this.#layers.shaderType||this.#layers.shaderType&shaderType){entries.push({binding:bindingIndex++,resource:{label:"layer",buffer:this.#layers.buffer},buffer:{type:"storage"}})}}this.#samplers.forEach(sampler=>{const isInternal=internal===sampler.internal;if(isInternal&&(!sampler.shaderType||sampler.shaderType&shaderType)){entries.push({binding:bindingIndex++,resource:sampler.resource,sampler:{type:sampler.descriptor.compare?"comparison":"filtering"}})}});this.#texturesStorage2d.forEach(textureStorage2d=>{const isInternal=internal===textureStorage2d.internal;if(isInternal&&(!textureStorage2d.shaderType||textureStorage2d.shaderType&shaderType)){entries.push({label:"texture storage 2d",binding:bindingIndex++,resource:textureStorage2d.texture.createView(),storageTexture:{type:"write-only"}})}});this.#textures2d.forEach(texture2d=>{const isInternal=internal===texture2d.internal;if(isInternal&&(!texture2d.shaderType||texture2d.shaderType&shaderType)){entries.push({label:"texture 2d",binding:bindingIndex++,resource:texture2d.texture.createView(),texture:{type:"float"}})}});this.#texturesDepth2d.forEach(texture2d=>{if(texture2d.renderPassIndex!==renderPassIndex){const isInternal=internal===texture2d.internal;if(isInternal&&(!texture2d.shaderType||texture2d.shaderType&shaderType)){const renderPass=this.#renderPasses.find(renderPass=>renderPass.index===texture2d.renderPassIndex);texture2d.texture=renderPass.textureDepth;entries.push({label:"texture depth 2d",binding:bindingIndex++,resource:texture2d.texture.createView(),texture:{sampleType:"depth",viewDimension:"2d",multisampled:false}})}}});this.#textures2dArray.forEach(texture2dArray=>{const isInternal=internal===texture2dArray.internal;if(isInternal&&(!texture2dArray.shaderType||texture2dArray.shaderType&shaderType)){entries.push({label:"texture 2d array",binding:bindingIndex++,resource:texture2dArray.texture.createView({dimension:"2d-array",baseArrayLayer:0,arrayLayerCount:texture2dArray.imageTextures.bitmaps.length}),texture:{type:"float",viewDimension:"2d-array"}})}});this.#texturesExternal.forEach(externalTexture=>{const isInternal=internal===externalTexture.internal;if(isInternal&&(!externalTexture.shaderType||externalTexture.shaderType&shaderType)){entries.push({label:"external texture",binding:bindingIndex++,resource:externalTexture.texture,externalTexture:{}})}});this.#bindingTextures.forEach(bindingTexture=>{const{usesRenderPass}=bindingTexture;if(usesRenderPass){if(GPUShaderStage.VERTEX===shaderType){return}if(bindingTexture.read.renderPassIndex===renderPassIndex){entries.push({label:`binding texture 2: name: ${bindingTexture.read.name}`,binding:bindingIndex++,resource:bindingTexture.texture.createView(),texture:{type:"float"}})}if(bindingTexture.write.renderPassIndex===renderPassIndex){entries.push({label:`binding texture: name: ${bindingTexture.write.name}`,binding:bindingIndex++,resource:bindingTexture.texture.createView(),storageTexture:{type:"write-only",format:"rgba8unorm"}})}return}const isInternal=internal===bindingTexture.internal;if(isInternal&&bindingTexture.read.shaderType&shaderType){entries.push({label:`binding texture 2: name: ${bindingTexture.read.name}`,binding:bindingIndex++,resource:bindingTexture.texture.createView(),texture:{type:"float"}})}if(isInternal&&bindingTexture.write.shaderType&shaderType){entries.push({label:`binding texture: name: ${bindingTexture.write.name}`,binding:bindingIndex++,resource:bindingTexture.texture.createView(),storageTexture:{type:"write-only",format:"rgba8unorm"}})}});entries.forEach(entry=>entry.visibility=shaderType);return entries}#createEntriesUpdate(shaderType,{index:renderPassIndex,internal}){let entries=[];let bindingIndex=0;this.#texturesExternal.forEach(externalTexture=>{const isInternal=internal===externalTexture.internal;if(isInternal&&(!externalTexture.shaderType||externalTexture.shaderType&shaderType)){entries.push({label:"external texture",binding:bindingIndex++,resource:externalTexture.texture,externalTexture:{}})}});entries.forEach(entry=>entry.visibility=shaderType);return entries}#createBindGroup(renderPass,shaderType){const hasComputeShader=shaderType===GPUShaderStage.COMPUTE&&renderPass.hasComputeShader;const hasVertexShader=shaderType===GPUShaderStage.VERTEX&&renderPass.hasVertexShader;const hasFragmentShader=shaderType===GPUShaderStage.FRAGMENT&&renderPass.hasFragmentShader;const entries=this.#createEntries(shaderType,renderPass);if(entries.length){const bindGroupLayout=this.#device.createBindGroupLayout({entries});const bindGroup=this.#device.createBindGroup({label:`_createBindGroup a ${shaderType} - ${renderPass.name}`,layout:bindGroupLayout,entries});if(hasComputeShader){renderPass.bindGroupLayoutCompute=bindGroupLayout;renderPass.computeBindGroup=bindGroup}if(hasVertexShader){renderPass.bindGroupLayoutVertex=bindGroupLayout;renderPass.vertexBindGroup=bindGroup}if(hasFragmentShader){renderPass.bindGroupLayoutFragment=bindGroupLayout;renderPass.fragmentBindGroup=bindGroup}}}#passBindGroup(renderPass,shaderType){const hasComputeShader=shaderType===GPUShaderStage.COMPUTE&&renderPass.hasComputeShader;const hasVertexShader=shaderType===GPUShaderStage.VERTEX&&renderPass.hasVertexShader;const hasFragmentShader=shaderType===GPUShaderStage.FRAGMENT&&renderPass.hasFragmentShader;const entries=this.#createEntries(shaderType,renderPass);if(entries.length){let bindGroupLayout=null;if(hasComputeShader){bindGroupLayout=renderPass.bindGroupLayoutCompute}if(hasVertexShader){bindGroupLayout=renderPass.bindGroupLayoutVertex}if(hasFragmentShader){bindGroupLayout=renderPass.bindGroupLayoutFragment}const bindGroup=this.#device.createBindGroup({label:`_passBindGroup 0`,layout:bindGroupLayout,entries});if(hasComputeShader){renderPass.computeBindGroup=bindGroup}if(hasVertexShader){renderPass.vertexBindGroup=bindGroup}if(hasFragmentShader){renderPass.fragmentBindGroup=bindGroup}}}async update(){if(!this.#canvas||!this.#device)return;this.#delta=this.#clock.getDelta();this.#time=this.#clock.time;this.#epoch=+new Date/1e3;this.setUniform(UniformKeys.TIME,this.#time);this.setUniform(UniformKeys.DELTA,this.#delta);this.setUniform(UniformKeys.EPOCH,this.#epoch);this.setUniform(UniformKeys.MOUSE_CLICK,this.#mouseClick);this.setUniform(UniformKeys.MOUSE_DOWN,this.#mouseDown);this.setUniform(UniformKeys.MOUSE_WHEEL,this.#mouseWheel);this.setUniform(UniformKeys.SCREEN,[this.#canvas.width,this.#canvas.height]);this.setUniform(UniformKeys.MOUSE,[this.#mouseX,this.#mouseY]);this.setUniform(UniformKeys.MOUSE_DELTA,this.#mouseDelta);this.#writeParametersUniforms();this.#writeStorages();this.#sounds.forEach(sound=>sound.analyser?.getByteFrequencyData(sound.data));this.#texturesExternal.forEach(externalTexture=>{externalTexture.texture=this.#device.importExternalTexture({label:`update, externalTexture: ${externalTexture.name}`,source:externalTexture.video});if("requestVideoFrameCallback"in externalTexture.video){externalTexture.video.requestVideoFrameCallback(_=>{})}});const commandEncoder=this.#device.createCommandEncoder();const swapChainTexture=this.#context.getCurrentTexture();this.#renderPasses.forEach(renderPass=>{if(renderPass.hasVertexAndFragmentShader){renderPass.descriptor.colorAttachments[0].view=swapChainTexture.createView();if(renderPass.depthWriteEnabled&&(!renderPass.descriptor.depthStencilAttachment.view||this.#screenResized)){renderPass.descriptor.depthStencilAttachment.view=renderPass.textureDepth.createView()}const isSameDevice=this.#device===renderPass.device;if(!isSameDevice||!renderPass.bundle||this.#texturesExternal.length||this.#screenResized||this.#textureUpdated){this.#passBindGroup(renderPass,GPUShaderStage.FRAGMENT);this.#passBindGroup(renderPass,GPUShaderStage.VERTEX);const bundleEncoderDescriptor={colorFormats:[this.#presentationFormat],sampleCount:1};if(renderPass.depthWriteEnabled){bundleEncoderDescriptor.depthStencilFormat="depth32float"}const bundleEncoder=this.#device.createRenderBundleEncoder(bundleEncoderDescriptor);bundleEncoder.setPipeline(renderPass.renderPipeline);if(this.#uniforms.length){bundleEncoder.setBindGroup(0,renderPass.vertexBindGroup);bundleEncoder.setBindGroup(1,renderPass.fragmentBindGroup)}bundleEncoder.setVertexBuffer(0,renderPass.vertexBuffer);const isThereInstancing=renderPass.meshes.some(mesh=>mesh.instanceCount>1);if(isThereInstancing){let vertexOffset=0;renderPass.meshes.forEach(mesh=>{bundleEncoder.draw(mesh.verticesCount,mesh.instanceCount,vertexOffset,0);vertexOffset=mesh.verticesCount})}else{bundleEncoder.draw(renderPass.vertexBufferInfo.vertexCount,1)}renderPass.bundle=bundleEncoder.finish();renderPass.device=this.#device}const passEncoder=commandEncoder.beginRenderPass(renderPass.descriptor);passEncoder.executeBundles([renderPass.bundle]);passEncoder.end();this.#textures2d.forEach(texture2d=>{if(texture2d.renderPassIndex===renderPass.index||!Number.isInteger(texture2d.renderPassIndex)){if(texture2d.copyCurrentTexture){commandEncoder.copyTextureToTexture({texture:swapChainTexture},{texture:texture2d.texture},this.#presentationSize)}}});this.#texturesToCopy.forEach(texturePair=>{commandEncoder.copyTextureToTexture({texture:texturePair.a},{texture:texturePair.b},[texturePair.a.width,texturePair.a.height])});this.#texturesToCopy=[]}if(renderPass.hasComputeShader){if(this.#texturesExternal.length||!renderPass.computeBindGroup){this.#passBindGroup(renderPass,GPUShaderStage.COMPUTE)}const passEncoder=commandEncoder.beginComputePass();passEncoder.setPipeline(renderPass.computePipeline);if(this.#uniforms.length){passEncoder.setBindGroup(0,renderPass.computeBindGroup)}passEncoder.dispatchWorkgroups(renderPass.workgroupCountX,renderPass.workgroupCountY,renderPass.workgroupCountZ);passEncoder.end()}});this.#screenResized=false;this.#textureUpdated=false;this.#readStorage.forEach(readStorageItem=>{let storageItem=this.#storage.find(storageItem=>storageItem.name===readStorageItem.name);commandEncoder.copyBufferToBuffer(storageItem.buffer,0,readStorageItem.buffer,0,readStorageItem.buffer.size)});this.#commandsFinished.push(commandEncoder.finish());this.#device.queue.submit(this.#commandsFinished);this.#commandsFinished=[];this.#mouseClick=false;this.#mouseWheel=false;this.#mouseDelta=[0,0];await this.read()}async read(){for(const[key,event]of this.#events){const{name}=event;const eventRead=await this.readStorage(name);if(eventRead){const id=eventRead[0];if(id!=0){const dataRead=await this.readStorage(`${name}_data`);event?.callback(dataRead);const storageToUpdate=this.#nameExists(this.#storage,name);const data=storageToUpdate.array;data[0]=0;this.setStorageMap(name,data)}}}}get canvas(){return this.#canvas}get device(){return this.#device}get context(){return this.#context}get buffer(){return this.#buffer}get fullscreen(){return this.#fullscreen}set fullscreen(value){if(value){this.#lastFitWindow=this.#fitWindow;this.fitWindow=value;this.#canvas.requestFullscreen().catch(err=>{throw`Error attempting to enable fullscreen mode: ${err.message} (${err.name})`});this.#fullscreen=true}else{document.exitFullscreen();this.#fullscreen=false;this.#resizeCanvasToDefault()}}set fitWindow(value){if(!this.#context){throw"fitWindow must be assigned after Points.init() call or you don't have a Canvas assigned in the constructor"}this.#fitWindow=value;if(this.#fitWindow){this.#resizeCanvasToFitWindow()}else{this.#resizeCanvasToDefault()}}get presentationFormat(){return this.#presentationFormat}set presentationFormat(value){this.#presentationFormat=value}destroy(){this.#uniforms=new UniformsArray;this.#meshUniforms=new UniformsArray;this.#cameraUniforms=new UniformsArray;this.#texturesExternal.forEach(textureExternal=>{const stream=textureExternal?.video.srcObject;stream?.getTracks().forEach(track=>track.stop())})}}export{RenderPass,RenderPasses,Points as default};
